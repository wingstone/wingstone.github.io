<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>排列与组合 | wingstone's blog</title>
<link rel=stylesheet href=/css/style.css>
<link rel=stylesheet href=/css/fonts.css>
<link rel=icon href=/icons/16.png>
</head>
<body>
<nav>
<ul class=menu>
<li><a href=/>Home</a></li>
<li><a href=/categories/>Categories</a></li>
<li><a href=/tags/>Tags</a></li>
<li><a href=/archives/>Archives</a></li>
<li><a href=/about/>About</a></li>
<li><a href=/index.xml>Subscribe</a></li>
</ul>
<hr>
</nav>
<div class=article-meta>
<h2><span class=title>排列与组合</span></h2>
<h3 class=date>2020/09/07</h3>
</div><h2>目录</h2>
<nav id=TableOfContents>
<ul>
<li><a href=#排列与组合的区别>排列与组合的区别</a></li>
<li><a href=#排列的算法框架>排列的算法框架</a></li>
<li><a href=#组合的算法框架>组合的算法框架</a></li>
</ul>
</nav>
<main>
<p>关于排列与组合的算法问题</p>
<h2 id=排列与组合的区别>排列与组合的区别</h2>
<p>实际上，排列意味着数据一样，数据出现的顺序不一样；
组合意味着，数据不一样，与数据的顺序无关；</p>
<h2 id=排列的算法框架>排列的算法框架</h2>
<p>如果数据没有重复，直接套用回溯算法框架即可；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>

    <span style=color:#66d9ef>void</span> Help(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> results, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> result, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> num, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> flags)
    {
        <span style=color:#66d9ef>if</span> (result.size() <span style=color:#f92672>==</span> num.size())
        {
            results.push_back(result);
            <span style=color:#66d9ef>return</span>;
        }

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> flags.size(); i<span style=color:#f92672>++</span>)
        {
            <span style=color:#66d9ef>if</span> (flags[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)  <span style=color:#75715e>//跳过已经取过的数
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>continue</span>;

            result.push_back(num[i]);
            flags[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
            Help(results, result, num, flags);
            flags[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
            result.pop_back();
        }
    }

    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> permute(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> results;
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> result;
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> flags(nums.size(), <span style=color:#ae81ff>1</span>);;
        Help(results, result, nums, flags);

        <span style=color:#66d9ef>return</span> results;
    }
};
</code></pre></div><p>对于特殊情况，比如数据中有重复的数据，需要考虑重复的情况；为了方便识别重复的情况，需要对数据源进行排序，这样在计算过程中，对于重复的情况，只需要向前单向查找是否重复即可；</p>
<h2 id=组合的算法框架>组合的算法框架</h2>
<p>如果直接套用回溯框架，就会导致重复问题，因为组合与顺序无关，先选跟后选可能会产生同一组数据；</p>
<p>解决办法：在回溯的过程中，只向后查找，而不向当前节点的前面查找，这样就不会产生重复的组合；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>

    <span style=color:#66d9ef>void</span> FindAll(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> candidates, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> results, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>result, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>current, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>target, <span style=color:#66d9ef>int</span> id)
    {
        <span style=color:#66d9ef>if</span> (current <span style=color:#f92672>==</span> target)
        {
            results.push_back(result);
            <span style=color:#66d9ef>return</span>;
        }

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> id; i <span style=color:#f92672>&lt;</span> candidates.size(); i<span style=color:#f92672>++</span>)
        {
            <span style=color:#66d9ef>if</span> (candidates[i]  <span style=color:#f92672>&lt;=</span> target <span style=color:#f92672>-</span> current )
            {
                result.push_back(candidates[i]);
                current <span style=color:#f92672>+=</span> candidates[i];
                FindAll(candidates, results, result, current, target, i);
                current <span style=color:#f92672>-=</span> candidates[i];
                result.pop_back();
            }
            <span style=color:#66d9ef>else</span>
            {
                <span style=color:#66d9ef>break</span>;
            }
        }
    }

    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> combinationSum(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> candidates, <span style=color:#66d9ef>int</span> target) {

        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> results;
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> result;
        <span style=color:#66d9ef>int</span> current <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

        FindAll(candidates, results, result, current, target, <span style=color:#ae81ff>0</span>);

        <span style=color:#66d9ef>return</span> results;
    }
};
</code></pre></div><p>同样对于数据中有重复的数据，需要考虑重复的情况；需要对数据源进行排序，在计算过程中，对于重复的情况，只需要向前单向查找是否重复即可；</p>
</main>
<footer>
<script defer src=//yihui.org/js/math-code.js></script>
<script defer src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script defer src=//yihui.org/js/center-img.js></script>
<hr>
© <a href=https://wingstone.github.io>wingstone</a> 2020 &ndash; 2022 | <a href=https://github.com/wingstone>Github</a> | <a href=https://www.zhihu.com/people/wu-zhu-32-40>Zhihu</a> | <a href=https://www.shadertoy.com/user/wingstone>Shadertoy</a>
</footer>
</body>
</html>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 8" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>