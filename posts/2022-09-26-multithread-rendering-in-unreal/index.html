<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>multithread rendering in unreal | wingstone's blog</title>
<link rel=stylesheet href=/css/style.css>
<link rel=stylesheet href=/css/fonts.css>
<link rel=icon href=/icons/16.png>
</head>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<body>
<nav>
<ul class=menu>
<li><a href=/ class=menu-item>Home</a></li>
<li><a href=/categories/ class=menu-item>Categories</a></li>
<li><a href=/tags/ class=menu-item>Tags</a></li>
<li><a href=/archives/ class=menu-item>Archives</a></li>
<li><a href=/about/ class=menu-item>About</a></li>
<li><a href=/index.xml class=menu-item>Subscribe</a></li>
</ul>
<hr>
</nav>
<div class=article-meta>
<h2><span class=title>multithread rendering in unreal</span></h2>
<h3 class=author>wingstone</h3>
<h3 class=date>2022/09/26</h3>
<div>
<span id=busuanzi_container_page_pv> 阅读量 <span id=busuanzi_value_page_pv></span> 次</span>
</div>
</div><h2>目录</h2>
<nav id=TableOfContents>
<ul>
<li><a href=#game-thread向rendering-thread传递指令>Game Thread向Rendering Thread传递指令</a></li>
<li><a href=#game-thread与rendering-thread同步>Game Thread与Rendering Thread同步</a></li>
<li><a href=#rendering-thread向rhi-thread传递指令>Rendering Thread向RHI Thread传递指令</a></li>
<li><a href=#game-thread与rhi-thread同步>Game Thread与RHI Thread同步</a></li>
</ul>
</nav>
<main>
<p>记录unreal引擎中的多线程渲染框架下的同步问题</p>
<h2 id=game-thread向rendering-thread传递指令>Game Thread向Rendering Thread传递指令</h2>
<p>通过RenderingThread.h中的<code>ENQUEUE_RENDER_COMMAND</code>宏来进行指令传递；</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RenderingThread.h
</span><span style=color:#75715e></span><span style=color:#75715e>#define ENQUEUE_RENDER_COMMAND(Type) \
</span><span style=color:#75715e>	struct Type##Name \
</span><span style=color:#75715e>	{  \
</span><span style=color:#75715e>		static const char* CStr() { return #Type; } \
</span><span style=color:#75715e>		static const TCHAR* TStr() { return TEXT(#Type); } \
</span><span style=color:#75715e>	}; \
</span><span style=color:#75715e>	EnqueueUniqueRenderCommand&lt;Type##Name&gt;
</span></code></pre></td></tr></table>
</div>
</div><p>顺着宏指令接着展开</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RenderingThread.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> TSTR, <span style=color:#66d9ef>typename</span> LAMBDA<span style=color:#f92672>&gt;</span>
FORCEINLINE_DEBUGGABLE <span style=color:#66d9ef>void</span> EnqueueUniqueRenderCommand(LAMBDA<span style=color:#f92672>&amp;&amp;</span> Lambda)
{
	<span style=color:#75715e>//QUICK_SCOPE_CYCLE_COUNTER(STAT_EnqueueUniqueRenderCommand);
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>typedef</span> TEnqueueUniqueRenderCommandType<span style=color:#f92672>&lt;</span>TSTR, LAMBDA<span style=color:#f92672>&gt;</span> EURCType;

<span style=color:#75715e>#if 0</span><span style=color:#75715e> // UE_SERVER &amp;&amp; UE_BUILD_DEBUG
</span><span style=color:#75715e>	UE_LOG(LogRHI, Warning, TEXT(&#34;Render command &#39;%s&#39; is being executed on a dedicated server.&#34;), TSTR::TStr())
</span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> (IsInRenderingThread())
	{
		FRHICommandListImmediate<span style=color:#f92672>&amp;</span> RHICmdList <span style=color:#f92672>=</span> GetImmediateCommandList_ForRenderCommand();
		Lambda(RHICmdList);
	}
	<span style=color:#66d9ef>else</span>
	{
		<span style=color:#66d9ef>if</span> (ShouldExecuteOnRenderThread())  <span style=color:#75715e>//这里为在GameThread中真正执行的指令
</span><span style=color:#75715e></span>		{
			CheckNotBlockedOnRenderThread();
			TGraphTask<span style=color:#f92672>&lt;</span>EURCType<span style=color:#f92672>&gt;::</span>CreateTask().ConstructAndDispatchWhenReady(Forward<span style=color:#f92672>&lt;</span>LAMBDA<span style=color:#f92672>&gt;</span>(Lambda));
		}
		<span style=color:#66d9ef>else</span>
		{
			EURCType <span style=color:#a6e22e>TempCommand</span>(Forward<span style=color:#f92672>&lt;</span>LAMBDA<span style=color:#f92672>&gt;</span>(Lambda));
			FScopeCycleCounter <span style=color:#a6e22e>EURCMacro_Scope</span>(TempCommand.GetStatId());
			TempCommand.DoTask(ENamedThreads<span style=color:#f92672>::</span>GameThread, FGraphEventRef());
		}
	}
}

</code></pre></td></tr></table>
</div>
</div><p>语句<code>TGraphTask&lt;EURCType>::CreateTask().ConstructAndDispatchWhenReady(Forward&lt;LAMBDA>(Lambda));</code>负责task任务的分发，并且将任务分发到rendering thread上面；为什么该语句可以分发到rendering thread上，可以继续跟进；</p>
<p>跟进后发现<code>ConstructAndDispatchWhenReady</code>的实现如下：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// TaskGraphInterfaces.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>...T<span style=color:#f92672>&gt;</span>
FGraphEventRef ConstructAndDispatchWhenReady(T<span style=color:#f92672>&amp;&amp;</span>... Args)
{
    <span style=color:#66d9ef>new</span> ((<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>Owner<span style=color:#f92672>-&gt;</span>TaskStorage) TTask(Forward<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(Args)...);
    <span style=color:#66d9ef>return</span> Owner<span style=color:#f92672>-&gt;</span>Setup(Prerequisites, CurrentThreadIfKnown);
}
</code></pre></td></tr></table>
</div>
</div><p>其中<code>Setup</code>的实现如下：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>//  TaskGraphInterfaces.h
</span><span style=color:#75715e></span>FGraphEventRef <span style=color:#a6e22e>Setup</span>(<span style=color:#66d9ef>const</span> FGraphEventArray<span style=color:#f92672>*</span> Prerequisites <span style=color:#f92672>=</span> NULL, ENamedThreads<span style=color:#f92672>::</span>Type CurrentThreadIfKnown <span style=color:#f92672>=</span> ENamedThreads<span style=color:#f92672>::</span>AnyThread)
{
    TaskTrace<span style=color:#f92672>::</span>Launched(GetTraceId(), <span style=color:#66d9ef>nullptr</span>, Subsequents.IsValid(), ((TTask<span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>TaskStorage)<span style=color:#f92672>-&gt;</span>GetDesiredThread());

    FGraphEventRef ReturnedEventRef <span style=color:#f92672>=</span> Subsequents; <span style=color:#75715e>// very important so that this doesn&#39;t get destroyed before we return
</span><span style=color:#75715e></span>    SetupPrereqs(Prerequisites, CurrentThreadIfKnown, true);
    <span style=color:#66d9ef>return</span> ReturnedEventRef;
}
</code></pre></td></tr></table>
</div>
</div><p>其中的<code>((TTask*)&TaskStorage)->GetDesiredThread()</code>决定了要分发的thread类型；而我们要分发的任务为<code>EURCType</code>，即<code>TEnqueueUniqueRenderCommandType&lt;TSTR, LAMBDA></code>，能查看该类继承自<code>FRenderCommand</code>类，而该类中包含有以下函数：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RenderingThread.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> ENamedThreads<span style=color:#f92672>::</span>Type GetDesiredThread()
{
    check(<span style=color:#f92672>!</span>GIsThreadedRendering <span style=color:#f92672>||</span> ENamedThreads<span style=color:#f92672>::</span>GetRenderThread() <span style=color:#f92672>!=</span> ENamedThreads<span style=color:#f92672>::</span>GameThread);
    <span style=color:#66d9ef>return</span> ENamedThreads<span style=color:#f92672>::</span>GetRenderThread();
}
</code></pre></td></tr></table>
</div>
</div><p>到此，<code>ENamedThreads::GetRenderThread()</code>便指示出了我们最终要分发的线程为rendering thread；</p>
<h2 id=game-thread与rendering-thread同步>Game Thread与Rendering Thread同步</h2>
<p>直接参考前人的总结<a href=https://zhuanlan.zhihu.com/p/80676205>UE4主线程与渲染线程同步</a>；同步位置在Tick函数的以下部分：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// LaunchEngineLoop.cpp
</span><span style=color:#75715e></span>{
    SCOPE_CYCLE_COUNTER(STAT_FrameSyncTime);
    <span style=color:#75715e>// this could be perhaps moved down to get greater parallelism
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Sync game and render thread. Either total sync or allowing one frame lag.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>static</span> FFrameEndSync FrameEndSync;
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>auto</span> CVarAllowOneFrameThreadLag <span style=color:#f92672>=</span> IConsoleManager<span style=color:#f92672>::</span>Get().FindTConsoleVariableDataInt(TEXT(<span style=color:#e6db74>&#34;r.OneFrameThreadLag&#34;</span>));
    FrameEndSync.Sync( CVarAllowOneFrameThreadLag<span style=color:#f92672>-&gt;</span>GetValueOnGameThread() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> );
}
</code></pre></td></tr></table>
</div>
</div><p>其中Sync函数用来完成同步，并且允许间隔一帧；Sync函数中同步部分的代码为：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// UnrealEngine.cpp
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> FFrameEndSync<span style=color:#f92672>::</span>Sync( <span style=color:#66d9ef>bool</span> bAllowOneFrameThreadLag )
{
    <span style=color:#75715e>// blablabla...
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// Since this is the frame end sync, allow sync with the RHI and GPU (true).
</span><span style=color:#75715e></span>	Fence[EventIndex].BeginFence(true);

    <span style=color:#75715e>// blablabla...
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// Use two events if we allow a one frame lag.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span>( bAllowOneFrameThreadLag )
	{
		EventIndex <span style=color:#f92672>=</span> (EventIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>;
	}

    <span style=color:#75715e>// blablabla...
</span><span style=color:#75715e></span>
	Fence[EventIndex].Wait(bEmptyGameThreadTasks);  <span style=color:#75715e>// here we also opportunistically execute game thread tasks while we wait
</span><span style=color:#75715e></span>}

</code></pre></td></tr></table>
</div>
</div><p>BeginFence的代码如下：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RenderingThread.cpp
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> FRenderCommandFence<span style=color:#f92672>::</span>BeginFence(<span style=color:#66d9ef>bool</span> bSyncToRHIAndGPU)
{
    <span style=color:#75715e>// blablabla...
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// Sync Game Thread with Render Thread only
</span><span style=color:#75715e></span>    DECLARE_CYCLE_STAT(TEXT(<span style=color:#e6db74>&#34;FNullGraphTask.FenceRenderCommand&#34;</span>),
    STAT_FNullGraphTask_FenceRenderCommand,
        STATGROUP_TaskGraphTasks);

    CompletionEvent <span style=color:#f92672>=</span> TGraphTask<span style=color:#f92672>&lt;</span>FNullGraphTask<span style=color:#f92672>&gt;::</span>CreateTask(NULL, ENamedThreads<span style=color:#f92672>::</span>GameThread).ConstructAndDispatchWhenReady(
        GET_STATID(STAT_FNullGraphTask_FenceRenderCommand), ENamedThreads<span style=color:#f92672>::</span>GetRenderThread());
}
</code></pre></td></tr></table>
</div>
</div><p>可以看到，BeginFence会创建一个FNullGraphTask任务添加到RenderThread中；</p>
<p>而Sync函数中的Wait函数代码如下：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RenderingThread.cpp
</span><span style=color:#75715e></span><span style=color:#75715e>/**
</span><span style=color:#75715e> * Waits for pending fence commands to retire.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>void</span> FRenderCommandFence<span style=color:#f92672>::</span>Wait(<span style=color:#66d9ef>bool</span> bProcessGameThreadTasks) <span style=color:#66d9ef>const</span>
{
	<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>IsFenceComplete())
	{
		StopRenderCommandFenceBundler();
<span style=color:#75715e>#if 0</span><span style=color:#75715e>
</span><span style=color:#75715e>		// on most platforms this is a better solution because it doesn&#39;t spin
</span><span style=color:#75715e>		// windows needs to pump messages
</span><span style=color:#75715e>		if (bProcessGameThreadTasks)
</span><span style=color:#75715e>		{
</span><span style=color:#75715e>			QUICK_SCOPE_CYCLE_COUNTER(STAT_FRenderCommandFence_Wait);
</span><span style=color:#75715e>			FTaskGraphInterface::Get().WaitUntilTaskCompletes(CompletionEvent, ENamedThreads::GameThread);
</span><span style=color:#75715e>		}
</span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span>		GameThreadWaitForTask(CompletionEvent, TriggerThreadIndex, bProcessGameThreadTasks);
	}
}

</code></pre></td></tr></table>
</div>
</div><p>可以看到GameThread会通过GameThreadWaitForTask函数来等待之前（隔帧或者当前帧）创建的FNullGraphTask任务完成，若FNullGraphTask任务完成了，则之前RenderingThread队列中的任务也都完成了；也就完成了Game Thread与Rendering Thread的同步；</p>
<h2 id=rendering-thread向rhi-thread传递指令>Rendering Thread向RHI Thread传递指令</h2>
<p>在RHICommandList.h中封装了大量可以在RenderingThread中可以调用的api，以其中的以下代码为例：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RHICommandList.h
</span><span style=color:#75715e></span>FORCEINLINE_DEBUGGABLE <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SetShaderTexture</span>(FRHIGraphicsShader<span style=color:#f92672>*</span> Shader, uint32 TextureIndex, FRHITexture<span style=color:#f92672>*</span> Texture)
{
    <span style=color:#75715e>//check(IsOutsideRenderPass());
</span><span style=color:#75715e></span>    ValidateBoundShader(Shader);
    <span style=color:#66d9ef>if</span> (Bypass())
    {
        GetContext().RHISetShaderTexture(Shader, TextureIndex, Texture);
        <span style=color:#66d9ef>return</span>;
    }
    ALLOC_COMMAND(FRHICommandSetShaderTexture<span style=color:#f92672>&lt;</span>FRHIGraphicsShader<span style=color:#f92672>&gt;</span>)(Shader, TextureIndex, Texture);
}
</code></pre></td></tr></table>
</div>
</div><p>该函数在SceneRendering.cpp中的<code>AddResolveSceneDepthPass</code>函数的lambda参数里面进行了调用；其中的<code>ALLOC_COMMAND</code>宏复杂向RHI Thread传递指令；继续跟进可得：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RHICommandList.h
</span><span style=color:#75715e></span><span style=color:#75715e>#define ALLOC_COMMAND(...) new ( AllocCommand(sizeof(__VA_ARGS__), alignof(__VA_ARGS__)) ) __VA_ARGS__
</span></code></pre></td></tr></table>
</div>
</div><p>展开即为：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RHICommandList.h
</span><span style=color:#75715e>// 展开前
</span><span style=color:#75715e></span>ALLOC_COMMAND(FRHICommandSetShaderTexture<span style=color:#f92672>&lt;</span>FRHIGraphicsShader<span style=color:#f92672>&gt;</span>)(Shader, TextureIndex, Texture);
<span style=color:#75715e>// 展开后
</span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> (AllocCommand(<span style=color:#66d9ef>sizeof</span>(FRHICommandSetShaderTexture<span style=color:#f92672>&lt;</span>FRHIGraphicsShader<span style=color:#f92672>&gt;</span>), <span style=color:#66d9ef>alignof</span>(FRHICommandSetShaderTexture<span style=color:#f92672>&lt;</span>FRHIGraphicsShader<span style=color:#f92672>&gt;</span>))) FRHICommandSetShaderTexture<span style=color:#f92672>&lt;</span>FRHIGraphicsShader<span style=color:#f92672>&gt;</span>(Shader, TextureIndex, Texture);
</code></pre></td></tr></table>
</div>
</div><p>这里用到了new关键字的另外一种用法，在内存的<code>AllocCommand(sizeof(FRHICommandSetShaderTexture&lt;FRHIGraphicsShader>), alignof(FRHICommandSetShaderTexture&lt;FRHIGraphicsShader>)))</code>位置，使用<code>FRHICommandSetShaderTexture&lt;FRHIGraphicsShader>(Shader, TextureIndex, Texture)</code>来进行初始化；跟进AllocCommand可得：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RHICommandList.h
</span><span style=color:#75715e></span>FORCEINLINE_DEBUGGABLE <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>AllocCommand</span>(int32 AllocSize, int32 Alignment)
{
    checkSlow(<span style=color:#f92672>!</span>IsExecuting());
    FRHICommandBase<span style=color:#f92672>*</span> Result <span style=color:#f92672>=</span> (FRHICommandBase<span style=color:#f92672>*</span>) MemManager.Alloc(AllocSize, Alignment);
    <span style=color:#f92672>++</span>NumCommands;
    <span style=color:#f92672>*</span>CommandLink <span style=color:#f92672>=</span> Result;
    CommandLink <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>Result<span style=color:#f92672>-&gt;</span>Next;
    <span style=color:#66d9ef>return</span> Result;
}
</code></pre></td></tr></table>
</div>
</div><p>可以看到RHICommand会以链表的形式存储起来，CommandLink的根节点在<code>RHICommandList</code>类下Root变量中；到目前为止，所有的RHICommand指令还未向RHI thread分发；跟进Root节点，最终能发现指令的分发在如下代码中：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RHICommandList.cpp
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> FRHICommandListExecutor<span style=color:#f92672>::</span>ExecuteInner(FRHICommandListBase<span style=color:#f92672>&amp;</span> CmdList)
{
    <span style=color:#75715e>// blablabla...
</span><span style=color:#75715e></span>
    RHIThreadTask <span style=color:#f92672>=</span> TGraphTask<span style=color:#f92672>&lt;</span>FExecuteRHIThreadTask<span style=color:#f92672>&gt;::</span>CreateTask(<span style=color:#f92672>&amp;</span>Prereq, ENamedThreads<span style=color:#f92672>::</span>GetRenderThread()).ConstructAndDispatchWhenReady(SwapCmdList);

    <span style=color:#75715e>// blablabla...    
</span><span style=color:#75715e></span>}
</code></pre></td></tr></table>
</div>
</div><p>跟进堆栈，能发现该函数在<code>ImmediateFlush</code>函数中调用，即</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RHICommandList.inc
</span><span style=color:#75715e></span>FORCEINLINE_DEBUGGABLE <span style=color:#66d9ef>void</span> FRHICommandListImmediate<span style=color:#f92672>::</span>ImmediateFlush(EImmediateFlushType<span style=color:#f92672>::</span>Type FlushType)
{
	<span style=color:#66d9ef>switch</span> (FlushType)
	{
	<span style=color:#66d9ef>case</span> EImmediateFlushType<span style=color:#f92672>::</span>WaitForOutstandingTasksOnly:
		{
			WaitForTasks();
		}
		<span style=color:#66d9ef>break</span>;

	<span style=color:#66d9ef>case</span> EImmediateFlushType<span style=color:#f92672>::</span>DispatchToRHIThread:
		{
			<span style=color:#66d9ef>if</span> (HasCommands())
			{
				GRHICommandList.ExecuteList(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
			}
		}
		<span style=color:#66d9ef>break</span>;

	<span style=color:#66d9ef>case</span> EImmediateFlushType<span style=color:#f92672>::</span>WaitForDispatchToRHIThread:
		{
			<span style=color:#66d9ef>if</span> (HasCommands())
			{
				GRHICommandList.ExecuteList(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
			}
			WaitForDispatch();
		}
		<span style=color:#66d9ef>break</span>;

	<span style=color:#66d9ef>case</span> EImmediateFlushType<span style=color:#f92672>::</span>FlushRHIThread:
		{
			CSV_SCOPED_TIMING_STAT(RHITFlushes, FlushRHIThreadTotal);
			<span style=color:#66d9ef>if</span> (HasCommands())
			{
				GRHICommandList.ExecuteList(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
			}
			WaitForDispatch();
			<span style=color:#66d9ef>if</span> (IsRunningRHIInSeparateThread())
			{
				WaitForRHIThreadTasks();
			}
			WaitForTasks(true); <span style=color:#75715e>// these are already done, but this resets the outstanding array
</span><span style=color:#75715e></span>		}
		<span style=color:#66d9ef>break</span>;

	<span style=color:#66d9ef>case</span> EImmediateFlushType<span style=color:#f92672>::</span>FlushRHIThreadFlushResources:
		{
			CSV_SCOPED_TIMING_STAT(RHITFlushes, FlushRHIThreadFlushResourcesTotal);
			<span style=color:#66d9ef>if</span> (HasCommands())
			{
				GRHICommandList.ExecuteList(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
			}
			WaitForDispatch();
			WaitForRHIThreadTasks();
			WaitForTasks(true); <span style=color:#75715e>// these are already done, but this resets the outstanding array
</span><span style=color:#75715e></span>
			PipelineStateCache<span style=color:#f92672>::</span>FlushResources();
			FRHIResource<span style=color:#f92672>::</span>FlushPendingDeletes(FRHICommandListExecutor<span style=color:#f92672>::</span>GetImmediateCommandList());
		}
		<span style=color:#66d9ef>break</span>;

	<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
		check(<span style=color:#ae81ff>0</span>);
	}
}
</code></pre></td></tr></table>
</div>
</div><p><code>ImmediateFlush</code>在RenderingThread线程的多处都有调用，至此就完成了RHICommand指令的分发；</p>
<h2 id=game-thread与rhi-thread同步>Game Thread与RHI Thread同步</h2>
<p>unreal中Game Thread、Rendering Thread以及RHI Thread之间的同步策略是可选的，在RenderingThread.cpp文件中有以下代码</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RenderingThread.cpp
</span><span style=color:#75715e></span>TAutoConsoleVariable<span style=color:#f92672>&lt;</span>int32<span style=color:#f92672>&gt;</span> CVarGTSyncType(
	TEXT(<span style=color:#e6db74>&#34;r.GTSyncType&#34;</span>),
	<span style=color:#ae81ff>0</span>,
	TEXT(<span style=color:#e6db74>&#34;Determines how the game thread syncs with the render thread, RHI thread and GPU.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
	TEXT(<span style=color:#e6db74>&#34;Syncing to the GPU swap chain flip allows for lower frame latency.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
	TEXT(<span style=color:#e6db74>&#34; 0 - Sync the game thread with the render thread (default).</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
	TEXT(<span style=color:#e6db74>&#34; 1 - Sync the game thread with the RHI thread.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
	TEXT(<span style=color:#e6db74>&#34; 2 - Sync the game thread with the GPU swap chain flip (only on supported platforms).</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>),
	ECVF_Default);
</code></pre></td></tr></table>
</div>
</div><p><code>CVarGTSyncType</code>控制值各线程之间的同步策略；Game Thread与Rendering Thread同步时会在<code>void FRenderCommandFence::BeginFence(bool bSyncToRHIAndGPU)</code>函数中向RenderingThread线程插入空任务，而Game Thread与RHI Thread同步时，同样在该函数中会执行以下代码：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// RenderingThread.cpp
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> FRenderCommandFence<span style=color:#f92672>::</span>BeginFence(<span style=color:#66d9ef>bool</span> bSyncToRHIAndGPU)
{
    <span style=color:#75715e>// blablabla...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (bSyncToRHIAndGPU)
    {
        <span style=color:#66d9ef>if</span> (IsRHIThreadRunning())
        {
            <span style=color:#75715e>// Change trigger thread to RHI
</span><span style=color:#75715e></span>            TriggerThreadIndex <span style=color:#f92672>=</span> ENamedThreads<span style=color:#f92672>::</span>RHIThread;
        }
        
        <span style=color:#75715e>// Create a task graph event which we can pass to the render or RHI threads.
</span><span style=color:#75715e></span>        CompletionEvent <span style=color:#f92672>=</span> FGraphEvent<span style=color:#f92672>::</span>CreateGraphEvent();

        FGraphEventRef InCompletionEvent <span style=color:#f92672>=</span> CompletionEvent;
        ENQUEUE_RENDER_COMMAND(FSyncFrameCommand)(
            [InCompletionEvent, GTSyncType](FRHICommandListImmediate<span style=color:#f92672>&amp;</span> RHICmdList)
            {
                <span style=color:#66d9ef>if</span> (IsRHIThreadRunning())
                {
                    ALLOC_COMMAND_CL(RHICmdList, FRHISyncFrameCommand)(InCompletionEvent, GTSyncType);
                    RHICmdList.ImmediateFlush(EImmediateFlushType<span style=color:#f92672>::</span>DispatchToRHIThread);
                }
                <span style=color:#66d9ef>else</span>
                {
                    FRHISyncFrameCommand <span style=color:#a6e22e>Command</span>(InCompletionEvent, GTSyncType);
                    Command.Execute(RHICmdList);
                }
            });
    }

    <span style=color:#75715e>// blablabla...
</span><span style=color:#75715e></span>}
</code></pre></td></tr></table>
</div>
</div><p>可见，Game Thread与RHI Thread同步时，会在RHI Thread线程中插入<code>FSyncFrameCommand</code>指令，且该指令被GameThread记录，用于在Game Thread线程中进行同步，代码如下：</p>
<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4>
<table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td>
<td style=vertical-align:top;padding:0;margin:0;border:0;width:100%>
<pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// UnrealEngine.cpp
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> FFrameEndSync<span style=color:#f92672>::</span>Sync( <span style=color:#66d9ef>bool</span> bAllowOneFrameThreadLag )
{
    <span style=color:#75715e>// blablabla...	
</span><span style=color:#75715e></span>    
    <span style=color:#75715e>// Since this is the frame end sync, allow sync with the RHI and GPU (true).
</span><span style=color:#75715e></span>	Fence[EventIndex].BeginFence(true);

    <span style=color:#75715e>// blablabla...	
</span><span style=color:#75715e></span>
	Fence[EventIndex].Wait(bEmptyGameThreadTasks);  <span style=color:#75715e>// here we also opportunistically execute game thread tasks while we wait
</span><span style=color:#75715e></span> 
    <span style=color:#75715e>// blablabla...
</span><span style=color:#75715e></span>}
</code></pre></td></tr></table>
</div>
</div><p>至此，就完成了Game Thread与RHI Thread之间的同步；</p>
</main>
<div id=gitalk-container></div>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css>
<script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script>
<script src=/js/md5.min.js></script>
<script>const gitalk=new Gitalk({clientID:'6ac25831f8084638e036',clientSecret:'ba798581fc341f62243d29d9be3d56d58cb38b74',repo:'wingstone.github.io',owner:'wingstone',admin:['wingstone'],id:md5(location.pathname),distractionFreeMode:!1});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('gitalk-container').innerHTML='Gitalk comments not available by default when the website is previewed locally.';return}gitalk.render('gitalk-container')})()</script>
<footer>
<script defer src=//yihui.org/js/math-code.js></script>
<script defer src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script defer src=//yihui.org/js/center-img.js></script>
<hr>
© <a href=https://wingstone.github.io>wingstone</a> 2020 &ndash; 2023 | <a href=https://github.com/wingstone>Github</a> | <a href=https://www.zhihu.com/people/wu-zhu-32-40>Zhihu</a> | <a href=https://www.shadertoy.com/user/wingstone>Shadertoy</a>
<div class=small-print>
<small> 访问量 <span id=busuanzi_value_site_pv></span> 次</small>
|
<small> 访客数 <span id=busuanzi_value_site_uv></span> 人次 </small>
</div>
</footer>
</body>
</html>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 8" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>