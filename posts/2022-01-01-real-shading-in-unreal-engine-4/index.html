<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Real Shading in Unreal Engine 4 | wingstone's blog</title>
<link rel=stylesheet href=/css/style.css>
<link rel=stylesheet href=/css/fonts.css>
<link rel=icon href=/icons/16.png>
</head>
<body>
<nav>
<ul class=menu>
<li><a href=/>Home</a></li>
<li><a href=/categories/>Categories</a></li>
<li><a href=/tags/>Tags</a></li>
<li><a href=/archives/>Archives</a></li>
<li><a href=/about/>About</a></li>
<li><a href=/index.xml>Subscribe</a></li>
</ul>
<hr>
</nav>
<div class=article-meta>
<h2><span class=title>Real Shading in Unreal Engine 4</span></h2>
<h3 class=author>wingstone</h3>
<h3 class=date>2022/01/01</h3>
</div><h2>目录</h2>
<nav id=TableOfContents>
<ul>
<li><a href=#介绍>介绍</a></li>
<li><a href=#shading-model>Shading Model</a>
<ul>
<li><a href=#diffuse-brdf>Diffuse BRDF</a></li>
<li><a href=#microfacet-specular-brdf>Microfacet Specular BRDF</a></li>
<li><a href=#image-based-lighting>Image-Based Lighting</a></li>
</ul>
</li>
<li><a href=#material-model>Material Model</a>
<ul>
<li><a href=#experience>Experience</a></li>
<li><a href=#material-layer>Material layer</a></li>
</ul>
</li>
<li><a href=#lighting-model>Lighting model</a>
<ul>
<li><a href=#area-lights>Area lights</a></li>
<li><a href=#billboard-reflections>Billboard Reflections</a></li>
<li><a href=#cone-intersection>Cone Intersection</a></li>
<li><a href=#specular-d-modification>Specular D Modification</a></li>
<li><a href=#representative-point>Representative Point</a></li>
<li><a href=#sphere-lights>Sphere Lights</a></li>
<li><a href=#tube-lights>Tube Lights</a></li>
</ul>
</li>
<li><a href=#总结>总结</a></li>
<li><a href=#实现细节>实现细节</a>
<ul>
<li><a href=#area-light>Area light</a></li>
<li><a href=#shading-model-1>shading model</a></li>
</ul>
</li>
</ul>
</nav>
<main>
<p>本文主要讲述PBR在Unreal中的实现思路，涉及Material Model、Shading Model、Lighting Model的背后原理与经验总结，来自演讲<a href=https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf>Real Shading in Unreal Engine 4</a>；在文章最后，添加了我个人的理解与实现细节扩展；</p>
<h2 id=介绍>介绍</h2>
<p>想要切换到pbr工作流的原因：可以渲染出更加真实的照片，同时能极大地改善美术工作人员的工作流与工作质量。</p>
<p>受迪士尼的以前<a href=http://blog.selfshadow.com/publications/s2012-shading-course/>Physically-Based Shading at Disney</a>的启发 ，unreal制定了自己的pbr所要达成的目标：</p>
<ol>
<li>Real-time performance，足够高效，满足实时渲染的帧率要求，（移动端还需考虑温度，耗电量要求）</li>
<li>Reduced complexity，参数尽可能少，过多的参数会产生更多的试错成本与失误。由于要受到ibl与解析光源的光照，因此，参数参数必须具有跨光源下的统一性。</li>
<li>Intuitive interface，简单易理解的接口，避免折射率这种物理数值。</li>
<li>Perceptual Linearly，感知上线性，意味着参数blend后的结果要尽可能接近结果的blend；（此项对感知依赖比较强，比如roughness的线性变化对应着主观感受上粗糙程度的线性变化）</li>
<li>Easy to Master，易于精通，不需要理解太多技术即可完成物理可信的效果；</li>
<li>Robust，意味着，不易产生不符合物理的效果，切多个参数的混合仍能获得物理可信效果；</li>
<li>Expressive，富有表现力的，由于使用延迟管线，因此基础的光照模型需要表达真实世界约99%的材质；</li>
<li>Flexible，足够灵活，项目并不都是真实感渲染，需要灵活到能够承载非真实感渲染；</li>
</ol>
<h2 id=shading-model>Shading Model</h2>
<h3 id=diffuse-brdf>Diffuse BRDF</h3>
<p>diffuse使用最简单的Lambert光照模型；</p>
<p>$$
f(l,v) = \frac{C_{diff}}{\pi}
$$</p>
<h3 id=microfacet-specular-brdf>Microfacet Specular BRDF</h3>
<p>通用的Cook-torrance微表面模型为：</p>
<p>$$
f(l,v) = \frac{D(h)F(v,h)G(l,v,h)}{4(n \cdot l)(n \cdot v)}
$$</p>
<h4 id=specular-d>Specular D</h4>
<p>D项起着非常重要的作用，直接影响着高光的trail分布，且采用GGX并不会比blinn-phong多出很多消耗，因此D项为：</p>
<p>$$
D(h) = \frac{\alpha^2}{\pi((n \cdot h)^2(\alpha^2+1)+1)^2}
$$</p>
<p>这里采用Disney所使用的的重参数化做法，即<code>$\alpha=Roughness^2$</code>；这里的Roughness在Unity的实现中对应于参数perceptualRoughness；</p>
<h4 id=specular-g>Specular G</h4>
<p>G项对比下来，最终选用Schlick model，并且使用<code>$k=\frac{\alpha}{2}$</code>，如此来更好的逼近GGX中的Smith model；参考Disney的做法将Roughness重映射为<code>$\frac{Roughness+1}{2}$</code>来减少“hotness”，只适用于解析光源，对于ibl计算，由于是离线的，可直接使用smith model；</p>
<p>$$
k=\frac{(Roughness+1)^2}{8}
$$
$$
G_1(v)=\frac{n\cdot v}{(n\cdot v)(1-k)+k}
$$
$$
G(l,v,h)=G_1(l)G_1(v)
$$</p>
<h4 id=specular-f>Specular F</h4>
<p>菲涅尔项同样采用Schlick 拟合项，并做了部分修改，使用了Spherical Gaussian approximation 来代替Power操作，差异是极其微小，但带来了性能的提升；</p>
<p>$$
F(v,h)=F_0+(1-F_0)2^{(-5.55473(v\cdot h)-6.98316)(v\cdot h)}
$$</p>
<h3 id=image-based-lighting>Image-Based Lighting</h3>
<p>我们使用前面的Shading Model来处理IBL，正常情况下要使用重要性采样来进行；积分公式为：</p>
<p>$$
\int_H {L_i(L)f(l,v)cos\theta_l} {\rm d}l= \frac{1}{N}\sum_{k=1}^N \frac{L_i(l_k)f(l,v)cos\theta_l}{p(l_k, v)} \quad
$$</p>
<p>代码为：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>float3 <span style=color:#a6e22e>ImportanceSampleGGX</span>( float2 Xi, <span style=color:#66d9ef>float</span> Roughness, float3 N )
{
    <span style=color:#66d9ef>float</span> a <span style=color:#f92672>=</span> Roughness <span style=color:#f92672>*</span> Roughness;
    <span style=color:#66d9ef>float</span> Phi <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> PI <span style=color:#f92672>*</span> Xi.x;
    <span style=color:#66d9ef>float</span> CosTheta <span style=color:#f92672>=</span> sqrt( (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> Xi.y) <span style=color:#f92672>/</span> ( <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> (a<span style=color:#f92672>*</span>a <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> Xi.y ) );
    <span style=color:#66d9ef>float</span> SinTheta <span style=color:#f92672>=</span> sqrt( <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> CosTheta <span style=color:#f92672>*</span> CosTheta );
    float3 H;
    H.x <span style=color:#f92672>=</span> SinTheta <span style=color:#f92672>*</span> cos( Phi );
    H.y <span style=color:#f92672>=</span> SinTheta <span style=color:#f92672>*</span> sin( Phi );
    H.z <span style=color:#f92672>=</span> CosTheta;
    float3 UpVector <span style=color:#f92672>=</span> abs(N.z) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.999</span> <span style=color:#f92672>?</span> float3(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>) <span style=color:#f92672>:</span> float3(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>);
    float3 TangentX <span style=color:#f92672>=</span> normalize( cross( UpVector, N ) );
    float3 TangentY <span style=color:#f92672>=</span> cross( N, TangentX );
    <span style=color:#75715e>// Tangent to world space
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> TangentX <span style=color:#f92672>*</span> H.x <span style=color:#f92672>+</span> TangentY <span style=color:#f92672>*</span> H.y <span style=color:#f92672>+</span> N <span style=color:#f92672>*</span> H.z;
}

float3 <span style=color:#a6e22e>SpecularIBL</span>( float3 SpecularColor , <span style=color:#66d9ef>float</span> Roughness, float3 N, float3 V )
{
    float3 SpecularLighting <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>const</span> uint NumSamples <span style=color:#f92672>=</span> <span style=color:#ae81ff>1024</span>;
    <span style=color:#66d9ef>for</span>( uint i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NumSamples; i<span style=color:#f92672>++</span> )
    {
        float2 Xi <span style=color:#f92672>=</span> Hammersley( i, NumSamples );
        float3 H <span style=color:#f92672>=</span> ImportanceSampleGGX( Xi, Roughness, N );
        float3 L <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> dot( V, H ) <span style=color:#f92672>*</span> H <span style=color:#f92672>-</span> V;
        <span style=color:#66d9ef>float</span> NoV <span style=color:#f92672>=</span> saturate( dot( N, V ) );
        <span style=color:#66d9ef>float</span> NoL <span style=color:#f92672>=</span> saturate( dot( N, L ) );
        <span style=color:#66d9ef>float</span> NoH <span style=color:#f92672>=</span> saturate( dot( N, H ) );
        <span style=color:#66d9ef>float</span> VoH <span style=color:#f92672>=</span> saturate( dot( V, H ) );
        <span style=color:#66d9ef>if</span>( NoL <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> )
        {
            float3 SampleColor <span style=color:#f92672>=</span> EnvMap.SampleLevel( EnvMapSampler , L, <span style=color:#ae81ff>0</span> ).rgb;
            <span style=color:#66d9ef>float</span> G <span style=color:#f92672>=</span> G_Smith( Roughness, NoV, NoL );
            <span style=color:#66d9ef>float</span> Fc <span style=color:#f92672>=</span> pow( <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> VoH, <span style=color:#ae81ff>5</span> );
            float3 F <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> Fc) <span style=color:#f92672>*</span> SpecularColor <span style=color:#f92672>+</span> Fc;
            <span style=color:#75715e>// Incident light = SampleColor * NoL
</span><span style=color:#75715e></span>            <span style=color:#75715e>// Microfacet specular = D*G*F / (4*NoL*NoV)
</span><span style=color:#75715e></span>            <span style=color:#75715e>// pdf = D * NoH / (4 * VoH)
</span><span style=color:#75715e></span>            SpecularLighting <span style=color:#f92672>+=</span> SampleColor <span style=color:#f92672>*</span> F <span style=color:#f92672>*</span> G <span style=color:#f92672>*</span> VoH <span style=color:#f92672>/</span> (NoH <span style=color:#f92672>*</span> NoV);
        }
    }
    <span style=color:#66d9ef>return</span> SpecularLighting <span style=color:#f92672>/</span> NumSamples;
}

</code></pre></div><p>就算使用重要性采样，使用mipmap来加速收敛，仍至少需要16次采样才能满足效果，再考虑到反射采样之间的blend（各种反射探针），实际上采样一次才能满足性能要求；</p>
<h4 id=split-sum-approximation>Split Sum Approximation</h4>
<p>将积分进行分离即可达到预结算的效果，同时满足性能要求；</p>
<p>$$
\frac{1}{N}\sum_{k=1}^N \frac{L_i(l_k)f(l,v)cos\theta_l}{p(l_k, v)} \quad = \left(\frac{1}{N}\sum_{k=1}^N L_i(l_k) \quad \right)\left( \frac{1}{N}\sum_{k=1}^N \frac{f(l,v)cos\theta_l}{p(l_k, v)} \quad \right)
$$</p>
<h4 id=pre-filtered-environment-map>Pre-Filtered Environment Map</h4>
<p>对于light部分，我们采用GGX来进行filter，将不同粗糙度下的filter结果存放到mipmap level中；同时假设<code>$n=v=l$</code>，引入的误差，在filter过程中使用<code>$cos\theta_{l_k}$</code>来加权得到更好的效果；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>float3 <span style=color:#a6e22e>PrefilterEnvMap</span>( <span style=color:#66d9ef>float</span> Roughness, float3 R )
{
    float3 N <span style=color:#f92672>=</span> R;
    float3 V <span style=color:#f92672>=</span> R;
    float3 PrefilteredColor <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>const</span> uint NumSamples <span style=color:#f92672>=</span> <span style=color:#ae81ff>1024</span>;
    <span style=color:#66d9ef>for</span>( uint i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NumSamples; i<span style=color:#f92672>++</span> )
    {
        float2 Xi <span style=color:#f92672>=</span> Hammersley( i, NumSamples );
        float3 H <span style=color:#f92672>=</span> ImportanceSampleGGX( Xi, Roughness, N );
        float3 L <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> dot( V, H ) <span style=color:#f92672>*</span> H <span style=color:#f92672>-</span> V;
        <span style=color:#66d9ef>float</span> NoL <span style=color:#f92672>=</span> saturate( dot( N, L ) );
        <span style=color:#66d9ef>if</span>( NoL <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> )
        {
            PrefilteredColor <span style=color:#f92672>+=</span> EnvMap.SampleLevel( EnvMapSampler , L, <span style=color:#ae81ff>0</span> ).rgb <span style=color:#f92672>*</span> NoL;
            TotalWeight <span style=color:#f92672>+=</span> NoL;
        }
    }
    <span style=color:#66d9ef>return</span> PrefilteredColor <span style=color:#f92672>/</span> TotalWeight;
}
</code></pre></div><h4 id=environment-brdf>Environment BRDF</h4>
<p>第二项积分，可以认为是均匀白光下，对Specular brdf的积分，即<code>$L_i(l_k)=1$</code>；对于菲涅尔项，使用Schlick的形式：<code>$F(v,h)=F_0+(1-F_0)(1-v\cdot h)^5$</code>，我们可以发现，积分中<code>$F_0$</code>可以提取出来，即</p>
<p>$$
\int_H {f(l,v)cos\theta_l} {\rm d}l= F_0\int_H {\frac{f(l,v)}{F(v,h)}(1-(1-v\cdot h)^5)cos\theta_l} {\rm d}l + \int_H {\frac{f(l,v)}{F(v,h)}(1-v\cdot h)^5cos\theta_l} {\rm d}l
$$</p>
<p>最后的积分公式只需要Roughness与<code>$cos\theta_v$</code>作为输入，<code>$F_0$</code>的scale与bias作为输出。由于输入为0到1的范围，可以很容易的使用2dlut来存储积分结果。</p>
<p>Unreal使用R16G16float的存储格式来存储，因为测试发现精度起着非常重要的作用。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 积分代码
</span><span style=color:#75715e></span>float2 <span style=color:#a6e22e>IntegrateBRDF</span>( <span style=color:#66d9ef>float</span> Roughness, <span style=color:#66d9ef>float</span> NoV )
{
    float3 V;
    V.x <span style=color:#f92672>=</span> sqrt( <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> NoV <span style=color:#f92672>*</span> NoV ); <span style=color:#75715e>// sin
</span><span style=color:#75715e></span>    V.y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    V.z <span style=color:#f92672>=</span> NoV; <span style=color:#75715e>// cos
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> A <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>float</span> B <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>const</span> uint NumSamples <span style=color:#f92672>=</span> <span style=color:#ae81ff>1024</span>;
    <span style=color:#66d9ef>for</span>( uint i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NumSamples; i<span style=color:#f92672>++</span> )
    {
        float2 Xi <span style=color:#f92672>=</span> Hammersley( i, NumSamples );
        float3 H <span style=color:#f92672>=</span> ImportanceSampleGGX( Xi, Roughness, N );
        float3 L <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> dot( V, H ) <span style=color:#f92672>*</span> H <span style=color:#f92672>-</span> V;
        <span style=color:#66d9ef>float</span> NoL <span style=color:#f92672>=</span> saturate( L.z );
        <span style=color:#66d9ef>float</span> NoH <span style=color:#f92672>=</span> saturate( H.z );
        <span style=color:#66d9ef>float</span> VoH <span style=color:#f92672>=</span> saturate( dot( V, H ) );
        <span style=color:#66d9ef>if</span>( NoL <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> )
        {
            <span style=color:#66d9ef>float</span> G <span style=color:#f92672>=</span> G_Smith( Roughness, NoV, NoL );
            <span style=color:#66d9ef>float</span> G_Vis <span style=color:#f92672>=</span> G <span style=color:#f92672>*</span> VoH <span style=color:#f92672>/</span> (NoH <span style=color:#f92672>*</span> NoV);
            <span style=color:#66d9ef>float</span> Fc <span style=color:#f92672>=</span> pow( <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> VoH, <span style=color:#ae81ff>5</span> );
            A <span style=color:#f92672>+=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> Fc) <span style=color:#f92672>*</span> G_Vis;
            B <span style=color:#f92672>+=</span> Fc <span style=color:#f92672>*</span> G_Vis;
        }
    }
    <span style=color:#66d9ef>return</span> float2( A, B ) <span style=color:#f92672>/</span> NumSamples;
}

<span style=color:#75715e>// 实时计算代码
</span><span style=color:#75715e></span>float3 <span style=color:#a6e22e>ApproximateSpecularIBL</span>( float3 SpecularColor, <span style=color:#66d9ef>float</span> Roughness, float3 N, float3 V )
{
    <span style=color:#66d9ef>float</span> NoV <span style=color:#f92672>=</span> saturate( dot( N, V ) );
    float3 R <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> dot( V, N ) <span style=color:#f92672>*</span> N <span style=color:#f92672>-</span> V;
    float3 PrefilteredColor <span style=color:#f92672>=</span> PrefilterEnvMap( Roughness, R );
    float2 EnvBRDF <span style=color:#f92672>=</span> IntegrateBRDF( Roughness, NoV );
    <span style=color:#66d9ef>return</span> PrefilteredColor <span style=color:#f92672>*</span> ( SpecularColor <span style=color:#f92672>*</span> EnvBRDF.x <span style=color:#f92672>+</span> EnvBRDF.y );
}
</code></pre></div><p>很多其他的研究使用了跟unreal一样或接近的的方式来计算lut，其中<a href=http://blog.selfshadow.com/publications/s2013-shading-course/>Getting More Physical in Call of Duty: Black Ops II</a>更近一步，使用解析拟合的方式来逼近积分。</p>
<h2 id=material-model>Material Model</h2>
<p>对于unreal的延迟管线来说，限制参数范围非常重要，这样可以优化gbuffer空间以及texture的存储及获取。
Unreal使用的参数为：</p>
<ol>
<li>Base color</li>
<li>Metalic</li>
<li>Roughness</li>
<li>Cavity</li>
</ol>
<p>其中Cavity用来进行小尺度（法线尺度上）的投影计算。</p>
<p>最值得注意的是Specular参数的去除，之所以去除，是因为该参数容易引起歧义，美术跟程序很容易设置出不合物理的参数，并且过多参数会限制对效果的把控。</p>
<p>Disney还提供了其他的shading model：</p>
<ol>
<li>Subsurface</li>
<li>Anisotropy</li>
<li>Clearcoat</li>
<li>Sheen</li>
</ol>
<p>Unreal发表此文章时只提供了subsurface与skin这两种shading model，由于采用纯粹的defer管线，unreal将shading model id存储于gbuffer，然后计算光照时使用动态分支来运行时计算不同shading model。</p>
<p>现在的unreal已经提供了很完备的shading model.</p>
<h3 id=experience>Experience</h3>
<p>Unreal转换pbr的经历验证了，移除speculer，使用金属粗糙度模型并不会影响美术人员的表达，只需要美术人员重新习惯即可。</p>
<p>金属度是否应该是是二值的？是的！金属度就应该是非黑即白的。对于金属度位于01之间的数值应该是使用material layer来表达！即金属覆盖在非金属之上或非金属覆盖在金属之上；</p>
<p>为了保证fortnite的非pbr效果，unreal还是扩充了specular参数，但是并不意味着无法用之前的pbr model来表达非pbr效果，毕竟Disney的动画片已经做出了验证。后续unreal也将会移除specular参数。</p>
<h3 id=material-layer>Material layer</h3>
<p>material layer大量受益于前面的研究成果，material layer即对材质分层，使得某一材质可以部分覆盖在其他材质之上，从而产生混合材质。</p>
<p>Material layer的优点为：</p>
<ol>
<li>可重复利用已有资产。</li>
<li>减少单个资产的复杂度。</li>
<li>统一并中心化影响游戏外观的材质，易于美术创作，统一美术风格。</li>
</ol>
<p>由于unreal节点式的工作流程，使得material layer的集成不会很难。</p>
<p>相比于离线的组装系统，material layer可以提供更高的质量。使用material layer时可以适当提高贴图分辨率，因为material layer的使用场合会非常复杂，除了低频信息，高频信息也会需要。同时因为效率问题也会限制单个材质下material layer的数量，但似乎限制layer的数量并不会影响美术人员的使用。</p>
<p>有两个地方，unreal还没有充分考虑：</p>
<ol>
<li>由于layer数量的限制，美术会趋近于拆分mesh，来使的每个mesh能获取到足够layer，这样反而会增加draw call，从而影响绘制效率。</li>
<li>对于100%覆盖的区域，使用动态分支是否能优化运行效率，unreal并没有做进一步研究。</li>
</ol>
<h2 id=lighting-model>Lighting model</h2>
<p>光源模型的建立也会直接影响到着色的物理正确性，unreal主要考虑了两点来改善效果，一个是光源的falloff，另外一个是non-punctual光源，即面光源。</p>
<p>unreal采用了平方衰减的falloff以及使用lumen的物理亮度单位来改善light model，同时考虑到光源范围的问题，falloff的计算公式如下：</p>
<p>$$
falloff = \frac{saturate(1-(distance/lightRadius)^4)^2}{distance^2+1}
$$</p>
<h3 id=area-lights>Area lights</h3>
<p>面光源在实时渲染中非常重要，如果没有面光源，美术人员将尝试调整roughness来得到面光源下的效果。这是pbr的一大忌讳，材质与光源应该解耦，彼此互不影响。</p>
<p>面光的计算，在离线渲染常使用大量的点光源来进行模拟，通过在光源上均匀采样或者重要性采样来计算。</p>
<p>Unreal对面光源模型的构建有以下要求：</p>
<ol>
<li>对材质影响的一致性，与其他光源一样，通过材质的diffuse brdf，specular brdf来影响材质的表现。</li>
<li>当solid angel接近0时，light model表现接近于点光源。不能通过修改shading model来达到这一目标。</li>
<li>性能足够好。</li>
</ol>
<h3 id=billboard-reflections>Billboard Reflections</h3>
<p>公告板反射是IBL的一种变种，用于离散多光源；具体理论为使用2D的image来存储3D空间下映射在对应Rectangle区域的全部光照，参考<a href=https://docs.unrealengine.com/udk/Three/rsrc/Three/DirectX11Rendering/MartinM_GDC11_DX11_presentation.pdf>The Technology Behind the DirectX 11 Unreal Engine"Samaritan" Demo</a>。与IBL类似，也需要使用pre-filter来存储不同粗糙度即Cone下的light结果。</p>
<p>尽管Billboard Reflections可以存储任意复杂的面光源信息，但却有以下缺点:</p>
<ol>
<li>只能在平面上做pre-filtered，因此filte的角度是有限的；</li>
<li>若反射光线没有与plane相机，将没有反射信息；</li>
<li>计算光照时，光照方向是未知的，通常假设为反射方向，即采用的方向；</li>
</ol>
<h3 id=cone-intersection>Cone Intersection</h3>
<p>Cone Intersection的实现不需要进行filter，一个较好的应用版本是<a href=https://www.slideshare.net/guerrillagames/lighting-of-killzone-shadow-fall>Lighting of Killzone: Shadow Fall</a>中的实现，该方法使用圆锥进行求交计算，将相交区域投射到与圆锥垂直的圆盘上，然后使用多项式近似的NDF来对相交区域进行分段积分，得到近似的光照结果；</p>
<p>这是一个很好的研究方向，不过当前版本并不能满足unreal的需要;即使用Cone Intersection必须是径向对称的，这样会丢失反射在倾斜角度下的拉伸现象，这是反射非常重要的一个特征；此外，与Billboard Reflections一样，计算光照时，光照方向是未知的；</p>
<h3 id=specular-d-modification>Specular D Modification</h3>
<p>这是Unreal在<a href=https://de45xmedrsdbp.cloudfront.net/Resources/files/The_Technology_Behind_the_Elemental_Demo_16x9-1248544805.pdf>The Technology Behind the 3D Graphics and Games Course “Unreal Engine 4 Elemental demo”</a>中所采用的技术；背后的理论为：认为光源的分布等同于某一Cone Angle下 <code>$D(h)$</code> 的分布。光源分布与反射Cone之间的卷积等同于两个Cone角度的相加，从而生成新的cone；</p>
<p>为了达到这种假设，可将 <code>$\alpha$</code> 转为对应Cone角度，然后加上光源对应的Cone角度，然后再重新转换为 <code>$\alpha^\prime$</code> ，使用新的 <code>$\alpha^\prime$</code> 来进行后续运算，即：</p>
<p>$$
\alpha^\prime = saturate(\alpha + \frac{sourceRadius}{3*distance})
$$</p>
<p>尽管这种算法很高效，效果确无法满足Unreal的需求，特别在光滑的材质受到大面积光源照射的情况下，穿帮更加明显；</p>
<h3 id=representative-point>Representative Point</h3>
<p>对一固定的着色点，可以认为受到面光源的光照，来自于光源表面某一代表性的固定点，这样面光源的光照计算就可以转换为点光源计算；该点的一个合理选择为光源上对该着色点具有最大贡献的点；</p>
<p>对于Phone着色来说，该点就是与反射光线具有最小夹角的点；</p>
<p>使用该方法时，随之带来的便是能量守恒问题，当前此问题并未解决；通过移动光源的发射位置，我们增大了光源的Solid Angle，但却未补充这一附加能量（即面光变点光，但点光的能量确未发生变化）；纠正此问题非常困难，因为此问题会与着色点的Specular 分布有关，即粗糙度；</p>
<h3 id=sphere-lights>Sphere Lights</h3>
<p>如果球形光源在着色平面之上，来自球形光源的Irradiance等价于来自于着色平面之上的点光源；这意味着我们只需要计算Specular lighting部分即可；</p>
<p>我们可以光源上计算离反射光线最小角度的点，通过计算离反射光线最近点的方式：</p>
<p>$$
centerToRay = L-(L\cdot r)r \\
closestPoint = L + centerToRay*saturate(\frac{sourceRadius}{|centerToRay|})
$$</p>
<p>其中L表示着色点到光源中心的矢量，r表示反射方向；若反射方向与光源相交，则求出来的是反射光线上距光源中心最近的点；</p>
<p>通过移动光源位置到光源表面，我们实际上会拓宽specular分布至光源对应的cone angle；使用归一化的Phong分布来表示的话，点光源与球光源的分布分别为：</p>
<p>$$
I_point = \frac{p+2}{2\pi} cos^p\phi_r \\
I_{sphere}
\begin{cases}
\frac{p+2}{2\pi} &if\phi_r &lt; \phi_a \\
\frac{p+2}{2\pi} cos^p(\phi_r-\phi_a) &if\phi_r > \phi_a
\end{cases}
$$</p>
<p>这里<code>$\phi_r$</code>表示r与l之间的夹角，<code>$\phi_a$</code>表示球形光源对应的Cone angle；此时点光源是归一化的，积分和为1，球形光很明显将不再归一化；为了近似这种能量的增长，我们使用类似前面提到的 <strong>Specular D Modification</strong> ，对于GGX，归一化因子为<code>$\frac{1}{\pi \alpha^2}$</code>，对于Representative Point的归一化，unreal使用新的拓宽后归一化因子除以原始点光下的归一化因子，即</p>
<p>$$
SphereNormalization = (\frac{\alpha}{\alpha \prime})^2
$$</p>
<p>如此便能得到满足Unreal前面三个要求的计算方法，其中<code>$\alpha\prime$</code>的计算与光源的位置及形状有关，与 <strong>Specular D Modification</strong> 方法中的不太一致，实现需要参考源码，原文中没有提及；</p>
<h3 id=tube-lights>Tube Lights</h3>
<p>首先减少光源半径为0，如此便可认为光源为linear light，linear light上理反射最小angle的近似点为：</p>
<p>$$
t = \frac{(r\cdot L_0)(r\cdot L_d) - (L_0\cdot L_d)}{|L_d|^2-(r\cdot L_d)^2} \\
l = ||L_0+saturate(t)L_d||
$$</p>
<p>为了保证能量守恒，使用类似于针对球形光源的方法，Specular的分布是由光源拓宽的，而linear light是一维的，因此我们可以使用anisotropic GGX的归一化因子<code>$\frac{1}{\pi \alpha_x\alpha_y}$</code>，这里<code>$\alpha_x=\alpha_y=\alpha$</code>，因此Representative Point的归一化为：</p>
<p>$$
LineNormalizetion = \frac{\alpha}{\alpha \prime}
$$</p>
<p>将line与sphere分离，能近似两者的卷积，从而能很好的模拟tube light的光照行为；</p>
<p>基于能量守恒下的Representative Point方法，能很好地模拟简单形状光源，基于此方法，unreal后续可能会加入更多形状的光源；</p>
<h2 id=总结>总结</h2>
<p>前面介绍了Unreal在Materials、shading以及lighting下如何转型到PBR，此做法已经被证明是非常成功的；在最新的技术demo，以及Fortnite项目中，他能大大提升视觉效果；后续Unreal也会将PBR应用到更多的项目中去；</p>
<h2 id=实现细节>实现细节</h2>
<h3 id=area-light>Area light</h3>
<p>对于球形光源的着色过程，阅读unreal源码后，发现有一些文章中没有提到的细节：</p>
<ul>
<li>Representative point方法主要用来计算面光源情况下的Specular BRDF，不会影响Irradiance的计算，因此NoL的计算直接使用光源中心即可，不需要使用Representative point计算得来的光照方向来计算NoL；</li>
<li>NoL的计算需要考虑光源与水平面相交的特殊情况，对此情况的处理，Unreal使用近似的方式来计算NoL的wrap，并给出了解析算法的代码；</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Engine/Shaders/Private/CapsuleLight.ush
</span><span style=color:#75715e>// Alpha is half of angle of spherical cap
</span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>SphereHorizonCosWrap</span>( <span style=color:#66d9ef>float</span> NoL, <span style=color:#66d9ef>float</span> SinAlphaSqr )
{
<span style=color:#75715e>#if 1
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> SinAlpha <span style=color:#f92672>=</span> sqrt( SinAlphaSqr );

    <span style=color:#66d9ef>if</span>( NoL <span style=color:#f92672>&lt;</span> SinAlpha )
    {
        NoL <span style=color:#f92672>=</span> max( NoL, <span style=color:#f92672>-</span>SinAlpha );
<span style=color:#75715e>#if 0</span><span style=color:#75715e>
</span><span style=color:#75715e>        // Accurate sphere irradiance
</span><span style=color:#75715e>        float CosBeta = NoL;
</span><span style=color:#75715e>        float SinBeta = sqrt( 1 - CosBeta * CosBeta );
</span><span style=color:#75715e>        float TanBeta = SinBeta / CosBeta;
</span><span style=color:#75715e>
</span><span style=color:#75715e>        float x = sqrt( 1 / SinAlphaSqr - 1 );
</span><span style=color:#75715e>        float y = -x / TanBeta;
</span><span style=color:#75715e>        float z = SinBeta * sqrt(1 - y*y);
</span><span style=color:#75715e>
</span><span style=color:#75715e>        NoL = NoL * acos(y) - x * z + atan( z / x ) / SinAlphaSqr;
</span><span style=color:#75715e>        NoL /= PI;
</span><span style=color:#75715e></span><span style=color:#75715e>#else
</span><span style=color:#75715e></span>        <span style=color:#75715e>// Hermite spline approximation
</span><span style=color:#75715e></span>        <span style=color:#75715e>// Fairly accurate with SinAlpha &lt; 0.8
</span><span style=color:#75715e></span>        <span style=color:#75715e>// y=0 and dy/dx=0 at -SinAlpha
</span><span style=color:#75715e></span>        <span style=color:#75715e>// y=SinAlpha and dy/dx=1 at SinAlpha
</span><span style=color:#75715e></span>        NoL <span style=color:#f92672>=</span> Pow2( SinAlpha <span style=color:#f92672>+</span> NoL ) <span style=color:#f92672>/</span> ( <span style=color:#ae81ff>4</span> <span style=color:#f92672>*</span> SinAlpha );
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    }
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>    NoL <span style=color:#f92672>=</span> saturate( ( NoL <span style=color:#f92672>+</span> SinAlphaSqr ) <span style=color:#f92672>/</span> ( <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> SinAlphaSqr ) );
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>return</span> NoL;
}
</code></pre></div><ul>
<li>能量守恒同样只针对于Speculer部分，对于normalize需要的 <code>$\alpha \prime$</code> 的计算，源码中给出了不一样的计算方法，与modified D distribution方法中的计算方式不同；</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Engine/Shaders/Private/ShadingModels.ush
</span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>New_a2</span>( <span style=color:#66d9ef>float</span> a2, <span style=color:#66d9ef>float</span> SinAlpha, <span style=color:#66d9ef>float</span> VoH )
{
    <span style=color:#66d9ef>return</span> a2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.25</span> <span style=color:#f92672>*</span> SinAlpha <span style=color:#f92672>*</span> (<span style=color:#ae81ff>3.0</span> <span style=color:#f92672>*</span> sqrtFast(a2) <span style=color:#f92672>+</span> SinAlpha) <span style=color:#f92672>/</span> ( VoH <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.001</span> );
    <span style=color:#75715e>//return a2 + 0.25 * SinAlpha * ( saturate(12 * a2 + 0.125) + SinAlpha ) / ( VoH + 0.001 );
</span><span style=color:#75715e></span>    <span style=color:#75715e>//return a2 + 0.25 * SinAlpha * ( a2 * 2 + 1 + SinAlpha ) / ( VoH + 0.001 );
</span><span style=color:#75715e></span>}
<span style=color:#66d9ef>float</span> <span style=color:#a6e22e>EnergyNormalization</span>( inout <span style=color:#66d9ef>float</span> a2, <span style=color:#66d9ef>float</span> VoH, FAreaLight AreaLight )
{
    <span style=color:#66d9ef>if</span>( AreaLight.SphereSinAlphaSoft <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> )
    {
        <span style=color:#75715e>// Modify Roughness
</span><span style=color:#75715e></span>        a2 <span style=color:#f92672>=</span> saturate( a2 <span style=color:#f92672>+</span> Pow2( AreaLight.SphereSinAlphaSoft ) <span style=color:#f92672>/</span> ( VoH <span style=color:#f92672>*</span> <span style=color:#ae81ff>3.6</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.4</span> ) );
    }

    <span style=color:#66d9ef>float</span> Sphere_a2 <span style=color:#f92672>=</span> a2;
    <span style=color:#66d9ef>float</span> Energy <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>if</span>( AreaLight.SphereSinAlpha <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> )
    {
        Sphere_a2 <span style=color:#f92672>=</span> New_a2( a2, AreaLight.SphereSinAlpha, VoH );
        Energy <span style=color:#f92672>=</span> a2 <span style=color:#f92672>/</span> Sphere_a2;
    }

    <span style=color:#66d9ef>if</span>( AreaLight.LineCosSubtended <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1</span> )
    {
<span style=color:#75715e>#if 1
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>float</span> LineCosTwoAlpha <span style=color:#f92672>=</span> AreaLight.LineCosSubtended;
        <span style=color:#66d9ef>float</span> LineTanAlpha <span style=color:#f92672>=</span> sqrt( ( <span style=color:#ae81ff>1.0001</span> <span style=color:#f92672>-</span> LineCosTwoAlpha ) <span style=color:#f92672>/</span> ( <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> LineCosTwoAlpha ) );
        <span style=color:#66d9ef>float</span> Line_a2 <span style=color:#f92672>=</span> New_a2( Sphere_a2, LineTanAlpha, VoH );
        Energy <span style=color:#f92672>*=</span> sqrt( Sphere_a2 <span style=color:#f92672>/</span> Line_a2 );
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>float</span> LineCosTwoAlpha <span style=color:#f92672>=</span> AreaLight.LineCosSubtended;
        <span style=color:#66d9ef>float</span> LineSinAlpha <span style=color:#f92672>=</span> sqrt( <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> LineCosTwoAlpha );
        <span style=color:#66d9ef>float</span> Line_a2 <span style=color:#f92672>=</span> New_a2( Sphere_a2, LineSinAlpha, VoH );
        Energy <span style=color:#f92672>*=</span> Sphere_a2 <span style=color:#f92672>/</span> Line_a2;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>return</span> Energy;
}

</code></pre></div><ul>
<li>在计算Specular BRDF是时候，unreal参考了Decima Engine演讲<a href=http://advances.realtimerendering.com/s2017/DecimaSiggraph2017.pdf>Decima Engine: Advances in Lighting and AA</a>中的做法，来计算NoH的最大值，代码为：</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Engine/Shaders/Private/BRDF.ush
</span><span style=color:#75715e>// [ de Carpentier 2017, &#34;Decima Engine: Advances in Lighting and AA&#34; ]
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SphereMaxNoH</span>( inout BxDFContext Context, <span style=color:#66d9ef>float</span> SinAlpha, <span style=color:#66d9ef>bool</span> bNewtonIteration )
{
    <span style=color:#66d9ef>if</span>( SinAlpha <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> )
    {
        <span style=color:#66d9ef>float</span> CosAlpha <span style=color:#f92672>=</span> sqrt( <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> Pow2( SinAlpha ) );
    
        <span style=color:#66d9ef>float</span> RoL <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Context.NoL <span style=color:#f92672>*</span> Context.NoV <span style=color:#f92672>-</span> Context.VoL;
        <span style=color:#66d9ef>if</span>( RoL <span style=color:#f92672>&gt;=</span> CosAlpha )
        {
            Context.NoH <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
            Context.XoH <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
            Context.YoH <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
            Context.VoH <span style=color:#f92672>=</span> abs( Context.NoV );
        }
        <span style=color:#66d9ef>else</span>
        {
            <span style=color:#66d9ef>float</span> rInvLengthT <span style=color:#f92672>=</span> SinAlpha <span style=color:#f92672>*</span> rsqrt( <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> RoL<span style=color:#f92672>*</span>RoL );
            <span style=color:#66d9ef>float</span> NoTr <span style=color:#f92672>=</span> rInvLengthT <span style=color:#f92672>*</span> ( Context.NoV <span style=color:#f92672>-</span> RoL <span style=color:#f92672>*</span> Context.NoL );
<span style=color:#75715e>// Enable once anisotropic materials support area lights
</span><span style=color:#75715e></span><span style=color:#75715e>#if 0</span><span style=color:#75715e>
</span><span style=color:#75715e>            float XoTr = rInvLengthT * ( Context.XoV - RoL * Context.XoL );
</span><span style=color:#75715e>            float YoTr = rInvLengthT * ( Context.YoV - RoL * Context.YoL );
</span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>float</span> VoTr <span style=color:#f92672>=</span> rInvLengthT <span style=color:#f92672>*</span> ( <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Context.NoV<span style=color:#f92672>*</span>Context.NoV <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> RoL <span style=color:#f92672>*</span> Context.VoL );

            <span style=color:#66d9ef>if</span> (bNewtonIteration)
            {
                <span style=color:#75715e>// dot( cross(N,L), V )
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>float</span> NxLoV <span style=color:#f92672>=</span> sqrt( saturate( <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> Pow2(Context.NoL) <span style=color:#f92672>-</span> Pow2(Context.NoV) <span style=color:#f92672>-</span> Pow2(Context.VoL) <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Context.NoL <span style=color:#f92672>*</span> Context.NoV <span style=color:#f92672>*</span> Context.VoL ) );

                <span style=color:#66d9ef>float</span> NoBr <span style=color:#f92672>=</span> rInvLengthT <span style=color:#f92672>*</span> NxLoV;
                <span style=color:#66d9ef>float</span> VoBr <span style=color:#f92672>=</span> rInvLengthT <span style=color:#f92672>*</span> NxLoV <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Context.NoV;

                <span style=color:#66d9ef>float</span> NoLVTr <span style=color:#f92672>=</span> Context.NoL <span style=color:#f92672>*</span> CosAlpha <span style=color:#f92672>+</span> Context.NoV <span style=color:#f92672>+</span> NoTr;
                <span style=color:#66d9ef>float</span> VoLVTr <span style=color:#f92672>=</span> Context.VoL <span style=color:#f92672>*</span> CosAlpha <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>   <span style=color:#f92672>+</span> VoTr;

                <span style=color:#66d9ef>float</span> p <span style=color:#f92672>=</span> NoBr   <span style=color:#f92672>*</span> VoLVTr;
                <span style=color:#66d9ef>float</span> q <span style=color:#f92672>=</span> NoLVTr <span style=color:#f92672>*</span> VoLVTr;
                <span style=color:#66d9ef>float</span> s <span style=color:#f92672>=</span> VoBr   <span style=color:#f92672>*</span> NoLVTr;

                <span style=color:#66d9ef>float</span> xNum <span style=color:#f92672>=</span> q <span style=color:#f92672>*</span> ( <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> p <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.25</span> <span style=color:#f92672>*</span> VoBr <span style=color:#f92672>*</span> NoLVTr );
                <span style=color:#66d9ef>float</span> xDenom <span style=color:#f92672>=</span> p<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> s <span style=color:#f92672>*</span> (s <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>p) <span style=color:#f92672>+</span> NoLVTr <span style=color:#f92672>*</span> ( (Context.NoL <span style=color:#f92672>*</span> CosAlpha <span style=color:#f92672>+</span> Context.NoV) <span style=color:#f92672>*</span> Pow2(VoLVTr) <span style=color:#f92672>+</span> q <span style=color:#f92672>*</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> (VoLVTr <span style=color:#f92672>+</span> Context.VoL <span style=color:#f92672>*</span> CosAlpha) <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5</span>) );
                <span style=color:#66d9ef>float</span> TwoX1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> xNum <span style=color:#f92672>/</span> ( Pow2(xDenom) <span style=color:#f92672>+</span> Pow2(xNum) );
                <span style=color:#66d9ef>float</span> SinTheta <span style=color:#f92672>=</span> TwoX1 <span style=color:#f92672>*</span> xDenom;
                <span style=color:#66d9ef>float</span> CosTheta <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> TwoX1 <span style=color:#f92672>*</span> xNum;
                NoTr <span style=color:#f92672>=</span> CosTheta <span style=color:#f92672>*</span> NoTr <span style=color:#f92672>+</span> SinTheta <span style=color:#f92672>*</span> NoBr;
                VoTr <span style=color:#f92672>=</span> CosTheta <span style=color:#f92672>*</span> VoTr <span style=color:#f92672>+</span> SinTheta <span style=color:#f92672>*</span> VoBr;
            }

            Context.NoL <span style=color:#f92672>=</span> Context.NoL <span style=color:#f92672>*</span> CosAlpha <span style=color:#f92672>+</span> NoTr; <span style=color:#75715e>// dot( N, L * CosAlpha + T * SinAlpha )
</span><span style=color:#75715e>// Enable once anisotropic materials support area lights
</span><span style=color:#75715e></span><span style=color:#75715e>#if 0</span><span style=color:#75715e>
</span><span style=color:#75715e>            Context.XoL = Context.XoL * CosAlpha + XoTr;
</span><span style=color:#75715e>            Context.YoL = Context.YoL * CosAlpha + YoTr;
</span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span>            Context.VoL <span style=color:#f92672>=</span> Context.VoL <span style=color:#f92672>*</span> CosAlpha <span style=color:#f92672>+</span> VoTr;

            <span style=color:#66d9ef>float</span> InvLenH <span style=color:#f92672>=</span> rsqrt( <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Context.VoL );
            Context.NoH <span style=color:#f92672>=</span> saturate( ( Context.NoL <span style=color:#f92672>+</span> Context.NoV ) <span style=color:#f92672>*</span> InvLenH );
<span style=color:#75715e>// Enable once anisotropic materials support area lights
</span><span style=color:#75715e></span><span style=color:#75715e>#if 0</span><span style=color:#75715e>
</span><span style=color:#75715e>            Context.XoH = ((Context.XoL + Context.XoV) * InvLenH);    // dot(X, (L+V)/|L+V|)
</span><span style=color:#75715e>            Context.YoH = ((Context.YoL + Context.YoV) * InvLenH);
</span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span>            Context.VoH <span style=color:#f92672>=</span> saturate( InvLenH <span style=color:#f92672>+</span> InvLenH <span style=color:#f92672>*</span> Context.VoL );
        }
    }
}
</code></pre></div><h3 id=shading-model-1>shading model</h3>
<p>在IBL这一块unreal使用了lut来做精确计算。不过随着硬件的发展，alu比带宽性能将会更友好，在2012的SIGGRAPH上<a href=https://blog.selfshadow.com/publications/s2013-shading-course/>Getting More Physical in Call of Duty: Black Ops II</a>给出了blin-phong模型的的EnvBRDF拟合做法；<a href=https://knarkowicz.wordpress.com/2014/12/27/analytical-dfg-term-for-ibl/>Krzysztof Narkowicz</a>以此为参考，给出了ggx的enviromwnt brdf拟合公式，代码为：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>float3 <span style=color:#a6e22e>EnvDFGLazarov</span>( float3 specularColor, <span style=color:#66d9ef>float</span> gloss, <span style=color:#66d9ef>float</span> ndotv )
{
    float4 p0 <span style=color:#f92672>=</span> float4( <span style=color:#ae81ff>0.5745</span>, <span style=color:#ae81ff>1.548</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.02397</span>, <span style=color:#ae81ff>1.301</span> );
    float4 p1 <span style=color:#f92672>=</span> float4( <span style=color:#ae81ff>0.5753</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.2511</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.02066</span>, <span style=color:#ae81ff>0.4755</span> );
 
    float4 t <span style=color:#f92672>=</span> gloss <span style=color:#f92672>*</span> p0 <span style=color:#f92672>+</span> p1;
 
    <span style=color:#66d9ef>float</span> bias <span style=color:#f92672>=</span> saturate( t.x <span style=color:#f92672>*</span> min( t.y, exp2( <span style=color:#f92672>-</span><span style=color:#ae81ff>7.672</span> <span style=color:#f92672>*</span> ndotv ) ) <span style=color:#f92672>+</span> t.z );
    <span style=color:#66d9ef>float</span> delta <span style=color:#f92672>=</span> saturate( t.w );
    <span style=color:#66d9ef>float</span> scale <span style=color:#f92672>=</span> delta <span style=color:#f92672>-</span> bias;
 
    bias <span style=color:#f92672>*=</span> saturate( <span style=color:#ae81ff>50.0</span> <span style=color:#f92672>*</span> specularColor.y );
    <span style=color:#66d9ef>return</span> specularColor <span style=color:#f92672>*</span> scale <span style=color:#f92672>+</span> bias;
}
float3 <span style=color:#a6e22e>EnvDFGPolynomial</span>( float3 specularColor, <span style=color:#66d9ef>float</span> gloss, <span style=color:#66d9ef>float</span> ndotv )
{
    <span style=color:#66d9ef>float</span> x <span style=color:#f92672>=</span> gloss;
    <span style=color:#66d9ef>float</span> y <span style=color:#f92672>=</span> ndotv;
 
    <span style=color:#66d9ef>float</span> b1 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.1688</span>;
    <span style=color:#66d9ef>float</span> b2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.895</span>;
    <span style=color:#66d9ef>float</span> b3 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.9903</span>;
    <span style=color:#66d9ef>float</span> b4 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>4.853</span>;
    <span style=color:#66d9ef>float</span> b5 <span style=color:#f92672>=</span> <span style=color:#ae81ff>8.404</span>;
    <span style=color:#66d9ef>float</span> b6 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>5.069</span>;
    <span style=color:#66d9ef>float</span> bias <span style=color:#f92672>=</span> saturate( min( b1 <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> b2 <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x, b3 <span style=color:#f92672>+</span> b4 <span style=color:#f92672>*</span> y <span style=color:#f92672>+</span> b5 <span style=color:#f92672>*</span> y <span style=color:#f92672>*</span> y <span style=color:#f92672>+</span> b6 <span style=color:#f92672>*</span> y <span style=color:#f92672>*</span> y <span style=color:#f92672>*</span> y ) );
 
    <span style=color:#66d9ef>float</span> d0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.6045</span>;
    <span style=color:#66d9ef>float</span> d1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.699</span>;
    <span style=color:#66d9ef>float</span> d2 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5228</span>;
    <span style=color:#66d9ef>float</span> d3 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>3.603</span>;
    <span style=color:#66d9ef>float</span> d4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.404</span>;
    <span style=color:#66d9ef>float</span> d5 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1939</span>;
    <span style=color:#66d9ef>float</span> d6 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.661</span>;
    <span style=color:#66d9ef>float</span> delta <span style=color:#f92672>=</span> saturate( d0 <span style=color:#f92672>+</span> d1 <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> d2 <span style=color:#f92672>*</span> y <span style=color:#f92672>+</span> d3 <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> d4 <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> y <span style=color:#f92672>+</span> d5 <span style=color:#f92672>*</span> y <span style=color:#f92672>*</span> y <span style=color:#f92672>+</span> d6 <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x );
    <span style=color:#66d9ef>float</span> scale <span style=color:#f92672>=</span> delta <span style=color:#f92672>-</span> bias;
 
    bias <span style=color:#f92672>*=</span> saturate( <span style=color:#ae81ff>50.0</span> <span style=color:#f92672>*</span> specularColor.y );
    <span style=color:#66d9ef>return</span> specularColor <span style=color:#f92672>*</span> scale <span style=color:#f92672>+</span> bias;
}
</code></pre></div><p>对于mobile平台，出于对考虑性能问题。unreal也参考COD给出了ggx的EnvBRDF拟合公式，相关发表为<a href=https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile>Physically Based Shading on Mobile</a>，如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>half3 <span style=color:#a6e22e>EnvBRDFApprox</span>( half3 SpecularColor, half Roughness, half NoV )
{
    <span style=color:#66d9ef>const</span> half4 c0 <span style=color:#f92672>=</span> { <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.0275</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.572</span>, <span style=color:#ae81ff>0.022</span> };
    <span style=color:#66d9ef>const</span> half4 c1 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.0425</span>, <span style=color:#ae81ff>1.04</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.04</span> };
    half4 r <span style=color:#f92672>=</span> Roughness <span style=color:#f92672>*</span> c0 <span style=color:#f92672>+</span> c1;
    half a004 <span style=color:#f92672>=</span> min( r.x <span style=color:#f92672>*</span> r.x, exp2( <span style=color:#f92672>-</span><span style=color:#ae81ff>9.28</span> <span style=color:#f92672>*</span> NoV ) ) <span style=color:#f92672>*</span> r.x <span style=color:#f92672>+</span> r.y;
    half2 AB <span style=color:#f92672>=</span> half2( <span style=color:#f92672>-</span><span style=color:#ae81ff>1.04</span>, <span style=color:#ae81ff>1.04</span> ) <span style=color:#f92672>*</span> a004 <span style=color:#f92672>+</span> r.zw;
    <span style=color:#66d9ef>return</span> SpecularColor <span style=color:#f92672>*</span> AB.x <span style=color:#f92672>+</span> AB.y;
}
half <span style=color:#a6e22e>EnvBRDFApproxNonmetal</span>( half Roughness, half NoV )
{
    <span style=color:#75715e>// Same as EnvBRDFApprox( 0.04, Roughness, NoV )
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> half2 c0 <span style=color:#f92672>=</span> { <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.0275</span> };
    <span style=color:#66d9ef>const</span> half2 c1 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.0425</span> };
    half2 r <span style=color:#f92672>=</span> Roughness <span style=color:#f92672>*</span> c0 <span style=color:#f92672>+</span> c1;
    <span style=color:#66d9ef>return</span> min( r.x <span style=color:#f92672>*</span> r.x, exp2( <span style=color:#f92672>-</span><span style=color:#ae81ff>9.28</span> <span style=color:#f92672>*</span> NoV ) ) <span style=color:#f92672>*</span> r.x <span style=color:#f92672>+</span> r.y;
}
</code></pre></div><p>Unity针对移动平台的性能要求，提供了更为简化的EnvBRDF公式，此外Unity还提供了ggx brdf在移动平台的简化版，参考文章为<a href=https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/moving-mobile-graphics>Moving Mobile Graphics</a>中的Optimizing PBR演讲；</p>
<p>而unity在buildin管线及urp管线中，实际使用的EnvBRDF代码与以上代码并不一致，网上也找不到相应的文章参考，实际的代码实现为：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>inline</span> half3 <span style=color:#a6e22e>FresnelLerp</span> (half3 F0, half3 F90, half cosA)
{
    half t <span style=color:#f92672>=</span> Pow5 (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> cosA);   <span style=color:#75715e>// ala Schlick interpoliation
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> lerp (F0, F90, t);
}
<span style=color:#75715e>// approximage Schlick with ^4 instead of ^5
</span><span style=color:#75715e></span><span style=color:#66d9ef>inline</span> half3 <span style=color:#a6e22e>FresnelLerpFast</span> (half3 F0, half3 F90, half cosA)
{
    half t <span style=color:#f92672>=</span> Pow4 (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> cosA);
    <span style=color:#66d9ef>return</span> lerp (F0, F90, t);
}

half grazingTerm <span style=color:#f92672>=</span> saturate(smoothness <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>oneMinusReflectivity));
 
<span style=color:#75715e>// Computes the specular term for EnvironmentBRDF
</span><span style=color:#75715e></span>half3 <span style=color:#a6e22e>EnvironmentBRDFSpecular</span>(half3 specColor, half roughness, half grazingTerm, half fresnelTerm)
{
    <span style=color:#66d9ef>float</span> surfaceReduction <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> (roughness<span style=color:#f92672>*</span>roughness <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0</span>); <span style=color:#75715e>// not perceptualRoughness
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> surfaceReduction <span style=color:#f92672>*</span> FresnelLerp(specColor, grazingTerm, fresnelTerm);
}
</code></pre></div>
</main>
<footer>
<script defer src=//yihui.org/js/math-code.js></script>
<script defer src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script defer src=//yihui.org/js/center-img.js></script>
<hr>
© <a href=https://wingstone.github.io>wingstone</a> 2020 &ndash; 2022 | <a href=https://github.com/wingstone>Github</a> | <a href=https://www.zhihu.com/people/wu-zhu-32-40>Zhihu</a> | <a href=https://www.shadertoy.com/user/wingstone>Shadertoy</a>
</footer>
</body>
</html>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>