<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on wingstone's blog</title><link>/posts/</link><description>Recent content in Posts on wingstone's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 01 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Real Shading in Unreal Engine 4</title><link>/posts/real-shading-in-unreal-engine-4/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>/posts/real-shading-in-unreal-engine-4/</guid><description>&lt;p>本文主要讲述PBR在Unreal中的实现思路，涉及Material Model、Shading Model、Lighting Model的背后原理与经验总结，来自演讲&lt;a href="https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">Real Shading in Unreal Engine 4&lt;/a>；在文章最后，添加了我个人的理解与实现细节扩展；&lt;/p></description></item><item><title>Color Space</title><link>/posts/light-and-color-color-space/</link><pubDate>Sat, 26 Jun 2021 23:14:15 +0000</pubDate><guid>/posts/light-and-color-color-space/</guid><description>&lt;p>颜色空间介绍&lt;/p></description></item><item><title>Gamma</title><link>/posts/light-and-color-gamma/</link><pubDate>Sat, 26 Jun 2021 21:11:24 +0000</pubDate><guid>/posts/light-and-color-gamma/</guid><description>&lt;p>颜色空间介绍&lt;/p></description></item><item><title>PostProcess关于UV的思考</title><link>/posts/postprocess-guan-yu-uv-de-si-kao/</link><pubDate>Thu, 10 Jun 2021 23:47:44 +0000</pubDate><guid>/posts/postprocess-guan-yu-uv-de-si-kao/</guid><description>&lt;p>以前一直以为屏幕空间下的UV应该是0-1的范围内的；&lt;/p></description></item><item><title>FXAA理论方法</title><link>/posts/fxaa-li-lun-fang-fa/</link><pubDate>Mon, 01 Mar 2021 22:52:01 +0000</pubDate><guid>/posts/fxaa-li-lun-fang-fa/</guid><description>&lt;p>FXAA是基于图像空间理论的抗拒齿方法；&lt;/p></description></item><item><title>景深的实现技术</title><link>/posts/jing-shen-de-shi-xian-ji-zhu/</link><pubDate>Tue, 20 Oct 2020 16:47:41 +0000</pubDate><guid>/posts/jing-shen-de-shi-xian-ji-zhu/</guid><description>&lt;p>景深的实现技术有很多，针对不同的使用场景，可以使用不同的方法；&lt;/p></description></item><item><title>后处理技术——景深</title><link>/posts/hou-chu-li-ji-zhu-jing-shen/</link><pubDate>Tue, 20 Oct 2020 16:05:48 +0000</pubDate><guid>/posts/hou-chu-li-ji-zhu-jing-shen/</guid><description>&lt;p>景深是能体现场景纵深的重要效果，同时还能虚化前景与背景，这样可以让玩家将注意力集中在聚焦物体上；&lt;/p></description></item><item><title>软阴影技术——PCF、ESM、VSM、CSM、PCSS</title><link>/posts/yin-ying-ji-zhu-pcfesmvsmpcss/</link><pubDate>Wed, 30 Sep 2020 23:39:42 +0000</pubDate><guid>/posts/yin-ying-ji-zhu-pcfesmvsmpcss/</guid><description>&lt;p>软阴影技术的各种实现以及个人理解；&lt;/p></description></item><item><title>贴图技术——Parallax Mapping（视差贴图）</title><link>/posts/texture-technique-parallax-mappingshi-chai-tie-tu/</link><pubDate>Wed, 30 Sep 2020 13:10:15 +0000</pubDate><guid>/posts/texture-technique-parallax-mappingshi-chai-tie-tu/</guid><description>&lt;p>视差贴图属于位移贴图(Displacement Mapping)技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一般使用位移贴图之前，需要对模型进行细分（细分着色器），然后进行顶点位移；&lt;/p></description></item><item><title>皮肤渲染——Preintegrated Subsurface Scattering</title><link>/posts/pi-fu-xuan-ran-zhi-preintegrated-subsurface-scattering/</link><pubDate>Mon, 28 Sep 2020 12:18:24 +0000</pubDate><guid>/posts/pi-fu-xuan-ran-zhi-preintegrated-subsurface-scattering/</guid><description>&lt;p>预积分皮肤散射主要解决三种皮肤散射情况：&lt;/p>
&lt;ol>
&lt;li>表面弯曲引起的散射（Surface Curvature）；&lt;/li>
&lt;li>表面小凸起引起的散射（Small Surface Bumps）；&lt;/li>
&lt;li>投影边缘引起的散射（Shadows）；&lt;/li>
&lt;li>皮肤背面的透射问题（Translucency）（自己添加的）；&lt;/li>
&lt;/ol></description></item><item><title>移动GPU架构</title><link>/posts/yi-dong-gpu-jia-gou/</link><pubDate>Thu, 17 Sep 2020 13:30:09 +0000</pubDate><guid>/posts/yi-dong-gpu-jia-gou/</guid><description>&lt;p>移动GPU架构经常被称之为TBDR（Tiled Based Deferred Rendering），我们这里也以TBDR代称；移动架构有TBR与TBDR两种，但实际上两者之间差别没那么大，所以这里拿TBDR来做统一介绍；&lt;/p></description></item><item><title>头发渲染——Kajiya model</title><link>/posts/tou-fa-xuan-ran-zhi-kajiya-model/</link><pubDate>Wed, 16 Sep 2020 12:19:32 +0000</pubDate><guid>/posts/tou-fa-xuan-ran-zhi-kajiya-model/</guid><description>&lt;p>关键点：采用多边形建模，进行深度排序修正渲染顺序（因为半透问题），AO去模拟自阴影，两层高光，采用Tangent向量代替N进行高光计算；&lt;/p></description></item><item><title>图形学资源汇总</title><link>/posts/tu-xing-xue-zi-yuan-tui-jian/</link><pubDate>Tue, 15 Sep 2020 16:10:15 +0000</pubDate><guid>/posts/tu-xing-xue-zi-yuan-tui-jian/</guid><description>&lt;p>图形学学习资源推荐，包含了学习网站，学习书记，开源项目等等；&lt;/p></description></item><item><title>Pipeline——Render Pipeline/Path（渲染管线/路径）</title><link>/posts/xuan-ran-guan-xian/</link><pubDate>Mon, 14 Sep 2020 14:51:39 +0000</pubDate><guid>/posts/xuan-ran-guan-xian/</guid><description>&lt;p>Render Path称之为渲染路径更为合适，实际上指渲染一帧所要走的流程，这个流程主要用来处理光照，以及后处理等；常见的有Forward/Deferred Rendering；以及其改版Forward+、Tiled Based Deferred Rendering、Clustered Shading；以及更灵活的Frame Graph（寒霜引擎）、SRP（Unity引擎）；&lt;/p></description></item><item><title>Pipeline——GPU Graphic Pipeline（图形管线）</title><link>/posts/gpu-graphic-pipeline/</link><pubDate>Sun, 13 Sep 2020 09:14:06 +0000</pubDate><guid>/posts/gpu-graphic-pipeline/</guid><description>&lt;h2 id="管线介绍">管线介绍&lt;/h2>
&lt;p>所谓管线就是一个流程，针对硬件来说，处理一个图元有一个硬件渲染流程&lt;strong>Graphic Pipeline（图形管线）&lt;/strong>；针对实际应用来说，渲染一帧画面也需要一个渲染流程&lt;strong>Render Pipeline/Path（渲染管线/路径）&lt;/strong>；Graphic Pipeline处于更加低级的渲染层次，是渲染一个物体必走的渲染流程；&lt;/p></description></item><item><title>Opengl Vertex Interpolation</title><link>/posts/opengl-vertex-interpolation/</link><pubDate>Thu, 10 Sep 2020 14:39:18 +0000</pubDate><guid>/posts/opengl-vertex-interpolation/</guid><description>&lt;p>OpenGL中关于插值问题&lt;/p></description></item><item><title>ECS Architecture</title><link>/posts/ecs-architecture/</link><pubDate>Thu, 10 Sep 2020 14:38:33 +0000</pubDate><guid>/posts/ecs-architecture/</guid><description>&lt;p>ECS架构介绍&lt;/p></description></item><item><title>C++ Static Usage</title><link>/posts/c-static-usage/</link><pubDate>Mon, 07 Sep 2020 14:37:51 +0000</pubDate><guid>/posts/c-static-usage/</guid><description>&lt;p>C++中的一些细节问题&lt;/p></description></item><item><title>排列与组合</title><link>/posts/pai-lie-yu-zu-he/</link><pubDate>Mon, 07 Sep 2020 14:37:00 +0000</pubDate><guid>/posts/pai-lie-yu-zu-he/</guid><description>&lt;p>关于排列与组合的算法问题&lt;/p></description></item><item><title>Monte Carlo Integration</title><link>/posts/monte-carlo-integration/</link><pubDate>Sun, 06 Sep 2020 14:35:52 +0000</pubDate><guid>/posts/monte-carlo-integration/</guid><description>&lt;p>蒙特卡洛积分的简短介绍，以及PBRT中常用的函数分布；&lt;/p></description></item><item><title>Mathematics about camera in graphics（图形学中关于相机的数学）</title><link>/posts/mathematics-about-camera-in-3d-game-engine/</link><pubDate>Thu, 18 Jun 2020 14:34:51 +0000</pubDate><guid>/posts/mathematics-about-camera-in-3d-game-engine/</guid><description>&lt;p>以OpenGL中的右手坐标系为例，介绍引擎中和各种应用中跟相机有关的数学；&lt;/p></description></item><item><title>Unity Custom UI Mesh</title><link>/posts/unity-custom-ui-mesh/</link><pubDate>Mon, 11 May 2020 14:34:08 +0000</pubDate><guid>/posts/unity-custom-ui-mesh/</guid><description>&lt;p>介绍在unity中实现自定义ui的形状；&lt;/p></description></item><item><title>Unity Useful Plugins And Projects</title><link>/posts/unity-useful-plugins-and-projects/</link><pubDate>Sun, 29 Mar 2020 14:33:26 +0000</pubDate><guid>/posts/unity-useful-plugins-and-projects/</guid><description>&lt;p>这是一个插件集合的列表，主要用来存储我在学习unity过程中使用到的非常好用的插件，或者一些不错的工程；本着通用和好用的要求，这里的插件都是一些基本功能的整合；&lt;/p></description></item><item><title> Unity 2D Kit Note</title><link>/posts/unity-2d-kit-note/</link><pubDate>Sun, 29 Mar 2020 14:32:39 +0000</pubDate><guid>/posts/unity-2d-kit-note/</guid><description>&lt;p>介绍unity 2D Kit包中所用的一些组件；&lt;/p></description></item><item><title>ShaderToy MultiParticle Rendering</title><link>/posts/shadertoy-multiparticle-rendering/</link><pubDate>Sat, 11 Jan 2020 14:31:41 +0000</pubDate><guid>/posts/shadertoy-multiparticle-rendering/</guid><description>&lt;p>在ShaderToy开发过程中，使用粒子可以极高的提升粒子效果，绘制粒子可以分为&lt;strong>粒子着色&lt;/strong>以及&lt;strong>粒子范围的确定&lt;/strong>，这篇文章主要讨论&lt;strong>粒子范围的确定&lt;/strong>。&lt;/p></description></item><item><title>ShaderToy Bloom Effect</title><link>/posts/shadertoy-bloom-effect/</link><pubDate>Sat, 11 Jan 2020 14:29:03 +0000</pubDate><guid>/posts/shadertoy-bloom-effect/</guid><description>&lt;p>bloom效果的实现，在已知距离场的情况下，使用距离的倒数以及指数函数能渲染出接近bloom的效果；&lt;/p></description></item></channel></rss>