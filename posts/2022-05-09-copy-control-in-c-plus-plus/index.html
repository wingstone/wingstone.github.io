<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Copy control in c++ | wingstone's blog</title>
<link rel=stylesheet href=/css/style.css>
<link rel=stylesheet href=/css/fonts.css>
<link rel=icon href=/icons/16.png>
</head>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<body>
<nav>
<ul class=menu>
<li><a href=/ class=menu-item>Home</a></li>
<li><a href=/categories/ class=menu-item>Categories</a></li>
<li><a href=/tags/ class=menu-item>Tags</a></li>
<li><a href=/archives/ class=menu-item>Archives</a></li>
<li><a href=/about/ class=menu-item>About</a></li>
<li><a href=/index.xml class=menu-item>Subscribe</a></li>
</ul>
<hr>
</nav>
<div class=article-meta>
<h2><span class=title>Copy control in c++</span></h2>
<h3 class=author>wingstone</h3>
<h3 class=date>2022/05/09</h3>
<div>
<span id=busuanzi_container_page_pv> 阅读量 <span id=busuanzi_value_page_pv></span> 次</span>
</div>
</div><h2>目录</h2>
<nav id=TableOfContents>
<ul>
<li><a href=#copy-constructor>Copy Constructor</a></li>
<li><a href=#copy-assignment-operator>Copy-Assignment Operator</a></li>
<li><a href=#-default-and--delete>= default and = delete</a></li>
<li><a href=#rvalues>Rvalues</a></li>
<li><a href=#rvalue-references>Rvalue References</a>
<ul>
<li><a href=#lvalues-persist-rvalues-are-ephemeral>Lvalues Persist; Rvalues Are Ephemeral</a></li>
<li><a href=#variables-are-lvalues>Variables Are Lvalues</a></li>
<li><a href=#the-library-move-function>The Library move Function</a></li>
</ul>
</li>
<li><a href=#move-constructor-and-move-assignment>Move Constructor and Move Assignment</a></li>
<li><a href=#move-operations-library-containers-and-exceptions>Move Operations, Library Containers, and Exceptions</a></li>
<li><a href=#move-assignment-operator>Move-Assignment Operator</a></li>
<li><a href=#a-moved-from-object-must-be-destructible>A Moved-from Object Must Be Destructible</a></li>
<li><a href=#the-synthesized-move-operations>The Synthesized Move Operations</a></li>
<li><a href=#rvalues-are-moved-lvalues-are-copied>Rvalues Are Moved, Lvalues Are Copied</a></li>
<li><a href=#reference>Reference</a></li>
</ul>
</nav>
<main>
<p>Copy control在c++中及其重要，使用不当，会严重影响c++的运行效率；本文总结主要参考C++ primer的第13章节，再加上一些个人的理解；</p>
<h2 id=copy-constructor>Copy Constructor</h2>
<p>Copy构造函数以相同类型实例的引用来作为第一个参数，剩余的参数没有或者使用默认参数即可；如下代码所示：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span> {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span>    Foo(); <span style=color:#75715e>// default constructor
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span style=color:#75715e></span>    Foo(<span style=color:#66d9ef>const</span> Foo<span style=color:#f92672>&amp;</span>); <span style=color:#75715e>// copy constructor
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span style=color:#75715e></span>    <span style=color:#75715e>// ...
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span style=color:#75715e></span>};
</code></pre></div><p>Copy构造函数的第一个参数几乎都是const的，虽然可以不加const，但是从代码的安全性考虑，不建议这样做；</p>
<p>Copy构造函数被调用的情况包含Copy Initialization，以及函数的参数，返回值；这些都是Copy构造函数的implicit调用（由编译器生成）；除了implicit调用，还有匹配Copy构造函数声明的explicit调用，如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span>	Something() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>	Something(<span style=color:#66d9ef>const</span> Something<span style=color:#f92672>&amp;</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>	{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>		std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Copy constructor called</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>	}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>};
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>Something <span style=color:#a6e22e>goo</span>(Something other)          <span style=color:#f92672>//</span> copy constructor <span style=color:#66d9ef>for</span> Parameters; implicit
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span>	Something s <span style=color:#f92672>=</span> other;                <span style=color:#75715e>// copy constructor for Parameters; implicit
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> s;                           <span style=color:#75715e>// copy constructor for return values; implicit
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span style=color:#75715e></span>}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Initializing s1</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span>	Something s0;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span>	Something s1 <span style=color:#f92672>=</span> goo(s0);             <span style=color:#75715e>// copy constructor for copy initialization; implicit
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span style=color:#75715e></span>	Something s2(s1);                   <span style=color:#75715e>// copy constructor for copy initialization; explicit
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span style=color:#75715e></span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span>}
</code></pre></div><p>如果声明Copy constructor时添加了explicit声明，将只能进行Copy constructor的显式调用，不能进行隐式调用；如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span>	Something() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>	<span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>Something</span>(<span style=color:#66d9ef>const</span> Something<span style=color:#f92672>&amp;</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>	{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>		std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Copy constructor called</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>	}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>};
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Initializing s1</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span>	Something s0;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span>	Something s2 <span style=color:#f92672>=</span> Something();         <span style=color:#75715e>// error! copy constructor for copy initialization; implicit!
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span style=color:#75715e></span>	Something s1(s0);                   <span style=color:#75715e>// copy constructor for copy initialization; explicit
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span style=color:#75715e></span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span>}
</code></pre></div><p>事实上，编译器在一些情况下会对copy initialization进行省略优化，从而转化为调用对应的direct initilization；
以下例子在VS2019上运行，实际上只有一次copy initialization的调用；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span>	Something() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>	Something(<span style=color:#66d9ef>const</span> Something<span style=color:#f92672>&amp;</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>	{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>		std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Copy constructor called</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>	}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>};
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>Something <span style=color:#a6e22e>foo</span>()
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span>	<span style=color:#66d9ef>return</span> Something(); <span style=color:#75715e>// copy constructor normally called here
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span style=color:#75715e></span>}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span>Something <span style=color:#a6e22e>goo</span>()
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span>	Something s;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span>	<span style=color:#66d9ef>return</span> s; <span style=color:#75715e>// copy constructor normally called here
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span style=color:#75715e></span>}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Initializing s1</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span>	Something s1 <span style=color:#f92672>=</span> foo(); <span style=color:#75715e>// copy constructor normally called here
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span style=color:#75715e></span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Initializing s2</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span>	Something s2 <span style=color:#f92672>=</span> goo(); <span style=color:#75715e>// copy constructor normally called here
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span style=color:#75715e></span>}
</code></pre></div><p>实际上，在STL的container的push_back与emplace_back的实现中，push_back使用copy initialization来填充，以对象为参数，emplace_back使用direct initialization来填充，以构造函数参数为参数，并返回新构造的对象；</p>
<h2 id=copy-assignment-operator>Copy-Assignment Operator</h2>
<p>Copy赋值操作与Copy构造函数的区别在于，Copy赋值操作只有explicit调用，并且调用实际与Copy构造函数不同，如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span>	Something() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>	Something(<span style=color:#66d9ef>const</span> Something<span style=color:#f92672>&amp;</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>	{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>		std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Copy constructor called</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>	}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>	Something<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> Something<span style=color:#f92672>&amp;</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>	{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>		std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Copy Assignment called</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span>	}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span>};
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span>	Something s1;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span>	Something s2 <span style=color:#f92672>=</span> s1;		<span style=color:#75715e>// copy constructor normally called here
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span style=color:#75715e></span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span>	Something s3;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span>	s3 <span style=color:#f92672>=</span> s2;				<span style=color:#75715e>// copy Assignment normally called here
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=-default-and--delete>= default and = delete</h2>
<p>Copy赋值操作与Copy构造函数，如果没有编写，编译器会在内部生成对应的函数实现；但这样会导致这些函数对使用者呈现隐藏状态，对使用者不够友好；
因此在C++11中，使用=default，表示明确告诉编译器，使用编译器的默认实现；使用=delete，表示明确告诉编译器，不需要进行相应实现；
若=default在函数声明处添加，表示为inline函数；若=default在函数实现处添加，表示为非inline函数；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Sales_data</span> {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span>    Sales_data() <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;                      <span style=color:#75715e>// no implement
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span style=color:#75715e></span>    Sales_data(<span style=color:#66d9ef>const</span> Sales_data<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;    <span style=color:#75715e>// default implement, inline
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span style=color:#75715e></span>    Sales_data<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Sales_data <span style=color:#f92672>&amp;</span>);
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span>    <span style=color:#f92672>~</span>Sales_data() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;                    <span style=color:#75715e>// default implement, inline
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span style=color:#75715e></span>};
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span>    Sales_data<span style=color:#f92672>&amp;</span> Sales_data<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Sales_data<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;     <span style=color:#75715e>// default implement, not inline
</span></code></pre></div><h2 id=rvalues>Rvalues</h2>
<p>右值与左值相对应，区分的方法为，可以放到=左边的值就是左值，不能放到=左边的就是右值；
更通俗的区分方法为，我们使用右值，使用的是右值的内容，使用左值，使用的是左值的地址；
如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// a为左值，a可以放在=左边，a可以取地址；1为右值，1不能放在=左边，1不能取地址，只能取内容；
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#75715e></span>a <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// a为左值，a + 1为右值；
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#75715e></span>a <span style=color:#f92672>=</span> abs(a, <span style=color:#ae81ff>1</span>);  <span style=color:#75715e>// a为左值，abs(a, 1)为右值；
</span></code></pre></div><h2 id=rvalue-references>Rvalue References</h2>
<p>右值虽不能取地址，但是在C++11中可以取右值的引用，使用方法为声明右值引用时，添加&&来表示；
值得注意的是右值引用只能绑定右值，不能绑定其它；
如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>r <span style=color:#f92672>=</span> i;                 <span style=color:#75715e>// ok: r refers to i
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;&amp;</span>rr <span style=color:#f92672>=</span> i;               <span style=color:#75715e>// error: cannot bind an rvalue reference to an lvalue
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>r2 <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>42</span>;           <span style=color:#75715e>// error: i * 42 is an rvalue
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>r3 <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>42</span>;     <span style=color:#75715e>// ok: we can bind a reference to const to an rvalue
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;&amp;</span>rr2 <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>42</span>;         <span style=color:#75715e>// ok: bind rr2 to the result of the multiplication
</span></code></pre></div><h3 id=lvalues-persist-rvalues-are-ephemeral>Lvalues Persist; Rvalues Are Ephemeral</h3>
<p>左值可以长期持有，而右值通常是一些将要销毁的值，因为没有其它值来使用这些右值；因此右值引用就变成了用来获取右值所占有资源的唯一途径，我们可以通过后续的移动构造或赋值来使用这些资源；</p>
<h3 id=variables-are-lvalues>Variables Are Lvalues</h3>
<p>值得注意的是右值引用本省是个变量，而变量是可以放到=左边的，因此右值引用本身是个左值；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;&amp;</span>rr1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;         <span style=color:#75715e>// ok: literals are rvalues
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;&amp;</span>rr2 <span style=color:#f92672>=</span> rr1;        <span style=color:#75715e>// error: the expression rr1 is an lvalue!
</span></code></pre></div><h3 id=the-library-move-function>The Library move Function</h3>
<p>虽然右值引用不能绑定左值，但是还是可以通过static_cast来将左值cast为右值，从而可绑定到右值引用上；
在C++标准库里面有一个move函数，其内部的实现既是通过cast来完成的；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>int</span> rr1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;&amp;</span>rr3 <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(rr1);     <span style=color:#75715e>// ok
</span></code></pre></div><h2 id=move-constructor-and-move-assignment>Move Constructor and Move Assignment</h2>
<p>所谓移动构造函数与移动赋值函数，与拷贝构造函数类似，只不过移动函数使用右值引用来作为参数，并且实现上，挪用右值的资源为己用，而不是拷贝重新构造一份；
对于，io buffer以及unique_ptr这些对象不能进行共享，因此对应的资源也非常适合移动，而不是拷贝；</p>
<h2 id=move-operations-library-containers-and-exceptions>Move Operations, Library Containers, and Exceptions</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StrVec</span> {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span>    StrVec(StrVec<span style=color:#f92672>&amp;&amp;</span>) <span style=color:#66d9ef>noexcept</span>; <span style=color:#75715e>// move constructor
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span style=color:#75715e></span>    <span style=color:#75715e>// other members as before
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span style=color:#75715e></span>};
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span>StrVec<span style=color:#f92672>::</span>StrVec(StrVec <span style=color:#f92672>&amp;&amp;</span>s) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> <span style=color:#75715e>/* member initializers */</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span>{ <span style=color:#75715e>/* constructor body */</span> }
</code></pre></div><p>我们必须在move函数的声明与定义处，添加no exception标签；
原因1：我们的move函数只挪用资源，不分配与释放资源，因此没有异常弹出，显式告诉编译器，可以减少编译器部分工作；
原因2：对于container，在其push_back时，其保证了有exception时，原对象是不变的，因此如果有exception，container就会调用拷贝构造函数，来保证原对象不变；使用noexcaption可以保证container调用move构造函数；</p>
<h2 id=move-assignment-operator>Move-Assignment Operator</h2>
<p>Move赋值操作所执行内容与Move constructor基本一致，同时又与Copy赋值操作一样，函数最终要返回自身的引用；如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span>StrVec <span style=color:#f92672>&amp;</span>StrVec<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(StrVec <span style=color:#f92672>&amp;&amp;</span>rhs) <span style=color:#66d9ef>noexcept</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span>{
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span>    <span style=color:#75715e>// direct test for self-assignment
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>rhs) {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span>        free();                         <span style=color:#75715e>// free existing elements
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span style=color:#75715e></span>        elements <span style=color:#f92672>=</span> rhs.elements;        <span style=color:#75715e>// take over resources from rhs
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span style=color:#75715e></span>        first_free <span style=color:#f92672>=</span> rhs.first_free;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>        cap <span style=color:#f92672>=</span> rhs.cap;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>                                        <span style=color:#75715e>// leave rhs in a destructible state
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span style=color:#75715e></span>        rhs.elements <span style=color:#f92672>=</span> rhs.first_free <span style=color:#f92672>=</span> rhs.cap <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>    }
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span>}
</code></pre></div><h2 id=a-moved-from-object-must-be-destructible>A Moved-from Object Must Be Destructible</h2>
<p>被move后的对象，必须要保证其是可销毁的，因为其内部资源已被move，那么被move后的对象就处于一个随时可被销毁的状态；上面例子的<code>rhs.elements = rhs.first_free = rhs.cap = nullptr;</code>就保证了被move后的对象可被安全销毁；</p>
<h2 id=the-synthesized-move-operations>The Synthesized Move Operations</h2>
<p>编译器也可以合成对应的Move函数，条件为：</p>
<ol>
<li>Unlike the copy constructor, the move constructor is defined as deleted if the class has a member that defines its own copy constructor but does not also define a move constructor, or if the class has a member that doesn’t define its own copy operations and for which the compiler is unable to synthesize a move constructor. Similarly for move-assignment.</li>
<li>The move constructor or move-assignment operator is defined as deleted if the class has a member whose own move constructor or move-assignment operator is deleted or inaccessible.</li>
<li>Like the copy constructor, the move constructor is defined as deleted if the destructor is deleted or inaccessible.</li>
<li>Like the copy-assignment operator, the move-assignment operator is defined as deleted if the class has a const or reference member.</li>
</ol>
<h2 id=rvalues-are-moved-lvalues-are-copied>Rvalues Are Moved, Lvalues Are Copied</h2>
<p>如果copy函数与move函数同时存在，则按照函数参数来匹配对应的函数调用，对constructor与assignment是一致的；
如果不存在Move函数，则会调用对应的copy函数；</p>
<h2 id=reference>Reference</h2>
<ol>
<li><a href=https://stackoverflow.com/questions/1051379/is-there-a-difference-between-copy-initialization-and-direct-initialization>Is there a difference between copy initialization and direct initialization?</a></li>
<li><a href=https://www.learncpp.com/cpp-tutorial/copy-initialization/>Copy initialization</a></li>
<li><a href=https://www.zhihu.com/question/363686723>c++为什么要搞个引用岀来，特别是右值引用，感觉破坏了语法的简洁和条理，拷贝一个指针不是很好吗？</a></li>
<li><a href=https://github.com/Cpp-Club/Cxx_HOPL4_zh>在拥挤和变化的世界中茁壮成长：C++ 2006–2020</a></li>
</ol>
</main>
<div id=gitalk-container></div>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css>
<script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script>
<script src=/js/md5.min.js></script>
<script>const gitalk=new Gitalk({clientID:'6ac25831f8084638e036',clientSecret:'ba798581fc341f62243d29d9be3d56d58cb38b74',repo:'wingstone.github.io',owner:'wingstone',admin:['wingstone'],id:md5(location.pathname),distractionFreeMode:!1});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('gitalk-container').innerHTML='Gitalk comments not available by default when the website is previewed locally.';return}gitalk.render('gitalk-container')})()</script>
<footer>
<script defer src=//yihui.org/js/math-code.js></script>
<script defer src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script defer src=//yihui.org/js/center-img.js></script>
<hr>
© <a href=https://wingstone.github.io>wingstone</a> 2020 &ndash; 2022 | <a href=https://github.com/wingstone>Github</a> | <a href=https://www.zhihu.com/people/wu-zhu-32-40>Zhihu</a> | <a href=https://www.shadertoy.com/user/wingstone>Shadertoy</a>
<div class=small-print>
<small> 访问量 <span id=busuanzi_value_site_pv></span> 次</small>
|
<small> 访客数 <span id=busuanzi_value_site_uv></span> 人次 </small>
</div>
</footer>
</body>
</html>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 8" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>