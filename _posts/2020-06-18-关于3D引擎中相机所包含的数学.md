---
layout: post
title: 关于3D引擎中相机所包含的数学
author: wingstone
---

以OpenGL中的右手坐标系为例，介绍引擎中和各种应用中跟相机有关的数学；

## 观察矩阵

首先理解观察矩阵的作用，观察矩阵是为了将相机位置和转向不同的情况进行统一，最合适的统一方式就是将相机移动到坐标原点，然后将相机朝向变为-Z轴，这样所有的世界在相机看来就是一致的，便于后续的处理；

实际就是将以(0, 0, 0)为原点的世界坐标系转变为以(cameraPos.x, cameraPos.y, cameraPos.z)为原点的坐标系，当然，这里不能少了旋转；

由于矩阵相乘的顺序影响最后的结果，由于旋转矩阵是相对原点进行旋转的，所以自然而然，我们应该先将相机移至原点（平移矩阵）再进行转向（旋转矩阵）；

在OpenGl中，假设相机坐标为cameraPos，朝向分别为Front，Up，Right，坐标为列向量，则相应的矩阵为：
$$
\left[
\begin{matrix}
1&0&0&cameraPos.x\\
0&1&0&cameraPos.y\\
0&0&1&cameraPos.z\\
0&0&0&1\\
\end{matrix}
\right]
\left[
\begin{matrix}
Right.x&Up.x&Front.x&0\\
Right.y&Up.y&Front.y&0\\
Right.z&Up.z&Front.z&0\\
0&0&0&1\\
\end{matrix}
\right]
$$

## 投影矩阵

关于投影矩阵的推导，看[这里](http://www.songho.ca/opengl/gl_projectionmatrix.html);

## 相机中非线性0-1的深度转为线性0-1深度

设非线性深度值0-1为depth，线性深度值0-1为lineardepth，Zn表示-1到1的NDC深度，Ze表示观察空间下的深度，n表示近裁剪面，f表示远裁剪面；
则几者之间的关系为：

$$depth = Zn *0.5+0.5$$
$$lineardepth = -Ze/f$$
$$Zn = \frac{-\frac{f+n}{f-n}Ze-\frac{2fn}{f-n}}{-Ze}$$

**其中由公式2可以看出，线性的0-1范围并不是指近裁剪面对应0、远裁剪面对应1，而是相机位置对应0，远裁剪面对应1；**

其中公式3可以在上面投影矩阵那篇文章中看到，跟进上面三式，可以得到depth与lineardepth的关系为：
$$lineardepth = \frac{1}{\frac{n-f}{n}depth+\frac{f}{n}}$$

## 第一人称视角相机的实现

第一人称视角相机，其实就是FPS类游戏中常用的相机，即相机所看的就是游戏中的人眼所看到的，可以自由的前后左右移动，以及左右上下旋转视角；

第一人称视角相机需要存储一些额外的变量，一个是移动的速度MovementSpeed，二是Pitch，Yaw角度，Pitch表示俯仰角，Yaw表示偏航角；

相机自带的变量为Front，Up，Right，cameraPos，worldUp，worldUp表示世界的正上方向；

### 相机的移动实现

```c++
void ProcessKeyBoard(CEMERA_MOVEMENT direction, float deltaTime)
{
    float offset = MovementSpeed * deltaTime;
    switch (direction)
    {
    case FORWARD:
        Position += Front * offset;
        break;
    case BACKWARD:
        Position -= Front * offset;
        break;
    case LEFT:
        Position -= Right * offset;
        break;
    case RIGHT:
        Position += Right * offset;
        break;
    default:
        break;
    }
}

```

### 相机的旋转实现

```c++
void ProcessMouseMovement(float xOffset, float yOffset, bool focusCenter = true, GLboolean constrainPitch = true)
{
    xOffset *= MouseSensitivity;
    yOffset *= MouseSensitivity;

    Yaw += xOffset;
    Pitch += yOffset;

    if (constrainPitch)
    {
        if (Pitch > 89.0f)
        {
            Pitch = 89.0f;
        }
        if (Pitch < -89.0f)
        {
            Pitch = -89.0f;
        }
    }

    {
        glm::vec3 front;
        front.x = sin(glm::radians(Yaw))*cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = -cos(glm::radians(Yaw))*cos(glm::radians(Pitch));
        Front = glm::normalize(front);

        Right = glm::normalize(glm::cross(Front, WorldUp));
        Up = glm::normalize(glm::cross(Right, Front));
    }
}
```

## 绕固定物体旋转相机的实现

绕固定物体旋转相机，有点类似于unity或maya中，Alt+左键移动移动镜头的那种实现，只不过镜头是绕着所看到的物体旋转的，不是自由旋转的，所以相机要跟进所计算的方向同时计算位置；

### 绕固定物体相机的旋转实现

```c++
void ProcessMouseMovement(float xOffset, float yOffset, float focusDistance = 5.0f, GLboolean constrainPitch = true)
{
    xOffset *= MouseSensitivity;
    yOffset *= MouseSensitivity;

    Yaw += xOffset;
    Pitch += yOffset;

    if (constrainPitch)
    {
        if (Pitch > 89.0f)
        {
            Pitch = 89.0f;
        }
        if (Pitch < -89.0f)
        {
            Pitch = -89.0f;
        }
    }

    glm::vec3 focusPos = Position + Front * focusDistance;      //区别在在这里

    {
        glm::vec3 front;
        front.x = sin(glm::radians(Yaw))*cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = -cos(glm::radians(Yaw))*cos(glm::radians(Pitch));
        Front = glm::normalize(front);

        Right = glm::normalize(glm::cross(Front, WorldUp));
        Up = glm::normalize(glm::cross(Right, Front));
    }

    Position = focusPos - Front * focusDistance;            //区别在在这里
}
```

## 参考文章

[learnopengl-cn](https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/)
[Unity Shader入门精要](https://book.douban.com/subject/26821639/)
[OpenGL Projection Matrix](http://www.songho.ca/opengl/gl_projectionmatrix.html)
