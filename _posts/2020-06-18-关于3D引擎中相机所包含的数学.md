---
layout: post
title: 关于3D引擎中相机所包含的数学
author: wingstone
---

以OpenGL中的右手坐标系为例，介绍引擎中和各种应用中跟相机有关的数学；

## 观察矩阵

首先理解观察矩阵的作用，观察矩阵是为了将相机位置和转向不同的情况进行统一，最合适的统一方式就是将相机移动到坐标原点，然后将相机朝向变为-Z轴，这样所有的世界在相机看来就是一致的，便于后续的处理；

实际就是将以(0, 0, 0)为原点的世界坐标系转变为以(cameraPos.x, cameraPos.y, cameraPos.z)为原点的坐标系，当然，这里不能少了旋转；

由于矩阵相乘的顺序影响最后的结果，由于旋转矩阵是相对原点进行旋转的，所以自然而然，我们应该先将相机移至原点（平移矩阵）再进行转向（旋转矩阵）；

在OpenGl中，假设相机坐标为cameraPos，朝向分别为Front，Up，Right，坐标为列向量，则相应的矩阵为：
$$
\left[
\begin{matrix}
1&0&0&cameraPos.x\\
0&1&0&cameraPos.y\\
0&0&1&cameraPos.z\\
0&0&0&1\\
\end{matrix}
\right]
\left[
\begin{matrix}
Right.x&Up.x&Front.x&0\\
Right.y&Up.y&Front.y&0\\
Right.z&Up.z&Front.z&0\\
0&0&0&1\\
\end{matrix}
\right]
$$

## 投影矩阵

关于投影矩阵的推导，看[这里](http://www.songho.ca/opengl/gl_projectionmatrix.html);

## 第一人称视角相机的实现

第一人称视角相机需要存储一些额外的变量，一个是移动的速度MovementSpeed，二是Pitch，Yaw角度，Pitch表示俯仰角，Yaw表示偏航角；

相机自带的变量为Front，Up，Right，cameraPos，worldUp，worldUp表示世界的正上方向；

### 相机的移动实现

```c++
void ProcessKeyBoard(CEMERA_MOVEMENT direction, float deltaTime)
{
    float offset = MovementSpeed * deltaTime;
    switch (direction)
    {
    case FORWARD:
        Position += Front * offset;
        break;
    case BACKWARD:
        Position -= Front * offset;
        break;
    case LEFT:
        Position -= Right * offset;
        break;
    case RIGHT:
        Position += Right * offset;
        break;
    default:
        break;
    }
}

```

### 相机的旋转实现

```c++
void ProcessMouseMovement(float xOffset, float yOffset, bool focusCenter = true, GLboolean constrainPitch = true)
{
    xOffset *= MouseSensitivity;
    yOffset *= MouseSensitivity;

    Yaw += xOffset;
    Pitch += yOffset;

    if (constrainPitch)
    {
        if (Pitch > 89.0f)
        {
            Pitch = 89.0f;
        }
        if (Pitch < -89.0f)
        {
            Pitch = -89.0f;
        }
    }

    {
        glm::vec3 front;
        front.x = sin(glm::radians(Yaw))*cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = -cos(glm::radians(Yaw))*cos(glm::radians(Pitch));
        Front = glm::normalize(front);

        Right = glm::normalize(glm::cross(Front, WorldUp));
        Up = glm::normalize(glm::cross(Right, Front));
    }
}
```

## 绕固定物体旋转相机的实现

### 绕固定物体相机的旋转实现

```c++
void ProcessMouseMovement(float xOffset, float yOffset, float focusDistance = 5.0f, GLboolean constrainPitch = true)
{
    xOffset *= MouseSensitivity;
    yOffset *= MouseSensitivity;

    Yaw += xOffset;
    Pitch += yOffset;

    if (constrainPitch)
    {
        if (Pitch > 89.0f)
        {
            Pitch = 89.0f;
        }
        if (Pitch < -89.0f)
        {
            Pitch = -89.0f;
        }
    }

    glm::vec3 focusPos = Position + Front * focusDistance;      //区别在在这里

    {
        glm::vec3 front;
        front.x = sin(glm::radians(Yaw))*cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = -cos(glm::radians(Yaw))*cos(glm::radians(Pitch));
        Front = glm::normalize(front);

        Right = glm::normalize(glm::cross(Front, WorldUp));
        Up = glm::normalize(glm::cross(Right, Front));
    }

    Position = focusPos - Front * focusDistance;            //区别在在这里
}
```

## 参考文章

[learnopengl-cn](https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/)