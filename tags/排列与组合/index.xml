<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>排列与组合 on wingstone's blog</title><link>/tags/%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/</link><description>Recent content in 排列与组合 on wingstone's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 07 Sep 2020 14:37:00 +0000</lastBuildDate><atom:link href="/tags/%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/index.xml" rel="self" type="application/rss+xml"/><item><title>排列与组合</title><link>/posts/pai-lie-yu-zu-he/</link><pubDate>Mon, 07 Sep 2020 14:37:00 +0000</pubDate><guid>/posts/pai-lie-yu-zu-he/</guid><description>关于排列与组合的算法问题
排列与组合的区别 实际上，排列意味着数据一样，数据出现的顺序不一样； 组合意味着，数据不一样，与数据的顺序无关；
排列的算法框架 如果数据没有重复，直接套用回溯算法框架即可；
class Solution { public: void Help(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; results, vector&amp;lt;int&amp;gt;&amp;amp; result, vector&amp;lt;int&amp;gt;&amp;amp; num, vector&amp;lt;int&amp;gt;&amp;amp; flags) { if (result.size() == num.size()) { results.push_back(result); return; } for (int i = 0; i &amp;lt; flags.size(); i++) { if (flags[i] == 0) //跳过已经取过的数 continue; result.push_back(num[i]); flags[i] = 0; Help(results, result, num, flags); flags[i] = 1; result.pop_back(); } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; results; vector&amp;lt;int&amp;gt; result; vector&amp;lt;int&amp;gt; flags(nums.size(), 1);; Help(results, result, nums, flags); return results; } }; 对于特殊情况，比如数据中有重复的数据，需要考虑重复的情况；为了方便识别重复的情况，需要对数据源进行排序，这样在计算过程中，对于重复的情况，只需要向前单向查找是否重复即可；</description></item></channel></rss>