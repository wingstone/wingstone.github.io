<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rendering on wingstone's blog</title><link>/tags/rendering/</link><description>Recent content in Rendering on wingstone's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 28 Sep 2020 14:45:56 +0000</lastBuildDate><atom:link href="/tags/rendering/index.xml" rel="self" type="application/rss+xml"/><item><title>皮肤渲染方法总结</title><link>/posts/pi-fu-xuan-ran-fang-fa-zong-jie/</link><pubDate>Mon, 28 Sep 2020 14:45:56 +0000</pubDate><guid>/posts/pi-fu-xuan-ran-fang-fa-zong-jie/</guid><description> gpugems1：wrap方法，模拟透射，纹理空间blur gpugems3：不同的Specular BRDF，改善模拟透射，纹理空间 Diffusion，屏幕空间Diffusion siggraph2011：pre-integrated skin rendering GPU Pro 2, Part 2. Rendering, Chapter 1. Pre-Intergrated Skin Shading</description></item><item><title>皮肤渲染——Preintegrated Subsurface Scattering</title><link>/posts/pi-fu-xuan-ran-zhi-preintegrated-subsurface-scattering/</link><pubDate>Mon, 28 Sep 2020 12:18:24 +0000</pubDate><guid>/posts/pi-fu-xuan-ran-zhi-preintegrated-subsurface-scattering/</guid><description>预积分皮肤散射主要解决三种皮肤散射情况：
表面弯曲引起的散射（Surface Curvature）； 表面小凸起引起的散射（Small Surface Bumps）； 投影边缘引起的散射（Shadows）； 皮肤背面的透射问题（Translucency）（自己添加的）； Surface Curvature 单纯的wrap并不符合物理，需要通过diffusion profile积分才能获取正确的wrap； 预积分贴图是在球形假设下进行计算的，因此该方法最大的缺陷是模拟表面拓扑复杂的结构时，有很大不合理之处； 幸运的是，当今模型表面大都是平滑的，而不平滑的小的部分都用法线贴图进行假设计算； 积分方程为：
$$ D(\theta, r) = \frac{\int_{-\pi/2}^{\pi/2} {cos(\theta+x)*R(2rsin(x/2))} ,{\rm d}x}{\int_{-\pi/2}^{\pi/2} {R(2rsin(x/2))} ,{\rm d}x} $$
式中R(d)表示Diffusion profile，表示相应距离下的辐射度，d表示距离。该式表示在曲率半径为r的半球下，对应$\theta$角度下，其它所有角度在该角度下的散射强度；对应模型如下图所示：
**图中的$\theta$应该全部用x来表示！**从图中的右侧的模型能够看出，N为我们要求的散射角度，L与N之间的角度为$\theta$，L在$N+x$处的光照强度为$cos(\theta+x)$；N距N+x的距离为2rsin(x/2)，即弦长；N+x在N处的散射可由R(d)计算得出；
图中的Diffusion profile一般使用高斯核叠加进行表示，对于rgb各成分的高斯核表示为： 最终得到一个Diffusion profile在不同$\theta$角度和曲率半径下的积分分布；将$\theta$角度和曲率半径转换为NdoL和1/r，即可得到常用的预积分贴图；如下图所示： 其中曲率的求法可在shader中借助偏导函数计算，即：
float3 dn = fwidth(N); float3 dp = fwidth(P); float c = length(dn)/length(dp); Small Surface Bumps 对于小的凸起以及皱纹，不能使用预积分来进行计算，但是由于可以多采样，因此可以使用预滤波的方式处理法线贴图；
对于specular使用正常的normalmap，对于diffuse的rgb分别使用针对不同Diffusion profile处理后的normalmap，因此需要4张normalmap；
为了效率考虑，可以使用一种高精度无滤波的normalmap，一张低精度预滤波的normalmap分别针对rgb插值来近似相应的预滤波处理；需要2张normalmap；
可以将低精度无滤波的normalmap省略，直接使用模型法线来代替，这样就可以指使用一张高精度无滤波的normalmap进行处理了；
最终的结果为：进行滤波处理的通道，其法线凹凸变弱，反应在视觉上，就是凹凸处该通道有相应的溢出（根本原因是此通道趋于恒定，而其他通道凹凸变换大）；
Shadows Scattering 皮肤出的散射特性在投影边缘会体现出来，具体模拟此现象是很困难的一件事情，但是我们可以通过一些trick来实现；
首先，阴影强度为0或1，表示被遮挡，或不被遮挡；位于两者之间的值，及表示半影区域，及发生散射的区域（前提是使用软阴影）；因此我们可以针对这一点，利用Diffusion profile进行积分，来得到阴影值与散射强度的关系；
积分的过程是针对位置进行积分，需要将阴影值映射到位置上后才能积分，针对不同的软阴影方法，映射函数是不同的；我们用P()表示阴影值与到blur kernel距离的函数，则此映射为$p^-{1}()$；具体的积分方程为： $$ P_S(s,w) = \frac{\int_{-\infty}^{\infty} {P^'(P^{-1}(s)+x)R(x/w)} ,{\rm d}x}{\int_{-\infty}^{\infty} {R(x/w)} ,{\rm d}x} $$ 针对box blur软阴影（PCF）方法，其过程如下： 需要注意的是，半影区域的一部分（宽度到没提及）作为正常的软阴影计算插值，剩下的一部分作为这些软阴影散射产生的影响；P'()即表示新的半影函数分布；</description></item><item><title>头发渲染——Kajiya model</title><link>/posts/tou-fa-xuan-ran-zhi-kajiya-model/</link><pubDate>Wed, 16 Sep 2020 12:19:32 +0000</pubDate><guid>/posts/tou-fa-xuan-ran-zhi-kajiya-model/</guid><description>关键点：采用多边形建模，进行深度排序修正渲染顺序（因为半透问题），AO去模拟自阴影，两层高光，采用Tangent向量代替N进行高光计算；
采用多边形建模 头发建模可分为发丝建模（关于发丝建模的渲染看这里）与多边形建模两种，当今游戏界所大量采用的做法也是多边形建模；
多边形建模有更低的几何复杂性，以至于有更高的排序效率；相比之下采用发丝建模需要大约100K-150K的发丝来构建，复杂度高很多； 采用多边形建模可以更加容易的集成到已有的渲染管线中去，基本已有的渲染管线都是处理的多边形模型； 高光计算 主要的高光计算都集成在下面这张PPT上； 可以看出，kajiya计算模型与blin-phong模型比较类似，本质上都是采用pow(NdotH, specularity)来进行的高光计算；但是kajiya模型没有使用多边形几何的法线来作为法线计算，而是采用法线平面的概念来作为法线的代替计算；
虽然几何是多边形，但是仍然将其作为发丝来看待，Tangent向量作为发丝的方向；而发丝的法线应该位于与发丝垂直的平面上，且发丝与此平面的交点作为法线的起点；
法线平面即红色平面所显示的，法线平面中真正的法线，有T向量、H向量所决定的平面，与法线平面的交线来决定，我们将这里决定出来的法线用N1（区别于真正的多边形几何法线）来代替；由于T、H、N1都是单位向量，由几何关系可以得到N1dotH = sin(T,H)，到此，我们就可以使用T、H来进行高光计算了；
模拟真正的头发高光 为了模拟头发真正的高光，还要基于对头发高光的观察进行部分假设，相应的观察假设在这张PPT上； 头发有两层高光； 主高光切变流向朝向发梢； 次高光拥有头发的颜色，且切变流向发根； 次高光带有闪烁效果，即不是很连续； 模拟两层高光比较简单，只需要计算两次高光即可；
如何模拟高光的切变流向，即一个位置偏向发梢，一个偏向发根；因为我们使用模型的T来计算的高光，要想改变高光位置，只能从T下手；AMD提供的方法为，使用N（这里是多边形几何的法线，不是法线平面中的法线N1）对T进行偏移；偏移量可以从贴图中进行采样，计算公式如下：
float ShiftTangent(float3 T, float3 N, float shift) { float3 shiftedT = T + shift * N; return normalize(shiftedT); } 如下图：T&amp;rsquo;与T'&amp;lsquo;是切变后的切向量； T表示发丝的方向，那么当发丝方向发生变化时，N（多边形对应法线）自然而然也同样产生变化，偏移后的N为：
float3 B = cross(N, T); N = cross(T, B); 实质上，N对T的偏移，是模拟头发的起伏，即发丝方向突出多边形平面或凹陷多边形平面；
次高光的闪烁效果模拟比较简单，只需要使用一个噪音纹理与次高光相乘即可；
渲染排序问题 由于头发具有半透效果，必须依据一定的顺序进行渲染才能得到正确的Blend效果；
模型内部排序 由于模型是一簇一簇的，因为只要决定簇之间的排序即可；依据视线观看头发的顺序，可以依照发簇距离头皮的距离进行排序；让靠近头皮的发簇对应的Index buffer排在整个模型Index buffer的前面；这样模型内部的渲染顺序就完全正确了；
修改Index buffer的顺序，可以由模型制作时合并的顺序来决定；也可以由程序进行单独处理；</description></item><item><title>皮肤渲染——Screen Space Separable Subsurface Scattering</title><link>/posts/pi-fu-xuan-ran-zhi-screen-space-separable-subsurface-scattering/</link><pubDate>Wed, 16 Sep 2020 11:31:29 +0000</pubDate><guid>/posts/pi-fu-xuan-ran-zhi-screen-space-separable-subsurface-scattering/</guid><description>总体来说，渲染步骤为：
首先对于不同的皮肤散射颜色，去计算相应的kernel（作为一维的颜色数组，存储该距离下次表面散射贡献），kernel是通过多层高斯曲线去拟合偶极子曲线得到的，因此需要多次高斯叠加计算；kernel的长度大小对应模糊的范围，也对应采样数的大小； 正常渲染皮肤，但要使用MRT，将diffuse成分与specular分离，并使用stencil进行标记； 在相机的BeforeImageEffectsOpaque时，进行皮肤部分的separable blur，并使用stencil test，保证只在皮肤部分进行blur；blur时要使用前面计算出来的kernel以及模型的曲率（借助深度的ddx、ddy计算），依据曲率来调整实际blur的范围； 将MRT进行合并，即blur后的diffuse部分与specular部分进行结合； Reference Separable Subsurface Scattering Advanced Techniques for Realistic Real-Time Skin Rendering</description></item></channel></rss>