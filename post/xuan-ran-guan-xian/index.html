<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>渲染管线 | CG黑魔法作坊</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://wingstone.github.io/favicon.ico?v=1600087881512">
<link rel="stylesheet" href="https://wingstone.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="管线介绍
所谓管线就是一个流程，针对硬件来说，处理一个图元有一个硬件渲染流程（Graphic Pipeline）；针对实际应用来说，渲染一帧画面也需要一个渲染流程（Render Path）；
GPU Graphic Pipeline
具体的..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://wingstone.github.io">
        <img src="https://wingstone.github.io/images/avatar.png?v=1600087881512" class="site-logo">
        <h1 class="site-title">CG黑魔法作坊</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      分享与记录关于CG技术的一切
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/wingstone/wingstone.github.io" target="_blank">wingstone</a> | <a class="rss" href="https://wingstone.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">渲染管线</h2>
            <div class="post-date">2020-09-14</div>
            
            <div class="post-content" v-pre>
              <h2 id="管线介绍">管线介绍</h2>
<p>所谓管线就是一个流程，针对硬件来说，处理一个图元有一个硬件渲染流程（Graphic Pipeline）；针对实际应用来说，渲染一帧画面也需要一个渲染流程（Render Path）；</p>
<h2 id="gpu-graphic-pipeline">GPU Graphic Pipeline</h2>
<p>具体的管线流程要看实际的硬件驱动，Direct3D每一个版本都有很大的改动，这里以Direct3D11为例进行介绍；具体的文章参考可以看这里：<a href="https://docs.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-graphics-pipeline">Direct3D 11 Graphics Pipeline</a>，<a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/pipelines-and-shaders-with-directx-12">Direct3D 12 Graphics Pipeline</a>；</p>
<h3 id="input-assembler-stage图元装配阶段">Input-Assembler Stage（图元装配阶段）</h3>
<p>这一阶段主要进行图元的装配，先从用户填充的缓冲中读取数据，然后将数据装配成图元；此阶段可装配成不同的图元类型（如 line lists, triangle strips, or primitives with adjacency）</p>
<h3 id="vertex-shader-stage顶点着色阶段">Vertex Shader Stage（顶点着色阶段）</h3>
<p><strong>一个可编程shader阶段</strong>，此阶段主要处理IA阶段输入的顶点，执行每顶点的处理（如变换、蒙皮、变形，顶点光照等）；VS阶段总是处理单一顶点，并输出单一顶点；VS阶段必须处于激活状态，VS必须提供；</p>
<h3 id="tessellation-stages细分阶段">Tessellation Stages（细分阶段）</h3>
<p>该阶段实际上有三个小阶段来完成图元的细分；通过硬件实现细分，GPU Graphic Pipeline能将低细节的模型转换为高细节模型进行渲染；</p>
<h4 id="hull-shader-stage壳着色阶段">Hull-Shader Stage（壳着色阶段）</h4>
<p><strong>一个可编程shader阶段</strong>，用来生成一个patch（和patch constants），每个patch对应一个输入的patch（quad, triangle, or line）；有点像一个基本的图元类型；</p>
<h4 id="tessellator-stage">Tessellator Stage</h4>
<p>一个固定处理阶段，用来生成简单格式的域，一个域代表一个geometry patch并用来生成更小物体的集合（triangles, points, or lines），通过连接domain sample来实现；</p>
<h4 id="domain-shader-stage域着色阶段">Domain-Shader Stage（域着色阶段）</h4>
<p><strong>一个可编程shader阶段</strong>，用来计算每个domain sample的顶点的位置，</p>
<h3 id="geometry-shader-stage几何着色阶段">Geometry Shader Stage（几何着色阶段）</h3>
<p><strong>一个可编程shader阶段</strong>，该阶段同样以顶点作为输入，以顶点作为输出；但与VS有很大不同；</p>
<ol>
<li>输入顶点数不一定为一，输入顶点数刚好可以可组成一完整图元（two vertices for lines, three vertices for triangles, or single vertex for point）；并且可以携带邻接的图元顶点数据（an additional two vertices for a line, an additional three for a triangle）；</li>
<li>输出顶点数不一定为一，输出的顶点数目可以形成特定的拓扑结构即可，输出的拓扑结构可选（GS stage output topologies available are: tristrip, linestrip, and pointlist）；</li>
</ol>
<h3 id="stream-output-stage流输出阶段">Stream-Output Stage（流输出阶段）</h3>
<p>该阶段的目的在于能够从不断的GS阶段输出顶点数据，至一个或多个缓存中；</p>
<h3 id="rasterizer-stage光栅化阶段">Rasterizer Stage（光栅化阶段）</h3>
<p>此阶段，将每个图元光栅化为像素，通过顶点差值来计算像素信息；光栅化过程总是运行顶点裁剪，透视除法，将顶点转换为齐次裁剪空间，然后将顶点映射到视口上；</p>
<h3 id="pixel-shader-stage像素着色器阶段">Pixel Shader Stage（像素着色器阶段）</h3>
<p><strong>一个可编程shader阶段</strong>，该阶段能够使用更加丰富的着色技术（每像素光照，后处理效果）；该阶段能够将常量，纹理数据，顶点差值数据以及其他数据进行计算，从而产生像素的输出；</p>
<h3 id="output-merger-stage输出合并阶段">Output-Merger Stage（输出合并阶段）</h3>
<p>该阶段生成最终的像素颜色，通过管线状态的整合，即：PS阶段生成的数据，如render target、depth/stencil buffer；OM阶段是用来决定可见颜色的最后一步，并且会Blend最终的像素颜色；</p>
<h2 id="render-path">Render Path</h2>
<p>Render Path称之为渲染路径更为合适，实际上指渲染一帧所要走的流程，这个流程主要用来处理光照，以及后处理等；常见的有Forward/Deferred Rendering；以及其改版Forward+、Tiled Based Deferred Rendering；以及更灵活的Frame Graph（寒霜引擎）、SRP（Unity引擎）；</p>
<h3 id="forward-rendering">Forward Rendering</h3>
<p>总的来说，前向渲染绘制次数为光源个数乘以物体个数，通常在一个pass中处理一个光源；然后多个pass处理多个光源，并在pass中通过blend add相加得到总的光照效果；</p>
<p><strong>DC复杂度为O(num(obj)*num(light))</strong>，通常会限制light的数量来减少DC；</p>
<p>更甚者，会将限制光源数量（一般附加光源数量为4），并将所有的光照写进一个Uber Shader，通过传递光照参数来实现；</p>
<h4 id="z-prepass避免overdraw问题">Z-Prepass避免overdraw问题</h4>
<p>具体来说，在实际渲染之前，加入了一个称之为z prepass的流程，这个流程关闭了color buffer的写入，同时pixel shader极为简单或者索性为空，可以非常快速的执行完毕并且获得场景中的z buffer；紧接着，我们再关闭z buffer的写入，改depth test function为equal。这样就只绘制我们所能看到的像素了（当然只针对于不透明问题）；</p>
<h3 id="deferred-rendering">Deferred Rendering</h3>
<p>得益于MRT的支持，我们可以发展处延迟渲染，它的核心技术是 <strong>第一阶段</strong> 在绘制物体时将光照所需要的的basecolor、normal、smoothness等信息存储于G-buffer中，而不进行真正的光照；待物体绘制完后， <strong>第二阶段</strong> 再重新使用G-buffer进行光照的计算（及将光照的计算进行推迟）；</p>
<p>传统的延迟渲染在G-Buffer生成之后，会根据光源的形状（light volume），对每个光源执行一次draw call，如果某个像素被light volume覆盖到了，我们就在该像素的位置执行一次当前光源的lighting计算。</p>
<p>需要注意的是，为了防止同一像素被光源正反面计算两次，我们需要在绘制light volume的时候使用单面渲染，如果摄像机在光源内，则需要开启正面剔除，并且将depth test设置为farOrEqual，如果摄像机在光源之外，则开启背面剔除，并且将depth test设置为nearOrEqual。</p>
<p><strong>DC的复杂度为O(num(obj)+num(light))</strong>；num(obj)为前期绘制物体的数量，num(light)为后期光照时光源的数量；在光照渲染时，同样通过blend add来实现多光源效果的叠加；</p>
<p>一种简单但耗费资源的做法：可以直接将所有光源信息传至一个shader，在这一个shader中进行所有光源的计算与累积，由于是在整个屏幕中进行计算，也就导致会产生多余的光照计算（光源照不到区域也进行了计算）；优点是只有O(1)的复杂度进行光照计算；</p>
<p>另外，G-Buffer除了用于直接照明外，还能够被用于一些间接照明的效果，比如SSAO，SSR；也正是G-Buffer概念的提出，使得近十年来越来越多的算法从world space向screen space的演进；</p>
<h3 id="light-pre-pass">Light Pre-Pass</h3>
<p>Light Pre-Pass是Deferred Rendering的一个变种，它将整个渲染流程分为<strong>三个阶段</strong>：</p>
<ol>
<li>只在G-Buffer中存储Z值和Normal值。对比Deferred Render，少了Diffuse Color， Specular Color以及对应位置的材质索引值。</li>
<li>在FS阶段（对应于普通Deferred Rendering的light volume绘制阶段）利用上面的G-Buffer计算出所必须的light properties，比如Normal*LightDir,LightColor,Specular等light properties。将这些计算出的光照进行blend add并存入LightBuffer（就是用来存储light properties的buffer）。</li>
<li>最后将结果送到forward rendering渲染方式计算最后的光照效果；采用Front to Back的绘制顺序，以及前面的LightBuffer进行光照计算；</li>
</ol>
<p>可以看到光照相关的light properties已经在第二阶段计算过了，第三阶段更多是光照成分的组合，因此又称之为Light Pre-Pass；总体的<strong>DC复杂度为O(num(obj)+num(light)+num(obj))</strong>，分别对应第一二三阶段；</p>
<p>相对于传统的Deferred Render，Light Pre-Pass第三步使用的其实是forward rendering，所以可以对每个mesh设置其材质，这两者是相辅相成的，有利有弊。另一个Light Pre-Pass的优点是在使用MSAA上很有利。</p>
<h3 id="tiled-based-deferred-rendering-forward">Tiled Based Deferred Rendering &amp; Forward+</h3>
<p>实际上TBDR和Forward+是tiled based方法在forward和deferred上各自的体现，相较于过去的管线，TBDR和Forward+增加了一个 <strong>light culling</strong> 的流程，这个流程把整个屏幕分割成若干个tile（通常每个tile是16*16个pixel），每个tile各自计算出一个单独的<strong>light list</strong>，找出场景中那些对当前tile有贡献的光源。然后对每个tile中的pixel，只需要计算其对应的tile中light list内的光源对该像素的贡献。</p>
<h4 id="tbdr">TBDR</h4>
<p><strong>light culling</strong> 后的光照计算过程，是在一个Computer shader中进行计算，针对每个tile，采用Deferred rendering只需累加相应light list的光照即可；<strong>不考虑tile数量，DC复杂度为O(1)</strong>；</p>
<p>由于只读取一次G-buffer，大大减少了带宽的影响；</p>
<h4 id="forward">Forward+</h4>
<p><strong>light culling</strong> 后的光照计算过程，针对每个tile里的物体，采用Forward rendering在一个shader中累加相应light list的光照即可；<strong>不考虑tile数量，复杂度为O(num(obj))</strong>；</p>
<p>与普通的Forward Rendering相比，其大大减少了DC的数量（因为所有的light都合到一个pass中进行了计算）；</p>
<p>另外，<strong>Z-Prepass</strong>对于Forward+来说是必须的，其大大减弱了Overdraw所带来的性能损耗；毕竟在Forward Rendering+流程中一个pass中进行了大量的light的运算；</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://wingstone.github.io/post/opengl-vertex-interpolation/">
                  <h3 class="post-title">
                    Opengl Vertex Interpolation
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
