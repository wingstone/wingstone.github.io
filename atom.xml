<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wingstone.github.io</id>
    <title>CG黑魔法作坊</title>
    <updated>2021-06-10T16:36:09.924Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wingstone.github.io"/>
    <link rel="self" href="https://wingstone.github.io/atom.xml"/>
    <subtitle>分享与记录关于CG技术的一切</subtitle>
    <logo>https://wingstone.github.io/images/avatar.png</logo>
    <icon>https://wingstone.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, CG黑魔法作坊</rights>
    <entry>
        <title type="html"><![CDATA[PostProcess关于UV的思考]]></title>
        <id>https://wingstone.github.io/post/postprocess-guan-yu-uv-de-si-kao/</id>
        <link href="https://wingstone.github.io/post/postprocess-guan-yu-uv-de-si-kao/">
        </link>
        <updated>2021-06-10T15:47:44.000Z</updated>
        <content type="html"><![CDATA[<p>以前一直以为屏幕空间下的UV应该是0-1的范围内的；</p>
<h2 id="blit操作下的postprocess">Blit操作下的PostProcess</h2>
<p>但是最近在做后处理时，对这件事重新进行了思考，其实Shader中使用的uv肯定是经过光栅化后的数据，既然是光栅化后的数据，那么UV坐标应该是像素中心的UV坐标；</p>
<p>后期一般都是通过DrawMesh来实现的，Mesh里的UV值为0-1，而此时的Mesh肯定需要覆盖整个屏幕，那么可以得到屏幕的最左侧uv.x = 0，最右侧uv.x = 1；而最左侧对应于最左列像素的左边，最右侧对应于最右列像素的右边；</p>
<p>由此可见，对于Vertex Shader，其UV是 <strong>0-1</strong> 范围内的；<br>
对于FragmentSahder，其UV范围是最左列像素坐标到最右侧像素坐标的，令_Size = float4(1/ScreenWidth, 1/ScreenHeight, ScreenWidth, ScreenHeight)，则UV范围为 <strong>(0.5*_Size.x~1-0.5*_Size.x, 0.5*_Size.y~1-0.5*_Size.y)</strong> ；</p>
<p>下图为10x10分辨率下的UV灰度图：<br>
<img src="https://wingstone.github.io/post-images/1623341545976.jpg" alt="" width="200" height="200" loading="lazy"><br>
可以看到最左列的灰度值并不为0，看来我们的思考是对的；</p>
<h2 id="computershader下的postprocess">ComputerShader下的PostProcess</h2>
<p>ComputerShader（简称CS）下的UV获取比较特殊，因为CS并不走正常的GPU绘制流水线，只是单纯的用多线程进行并行计算，所以我们在CS中获取UV值一般是由ThreadID除以屏幕分辨率来获取；</p>
<p>简易CS Example：</p>
<pre><code class="language-C">#pragma kernel CSMain

RWTexture2D&lt;float4&gt; _Result;
float4 _Size;   //(1/width, 1/height,  width, height)

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy/_Size.zw;
    _Result[id.xy] = uv.x;
}
</code></pre>
<p>threadID即为我们分配的线程ID，每个线程有唯一值，对于图片处理，一般范围为(0<sub>width-1,0</sub>height-1)，那么算下来，CS里的UV范围应该为 <strong>(0~1-_Size.x, 0~1-_Size.y)</strong> ；</p>
<p>下图为10x10分辨率下的UV灰度图：<br>
<img src="https://wingstone.github.io/post-images/1623342423558.jpg" alt="" width="200" height="200" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FXAA理论方法]]></title>
        <id>https://wingstone.github.io/post/fxaa-li-lun-fang-fa/</id>
        <link href="https://wingstone.github.io/post/fxaa-li-lun-fang-fa/">
        </link>
        <updated>2021-03-01T14:52:01.000Z</updated>
        <content type="html"><![CDATA[<p>FXAA是基于图像空间理论的抗拒齿方法；</p>
<h2 id="基础理论为">基础理论为：</h2>
<ol>
<li>进行图像边缘检测；</li>
<li>针对检测出来的图像边缘，进行抗拒齿处理；</li>
</ol>
<h2 id="基础步骤">基础步骤：</h2>
<ol>
<li><strong>采样屏幕颜色，转换至亮度；</strong><br>
Nvidia建议使用red以及green通道来计算亮度进行优化，人眼对这两种颜色最为敏感；亮度计算方法如下：</li>
</ol>
<pre><code class="language-c++">float FxaaLuma(float3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; }
</code></pre>
<ol start="2">
<li><strong>根据亮度来计算对比度，用对比度来作为边缘检测的标准；</strong><br>
一般边缘检测都会使用<strong>当前像素</strong>，以及<strong>上下左右四个像素</strong>来进行对比度的计算；当对比度大于某个阈值时，认为当前点处于边缘位置；</li>
</ol>
<pre><code class="language-c++">float3 rgbN  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0,-1)).xyz;
float3 rgbW  = FxaaTextureOffset(tex, pos.xy, FxaaInt2(-1, 0)).xyz;
float3 rgbM  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0, 0)).xyz;
float3 rgbE  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 1, 0)).xyz;
float3 rgbS  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0, 1)).xyz;
float lumaN  = FxaaLuma(rgbN);
float lumaW  = FxaaLuma(rgbW);
float lumaM  = FxaaLuma(rgbM);
float lumaE  = FxaaLuma(rgbE);
float lumaS  = FxaaLuma(rgbS);
float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));
float range = rangeMax -rangeMin;
if(range &lt; max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * XAA_EDGE_THRESHOLD))           {return FxaaFilterReturn(rgbM); }
</code></pre>
<ol start="3">
<li><strong>边缘的横纵向检测，用于后续抗拒齿处理；</strong><br>
边缘进行光栅化之后，在比较小的维度上，只有横向边缘与纵向边缘之分；检测出来横向与纵向，可以便于后续沿边缘进行延伸；</li>
</ol>
<pre><code class="language-c++">float edgeVert = abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));
float edgeHorz = abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));
bool horzSpan = edgeHorz &gt;= edgeVert;   //判断当前像素位于横向边缘还是纵向边缘
</code></pre>
<p>4.** 判断真正的边缘边界位置，并将当前点定位到真正的边缘边界处；**<br>
检测出横向还是纵向后，需要定位边缘边界是在上横向还是下横向，左横向还是右横向；<br>
当前点是在像素中心，定位出边缘边界（位于两个像素的交接处）后，即可将当前点移动到边缘边界；</p>
<pre><code class="language-c++">// 梯度最大处作为边缘边界的位置；
float luma1 = isHorizontal ? lumaDown : lumaLeft;
float luma2 = isHorizontal ? lumaUp : lumaRight;
float gradient1 = luma1 - lumaCenter;
float gradient2 = luma2 - lumaCenter;
bool is1Steepest = abs(gradient1) &gt;= abs(gradient2);

// 我也不清楚此处为什么要用0.25来进行normalize，感觉就是一个简单的factor；
float gradientScaled = 0.25*max(abs(gradient1),abs(gradient2));

float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;

//边缘边界处（计算像素相交处）的亮度平均值
float lumaLocalAverage = 0.0;
if(is1Steepest){
    stepLength = - stepLength;
    lumaLocalAverage = 0.5*(luma1 + lumaCenter);
} else {
    lumaLocalAverage = 0.5*(luma2 + lumaCenter);
}

// 将uv移动半个像素，定位到边缘边界处（像素相交处）.
vec2 currentUv = In.uv;
if(isHorizontal){
    currentUv.y += stepLength * 0.5;
} else {
    currentUv.x += stepLength * 0.5;
}
</code></pre>
<ol start="5">
<li>定位到边界处，需要沿边缘方向（横向或纵向）进行搜索，来计算当前边缘的长度；<br>
之所以计算边缘的长度，是因为锯齿一般都出现在边缘端点处；离端点越远，越不容易产生锯齿；我们需要计算当前边缘边界距边缘端点的距离，用来计算锯齿的强弱程度；</li>
</ol>
<pre><code class="language-c++">// 第一步迭代
vec2 offset = isHorizontal ? vec2(inverseScreenSize.x,0.0) : vec2(0.0,inverseScreenSize.y);
vec2 uv1 = currentUv - offset;
vec2 uv2 = currentUv + offset;

float lumaEnd1 = rgb2luma(texture(screenTexture,uv1).rgb);
float lumaEnd2 = rgb2luma(texture(screenTexture,uv2).rgb);
lumaEnd1 -= lumaLocalAverage;
lumaEnd2 -= lumaLocalAverage;

bool reached1 = abs(lumaEnd1) &gt;= gradientScaled;
bool reached2 = abs(lumaEnd2) &gt;= gradientScaled;
bool reachedBoth = reached1 &amp;&amp; reached2;

if(!reached1){
    uv1 -= offset;
}
if(!reached2){
    uv2 += offset;
}  

// 继续后面的迭代
if(!reachedBoth){

    for(int i = 2; i &lt; ITERATIONS; i++){
        if(!reached1){
            lumaEnd1 = rgb2luma(texture(screenTexture, uv1).rgb);
            lumaEnd1 = lumaEnd1 - lumaLocalAverage;
        }
        if(!reached2){
            lumaEnd2 = rgb2luma(texture(screenTexture, uv2).rgb);
            lumaEnd2 = lumaEnd2 - lumaLocalAverage;
        }
        reached1 = abs(lumaEnd1) &gt;= gradientScaled;
        reached2 = abs(lumaEnd2) &gt;= gradientScaled;
        reachedBoth = reached1 &amp;&amp; reached2;

        // 此处QUALITY为迭代步进的缩放系数，一般前5步为1，后面可逐渐递增
        if(!reached1){
            uv1 -= offset * QUALITY(i);
        }
        if(!reached2){
            uv2 += offset * QUALITY(i);
        }

        if(reachedBoth){ break;}
    }
}
</code></pre>
<ol start="6">
<li>偏移（此偏移量作用于最初uv，用于最终采样）估算<br>
前面说到越靠近边缘终点，锯齿越严重，那么最终像素输出采样点的偏移量越大；与此相反，越靠近边缘中点，输出采样点的偏移量越小；算法如下：</li>
</ol>
<pre><code class="language-c++">// 使用边缘边界点与边缘终点的距离处于边缘的长度来计算offset
float distance1 = isHorizontal ? (In.uv.x - uv1.x) : (In.uv.y - uv1.y);
float distance2 = isHorizontal ? (uv2.x - In.uv.x) : (uv2.y - In.uv.y);
bool isDirection1 = distance1 &lt; distance2;
float distanceFinal = min(distance1, distance2);
float edgeThickness = (distance1 + distance2);
float pixelOffset = - distanceFinal / edgeThickness + 0.5;

// 添加额外的判断，来保证端点处的走势（gradient）与中心处的一致
bool isLumaCenterSmaller = lumaCenter &lt; lumaLocalAverage;
bool correctVariation = ((isDirection1 ? lumaEnd1 : lumaEnd2) &lt; 0.0) != isLumaCenterSmaller;
float finalOffset = correctVariation ? pixelOffset : 0.0;
</code></pre>
<ol start="7">
<li>子像素抗拒齿处理<br>
使用额外的步骤即可处理子像素抗拒齿（即细线引起的锯齿，或点引起的锯齿，我也不知道为啥叫做子像素锯齿==）；<br>
基本思路是计算中心点与周围点的差值，然后计算此差值与局部差值的比值来计算子像素抗拒齿的偏移量；最终选择较大偏移量作为最终采样值；</li>
</ol>
<pre><code class="language-c++">float lumaAverage = (1.0/12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);
float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter)/lumaRange,0.0,1.0);
float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;
float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * SUBPIXEL_QUALITY;

// Pick the biggest of the two offsets.
finalOffset = max(finalOffset,subPixelOffsetFinal);
</code></pre>
<ol start="8">
<li>使用最终偏移量进行采样;</li>
</ol>
<pre><code class="language-c++">vec2 finalUv = In.uv;
if(isHorizontal){
    finalUv.y += finalOffset * stepLength;
} else {
    finalUv.x += finalOffset * stepLength;
}

vec3 finalColor = texture(screenTexture,finalUv).rgb;
fragColor = finalColor;
</code></pre>
<p>注意点：FXAA运行在sRGB空间；直接作用于linear、hdr数据，会出现闪烁问题；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity中序列化Asset的修改]]></title>
        <id>https://wingstone.github.io/post/unity-zhong-xu-lie-hua-asset-de-xiu-gai/</id>
        <link href="https://wingstone.github.io/post/unity-zhong-xu-lie-hua-asset-de-xiu-gai/">
        </link>
        <updated>2021-02-28T15:31:35.000Z</updated>
        <content type="html"><![CDATA[<p>代码片段事例：</p>
<pre><code>        Object obj = new Object();
        SerializedObject so = new SerializedObject(obj);     //这里obj为要进行序列化操作的asset对象
        SerializedProperty sp = so.FindProperty(&quot;property&quot;);    //这里property为要进行操作的property，需要查看asset文件获取
        sp.boolValue = true;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种常用渲染技术文章集合]]></title>
        <id>https://wingstone.github.io/post/ge-chong-chang-yong-xuan-ran-ji-zhu-wen-zhang-ji-he/</id>
        <link href="https://wingstone.github.io/post/ge-chong-chang-yong-xuan-ran-ji-zhu-wen-zhang-ji-he/">
        </link>
        <updated>2020-11-11T13:52:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="localcubemap">LocalCubemap</h2>
<p><a href="https://armkeil.blob.core.windows.net/developer/Files/pdf/graphics-and-multimedia/ImplementingReflectionsinUnityUsingLocalCubemaps.pdf">ImplementingReflectionsinUnityUsingLocalCubemaps PDF</a><br>
<a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity">Reflections Based on Local Cubemaps in Unity Web</a></p>
<h2 id="clearcoat">ClearCoat</h2>
<p><a href="https://google.github.io/filament/Filament.html#materialsystem/clearcoatmodel">Clear coat model in filament Web</a></p>
<h2 id="cloud-in-sky">Cloud In Sky</h2>
<p><a href="http://walkingfat.com/bump-noise-cloud-3d%e5%99%aa%e7%82%b9gpu-instancing%e5%88%b6%e4%bd%9c%e5%9f%ba%e4%ba%8e%e6%a8%a1%e5%9e%8b%e7%9a%84%e4%bd%93%e7%a7%af%e4%ba%91/">Bump Noise Cloud – 3D噪点+GPU instancing制作基于模型的体积云 Web</a><br>
<a href="https://blog.csdn.net/qq_33967521/article/details/102657017">浅谈《Sky 光·遇》中的渲染技术 Web</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[景深的实现技术]]></title>
        <id>https://wingstone.github.io/post/jing-shen-de-shi-xian-ji-zhu/</id>
        <link href="https://wingstone.github.io/post/jing-shen-de-shi-xian-ji-zhu/">
        </link>
        <updated>2020-10-20T08:47:41.000Z</updated>
        <content type="html"><![CDATA[<p>景深的实现技术有很多，针对不同的使用场景，可以使用不同的方法；</p>
<h2 id="基于光线追踪的景深效果离线">基于光线追踪的景深效果（离线）</h2>
<p>基于光线追踪的景深效果，直接使用薄透镜模型，在透镜上面进行多采样即可实现景深效果；</p>
<p>关于薄透镜理论的使用，可以参考这里<a href="https://zhuanlan.zhihu.com/p/23827065">基于摄影参数渲染</a>;</p>
<h2 id="基于累积贴图的景深效果实时">基于累积贴图的景深效果（实时）</h2>
<p>大致思路为，将相机进行移动（可按照透镜多采样的方式移动），沿焦平面进行多个相机的渲染，然后将渲染结果进行累加，这样就能获取与光线追踪类似的效果；本质上类似于光线追踪的多采样方式，但需要花费大量的DC，一般只用来验证；</p>
<h2 id="基于分层绘制的景深效果实时">基于分层绘制的景深效果（实时）</h2>
<p>本质上，是基于2D图层的方式来实现；将场景按深度进行分层绘制，然后将远离焦距的绘制rt记性模糊，然后按层进行混合，即可获取接近景深的效果；</p>
<p>使用要求时，不同的景物之间不能有交叉，即物体不能有太强的深度变化；因为针对单个物体是无法产生即聚焦又失焦的现象；</p>
<h2 id="基于前向映射的z-buffer的景深效果实时">基于前向映射的Z-buffer的景深效果（实时）</h2>
<p>此方法常用在后处理效果中，该方法存储颜色缓冲与深度缓冲作为最后的blit对象；然后使用深度缓冲计算COC（circle of confusion），即点投影在屏幕上形成的弥散圆；再然后利用弥散圆进行模糊与blend，这里模糊并不是通常意义上的模糊，模糊需要的圆盘采样与普通模糊一致，但是采样的判定需要根据采样点的COC是否能覆盖到当前点，来确定该采样点的弥散圆是否对当前点有贡献；GPU Gems中说blend只能混合到距离摄像机比自己远的那些相邻像素中，以避免模糊的像素影响它们前面的清晰像素。实际上，blend的是为了避免前面模糊造成聚焦物体边缘的消失；</p>
<h2 id="基于反向映射的z-buffer的景深效果实时">基于反向映射的Z-buffer的景深效果（实时）</h2>
<p>该方法与上一种技术类似，区别在于并不是通过blend来形成最后的图像，而是通过使用深度值距焦距的距离来进行blur，从而形成最终的效果；这里把当前点的弥散圆当做模糊范围来进行计算了，与实际的PBR有些偏差，但也能凑活使用；</p>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/depth-of-field/">Depth of Field</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-23-depth-field-survey-techniques">Depth of Field: A Survey of Techniques</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23827065">基于摄影参数渲染</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/146143501">渲染中的景深(Depth of Field/DOF)</a></li>
<li><a href="https://epicgames.ent.box.com/s/s86j70iamxvsuu6j35pilypficznec04">A Life of a Bokeh - SIGGRAPH 2018</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后处理技术——景深]]></title>
        <id>https://wingstone.github.io/post/hou-chu-li-ji-zhu-jing-shen/</id>
        <link href="https://wingstone.github.io/post/hou-chu-li-ji-zhu-jing-shen/">
        </link>
        <updated>2020-10-20T08:05:48.000Z</updated>
        <content type="html"><![CDATA[<p>景深是能体现场景纵深的重要效果，同时还能虚化前景与背景，这样可以让玩家将注意力集中在聚焦物体上；</p>
<h2 id="实现步骤">实现步骤</h2>
<h3 id="提取coc">提取COC</h3>
<p>所谓COC即circle of confusion，表示一点投影在屏幕上所形成的弥散圆。可知，焦距上的点仍然会形成点，而远离焦距的点则会形成弥散圆；</p>
<p>一般将COC的半径存储为rt，此半径需要根据焦距（focus distance）以及焦距范围（focus range）来进行计算；</p>
<h3 id="计算散景效果">计算散景效果</h3>
<p>实际上就是使用圆形范围的模糊效果来进行RT的blit；这里模糊并不是通常意义上的模糊，模糊需要的圆盘采样与普通模糊一致，但是采样的判定需要根据采样点的COC是否能覆盖到当前点，来确定该采样点的弥散圆是否对当前点有贡献（GPU Gems中说blend只能混合到距离摄像机比自己远的那些相邻像素中，以避免模糊的像素影响它们前面的清晰像素。）；</p>
<p>考虑到采样所带来的的效率问题，一般都会讲rt进行降采样处理；同样的COC也要记性降采样，才可以使用，一般会将其存储至rt的alpha通道；</p>
<p>一般散景模糊主要考虑的就是效率问题，可以采用其他的途径来获取相应效果；毕竟只是实现模糊就有很多种不同方法；</p>
<h3 id="与物模糊背景进行融合">与物模糊背景进行融合</h3>
<p>计算散景效果时，对于聚焦物体的边缘部分，还是会产生模糊问题；为了比较这种问题产生，只能使用blend方法，将这些区域恢复为原来的无模糊图像；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[天空渲染——大气物理]]></title>
        <id>https://wingstone.github.io/post/tian-kong-xuan-ran-da-qi-wu-li/</id>
        <link href="https://wingstone.github.io/post/tian-kong-xuan-ran-da-qi-wu-li/">
        </link>
        <updated>2020-10-10T07:38:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="大气物理现象">大气物理现象</h2>
<p>假设1：空气密度随着高度成指数进行衰减；即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>=</mo><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>(</mo><mn>0</mn><mo>)</mo><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>h</mi><mi>H</mi></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">density(h) = density(0)e^{-\frac{h}{H}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.27902em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.02902em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中density(0)为海平面密度，h为当前高度，H为scale height，随温度变化；不是所有的人都采用这种模型，另一种密度假设为分层模型，每一层采用不同的大气密度；</p>
<p>大气分子散射主要可分为<strong>空气分子散射（Rayleigh scattering，小于光线波长）<strong>与</strong>气溶胶散射（Mie scattering，大于光线波长）</strong>；空气分子散射主要会产生天空的蓝色成分与橘黄色成分（日出、日落时分），气溶胶散射主要会导致灰白色条带（特别是污染都市上空）；</p>
<p>在进行光追计算时，还需要进行地球半径的假设，以及大气层半径的假设；我们假设地球半径为6360 km，大气半径为6420 km，此外还需要假设太阳光为平行光，因为太阳距地球足够远；</p>
<p>计算的过程中需要注意量纲的统一，一般都去Km；</p>
<p>熟悉体渲染的人应该知道，物体的体渲染熟悉可以用散射系数（针对外散射）、吸收系数、相位函数（针对内散射）进行描述，我们这里忽略大气吸收的过程，即忽略吸收系数的计算；</p>
<h2 id="rayleigh-scattering">Rayleigh scattering</h2>
<p>Rayleigh scattering具有很强的波长依赖性，散射蓝光比绿光和红光具有更高的精确性；</p>
<p>Rayleigh首先提出了计算此现象的公式，他给出了散射系数的公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>λ</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mn>8</mn><msup><mi>π</mi><mn>3</mn></msup><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow><mrow><mn>3</mn><mi>N</mi><msup><mi>λ</mi><mn>4</mn></msup></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>h</mi><msub><mi>H</mi><mi>R</mi></msub></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">{\beta}_R^s(h, \lambda) = \frac{8\pi^3(n^2-1)^2}{3N\lambda^4}e^{-\frac{h}{H_R}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.133835em;"><span style="top:-3.5178149999999997em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.6559999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:-0.08125em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833299999999998em;"></span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.33853em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5858071428571429em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这里<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>表示波长，N表示大气分子密度，n为大气折射率，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">H_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>即为前面的scale height，此处我们取8Km；</p>
<p>参考文献中N与n并没有给出相应的参数，但是给出了相应的散射系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup><mo>=</mo><mo>(</mo><mn>5.8</mn><mo separator="true">,</mo><mn>13.5</mn><mo separator="true">,</mo><mn>33.1</mn><mo>)</mo><mn>1</mn><msup><mn>0</mn><mo>−</mo></msup><mn>6</mn><msup><mi>m</mi><mo>−</mo></msup><mn>1</mn></mrow><annotation encoding="application/x-tex">\beta^s_R=(5.8, 13.5, 33.1)10^-6m^-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9697709999999999em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">.</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">6</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">1</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mo>(</mo><mn>680</mn><mo separator="true">,</mo><mn>550</mn><mo separator="true">,</mo><mn>440</mn><mo>)</mo><mi>n</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">\lambda=(680, 550, 440)nm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">8</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">5</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mord">0</span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span></span></span></span>；</p>
<p>渲染使用的extinction coefficient为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>e</mi></msubsup><mo>=</mo><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup></mrow><annotation encoding="application/x-tex">\beta_R^e = \beta_R^s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>相位函数的公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>R</mi></msub><mo>(</mo><mi>μ</mi><mo>)</mo><mo>=</mo><mfrac><mn>3</mn><mrow><mn>16</mn><mi>π</mi></mrow></mfrac><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>μ</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">P_R(\mu)=\frac{3}{16\pi}(1+\mu^2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>表示光线与视角的夹角；</p>
<h2 id="mie-scattering">Mie Scattering</h2>
<p>与Rayleigh Scattering类似，其散射公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>M</mi><mi>s</mi></msubsup><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>λ</mi><mo>)</mo><mo>=</mo><msubsup><mi>β</mi><mi>M</mi><mi>s</mi></msubsup><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>λ</mi><mo>)</mo><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>h</mi><msub><mi>H</mi><mi>M</mi></msub></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\beta_M^s(h,\lambda)=\beta_M^s(0,\lambda) e^{-\frac{h}{H_M}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.383835em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.133835em;"><span style="top:-3.5178149999999997em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.6559999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:-0.08125em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833299999999998em;"></span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.33853em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5858071428571429em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">H_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>通常取1.2Km；同样类似于Rayleigh Scattering，气溶胶密度也随高度进行指数衰减，我们直接取散射系数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>M</mi><mi>s</mi></msubsup><mo>=</mo><mn>210</mn><mi>x</mi><mn>1</mn><msup><mn>0</mn><mo>−</mo></msup><mn>5</mn><msup><mi>m</mi><mo>−</mo></msup><mn>1</mn></mrow><annotation encoding="application/x-tex">\beta^s_M=210x10^-5m^-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9697709999999999em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">1</span></span></span></span>；</p>
<p>渲染使用的extinction coefficient为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>e</mi></msubsup><mo>=</mo><mn>1.1</mn><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup></mrow><annotation encoding="application/x-tex">\beta_R^e = 1.1\beta_R^s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>相位函数为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>M</mi></msub><mo>(</mo><mi>μ</mi><mo>)</mo><mo>=</mo><mfrac><mn>3</mn><mrow><mn>8</mn><mi>π</mi></mrow></mfrac><mfrac><mrow><mo>(</mo><mn>1</mn><mo>−</mo><msup><mi>g</mi><mn>2</mn></msup><mo>)</mo><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>μ</mi><mn>2</mn></msup><mo>)</mo></mrow><mrow><mo>(</mo><mn>2</mn><mo>+</mo><msup><mi>g</mi><mn>2</mn></msup><mo>)</mo><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>g</mi><mn>2</mn></msup><mo>−</mo><mn>2</mn><mi>g</mi><mi>μ</mi><msup><mo>)</mo><mfrac><mn>3</mn><mn>2</mn></mfrac></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">P_M(\mu)=\frac{3}{8\pi}\frac{(1-g^2)(1+\mu^2)}{(2+g^2)(1+g^2-2g\mu)^{\frac{3}{2}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.570678em;vertical-align:-1.07957em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.17043em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.93957em;"><span style="top:-3.3485500000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.07957em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>项用来控制介质的各向异性，一般取0.76；</p>
<h2 id="reference">Reference</h2>
<p><a href="https://www.ea.com/frostbite/news/physically-based-sky-atmosphere-and-cloud-rendering">寒霜引擎天空渲染实现</a></p>
<p><a href="https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky">Simulating the Colors of the Sky</a></p>
<p><a href="http://www-ljk.imag.fr/Publications/Basilic/com.lmc.publi.PUBLI_Article@11e7cdda2f7_f64b69/article.pdf">Precomputed Atmospheric Scattering</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软阴影技术——PCF、ESM、VSM、CSM、PCSS]]></title>
        <id>https://wingstone.github.io/post/yin-ying-ji-zhu-pcfesmvsmpcss/</id>
        <link href="https://wingstone.github.io/post/yin-ying-ji-zhu-pcfesmvsmpcss/">
        </link>
        <updated>2020-09-30T15:39:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pcfpercentage-closer-filtering">PCF（Percentage-Closer Filtering）</h2>
<p>就是对阴影结果进行滤波，这里的阴影结果指阴影测试函数所得的结果；一般采用双线性滤波，此时可以使用硬件PCF来进行插值；</p>
<h3 id="实现要求">实现要求</h3>
<p>Depth格式的shadow map或者ShadowMap格式的shadow map；</p>
<h2 id="esmexponential-shadow-maps">ESM（Exponential Shadow Maps）</h2>
<p>PCF方法对阴影结果进行滤波，无法集成到阴影测试函数中；因此可以采用其他的阴影测试函数来进行实现软阴影效果；</p>
<p>ESM采用指数空间下的深度测试函数来代替传统的深度测试函数；</p>
<p>采用ESM方法，存储的为指数空间下的阴影数值，支持预滤波，这样就可以对shadowmap进行blur，将滤波与测试函数进行分离；</p>
<p>传统shadowmap存储的为深度z，而在ESM中存储的为<code>exp(c*z)</code>，即深度值的指数形式；其中c表示指数常数，对于32位存储格式，极限值为88；</p>
<p>而阴影测试函数，传统的shadowmap为<code>step(d, z)</code>，而ESM的阴影测试函数则变为<code>exp(-cd)*tz</code>；其中tz表示采样的指数深度值，即<code>exp(c*z)</code>，这样原来的<code>z-d</code>转变为了<code>exp(c(z-d))</code>；</p>
<h3 id="所带来的问题有">所带来的问题有：</h3>
<ol>
<li>计算出来的阴影值与shadow caseter、shadow receiver之间的距离有关，距离越远，阴影越黑，越近，阴影越接近于无；</li>
<li>多重阴影下，肯会由于shadow map精度问题产生瑕疵；</li>
<li>对rt精度要求比较高；</li>
</ol>
<h3 id="实现需求">实现需求</h3>
<p>一张Depth格式的shadow map即可，需要手动对其进行模糊；</p>
<h2 id="renference">Renference</h2>
<ol>
<li>《实时阴影技术》 艾森曼努；</li>
<li><a href="https://zhuanlan.zhihu.com/p/26853641">实时渲染中的软阴影技术</a></li>
<li><a href="http://www.klayge.org/2013/10/07/%e5%88%87%e6%8d%a2%e5%88%b0esm/">切换到esm</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[贴图技术——Parallax Mapping（视差贴图）]]></title>
        <id>https://wingstone.github.io/post/texture-technique-parallax-mappingshi-chai-tie-tu/</id>
        <link href="https://wingstone.github.io/post/texture-technique-parallax-mappingshi-chai-tie-tu/">
        </link>
        <updated>2020-09-30T05:10:15.000Z</updated>
        <content type="html"><![CDATA[<p>视差贴图属于位移贴图(Displacement Mapping)技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一般使用位移贴图之前，需要对模型进行细分（细分着色器），然后进行顶点位移；</p>
<p>位移贴图要想有好的效果，需要大量顶点支持，而使用视差贴图即可省去大量的顶点使用；</p>
<p>视差贴图的原理实际上是对采样纹理坐标进行偏移，而偏移的原理根据视角观察高度图的真实过程进行模拟，因此可以模拟出真实的贴图凹凸遮挡关系；</p>
<p>在实际的使用过程中，一般使用 <strong>深度图来代替高度图</strong> ，两种互为反相；</p>
<h2 id="parallax-mapping">Parallax mapping</h2>
<p>最原始视差贴图方法就叫Parallax mapping，其大概原理是：在切线空间下，当前采样坐标获得的高度作为V向量偏移的长度，然后偏移后的长度在切平面的投影即为坐标的偏移量</p>
<pre><code class="language-C++">//_ParallaxHeight为一控制参数
uv -= tex2D(_HightMap, uv)*TV.xy*_ParallaxHeight;     //V向量为切空间下的向量
</code></pre>
<p>在高度图变化比较剧烈的地方，采用这种方法会有很对问题；因此又发展出了Steep Parallax Mapping（陡峭视差贴图）；</p>
<h2 id="steep-parallax-mapping">Steep Parallax Mapping</h2>
<p>对于高度变化剧烈地方，其实很难通过一步就定位到偏移后的位置，陡峭视差贴图方法实际上就是ray matching方法，使用此方法可以更精确的定位到偏移后位置；但由于ray matching算法的性质，在计算量不足的情况下，容易出现分层的痕迹；针对分层问题，后面提出了Parallax Occlusion Mapping(视差遮蔽映射)方法；</p>
<p>该算法首先将深度值进行分层，每一步递进一层；若当前步所获取深度值与步进深度值的差值的符号，与前一步相反，则可定位当前层深度即为偏移深度；分层数量越多，计算量越大，计算结果越精细；</p>
<pre><code class="language-C++">float numLayers = 10;
float depthStep = 1.0 / numLayers;
float currentDepth = 0.0;
float2 uvStep = TV.xy * _ParallaxHeight/ numLayers; 
float currentDepthMapValue = tex2D(_DepthTex, uv).r;

for(int i = 0; i&lt; 10; i++)
{
    if(currentDepth &gt; currentDepthMapValue)
        break;
    uv -= uvStep;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    currentDepth += depthStep;  
}
</code></pre>
<h2 id="parallax-occlusion-mapping">Parallax Occlusion Mapping</h2>
<p>视差遮蔽贴图与陡峭视差贴图类似，区别仅在于最后深度的选择；陡峭视差贴图最终的深度为步进深度的倍数，并且最终深度大于此位置的采样深度，而前一步的深度小于前一步位置的采样深度；针对此现象，我们可以在两者之间进行深度插值，这样最终采样深度就是一个连续的分布了；</p>
<p>插值的根本原理就是相似三角形原理；代码如下，示意图请看参考引用；</p>
<pre><code class="language-C++">float numLayers = 10;
float depthStep = 1.0 / numLayers;
float currentDepth = 0.0;
float2 uvStep = TV.xy * _ParallaxHeight/ numLayers; 
float currentDepthMapValue = tex2D(_DepthTex, uv).r;

float preDiff = 1e-5;       //防止除0
for(int i = 0; i&lt; 10; i++)
{
    if(currentDepth &gt;= currentDepthMapValue)
    {
        float curDiff = currentDepth-currentDepthMapValue;
        uv -= uvStep*preDiff/(curDiff+preDiff);
        break;
    }
    else
        preDiff = currentDepthMapValue - currentDepth;
    uv -= uvStep;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    currentDepth += depthStep; 
}
</code></pre>
<h2 id="relief-mapping">Relief Mapping</h2>
<p>视差遮蔽贴图在最后的一步采用插值进行计算，本质上是采用线性分布模拟步进深度中的非线性深度分布；因此最好的方法就是采用更细的步进深度进行测试，但这样就要求需要有大量的步进运算；因此可采用二分法方法来进行步进，这样可以更快定位到相交的深度；但是二分法要求单调性，实际的深度分布不可能是但单调分布的，因此最佳的步进方法为，先进行大步进深度的传统线性步进，再进行二分步进，这就是Relief Mapping的中心思想；</p>
<pre><code class="language-C++">//linear rematching
float numLayers = 10;
float depthStep = 1.0 / numLayers;
float currentDepth = 0.0;
float2 uvStep = TV.xy * _ParallaxHeight/ numLayers; 
float currentDepthMapValue = tex2D(_DepthTex, uv).r;

for(int i = 0; i&lt; 10; i++)
{
    if(currentDepth &gt; currentDepthMapValue)
    {
        break;
    }
    uv -= uvStep;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    currentDepth += depthStep;  
}

//binary rematching
for(int i = 0; i&lt; 8; i++)
{
    uvStep *= 0.5;
    depthStep *= 0.5;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    if(currentDepth &lt; currentDepthMapValue)
    {
        uv -= uvStep;
        currentDepth += depthStep;
    }
    else
    {
        uv += uvStep;
        currentDepth -= depthStep;
    }
}
</code></pre>
<p>实际上，深度图的使用原理，与地形及其类似；确定好视线与深度相交点后，就可以沿光源方向进行阴影计算，<a href="https://shintaroiguchidotcom.files.wordpress.com/2016/01/relief-mapping-in-a-pixel-shader-using-binary-search.pdf">PDF：Relief Mapping</a>这篇文章也提到了使用深度图进行自投影的计算；</p>
<p>关于使用raymatching方法进行地形的渲染，可以参考<a href="https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm">iq：raymarching terrains</a>，读完后相应对于视差贴图的理解可以更深一步；</p>
<h2 id="个人思考">个人思考</h2>
<p>从结果上来看，确实算法越来越精确了，但是都要有一个严重的问题：如下图所示：<br>
<img src="https://wingstone.github.io/post-images/1601477127814.jpg" alt="实际运行图片" loading="lazy"><br>
可以看出，在视差起作用的边界处，出现了明显的锯齿，感觉如何解决这个要命的问题才是当下需要着重研究的；</p>
<h2 id="参考">参考</h2>
<p><a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">learnopengl：Parallax-Mapping</a><br>
<a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/">learnopengl中文版：Parallax-Mapping</a><br>
<a href="https://shintaroiguchidotcom.files.wordpress.com/2016/01/relief-mapping-in-a-pixel-shader-using-binary-search.pdf">PDF：Relief Mapping</a><br>
<a href="https://en.wikipedia.org/wiki/Parallax_mapping">Wiki：Parallax mapping</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NPR之描边]]></title>
        <id>https://wingstone.github.io/post/npr-zhi-miao-bian/</id>
        <link href="https://wingstone.github.io/post/npr-zhi-miao-bian/">
        </link>
        <updated>2020-09-28T07:49:37.000Z</updated>
        <content type="html"><![CDATA[<p><strong>对于非平滑模型，采用背部扩展描边的方式，容易出现断裂问题；</strong></p>
<p>解决方法为：<strong>使用高模的平滑法线来进行背面的扩展</strong>，可以使用法线贴图计算高模法线；</p>
<p>对于NPR渲染，其实一般也不怎么使用贴图；所以可以<strong>将高模的法线bake到顶点色</strong>里面；</p>
<p>由于蒙皮网格会实时计算变换后的切空间下的normal、tangent、binormal；因此不能bake local space下的高模法线，除非将local space下的高模法线bake到tangent或binormal进行存储，或者将tangent space下的高模法线bake到顶点色里进行存储；</p>
]]></content>
    </entry>
</feed>