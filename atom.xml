<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wingstone.github.io</id>
    <title>CG黑魔法作坊</title>
    <updated>2020-09-30T14:56:03.839Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wingstone.github.io"/>
    <link rel="self" href="https://wingstone.github.io/atom.xml"/>
    <subtitle>分享与记录关于CG技术的一切</subtitle>
    <logo>https://wingstone.github.io/images/avatar.png</logo>
    <icon>https://wingstone.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CG黑魔法作坊</rights>
    <entry>
        <title type="html"><![CDATA[贴图技术——Parallax Mapping（视差贴图）]]></title>
        <id>https://wingstone.github.io/post/texture-technique-parallax-mappingshi-chai-tie-tu/</id>
        <link href="https://wingstone.github.io/post/texture-technique-parallax-mappingshi-chai-tie-tu/">
        </link>
        <updated>2020-09-30T05:10:15.000Z</updated>
        <content type="html"><![CDATA[<p>视差贴图属于位移贴图(Displacement Mapping)技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一般使用位移贴图之前，需要对模型进行细分（细分着色器），然后进行顶点位移；</p>
<p>位移贴图要想有好的效果，需要大量顶点支持，而使用视差贴图即可省去大量的顶点使用；</p>
<p>视差贴图的原理实际上是对采样纹理坐标进行偏移，而偏移的原理根据视角观察高度图的真实过程进行模拟，因此可以模拟出真实的贴图凹凸遮挡关系；</p>
<p>在实际的使用过程中，一般使用 <strong>深度图来代替高度图</strong> ，两种互为反相；</p>
<h2 id="parallax-mapping">Parallax mapping</h2>
<p>最原始视差贴图方法就叫Parallax mapping，其大概原理是：在切线空间下，当前采样坐标获得的高度作为V向量偏移的长度，然后偏移后的长度在切平面的投影即为坐标的偏移量</p>
<pre><code class="language-C++">//_ParallaxHeight为一控制参数
uv -= tex2D(_HightMap, uv)*TV.xy*_ParallaxHeight;     //V向量为切空间下的向量
</code></pre>
<p>在高度图变化比较剧烈的地方，采用这种方法会有很对问题；因此又发展出了Steep Parallax Mapping（陡峭视差贴图）；</p>
<h2 id="steep-parallax-mapping">Steep Parallax Mapping</h2>
<p>对于高度变化剧烈地方，其实很难通过一步就定位到偏移后的位置，陡峭视差贴图方法实际上就是ray matching方法，使用此方法可以更精确的定位到偏移后位置；但由于ray matching算法的性质，在计算量不足的情况下，容易出现分层的痕迹；针对分层问题，后面提出了Parallax Occlusion Mapping(视差遮蔽映射)方法；</p>
<p>该算法首先将深度值进行分层，每一步递进一层；若当前步所获取深度值与步进深度值的差值的符号，与前一步相反，则可定位当前层深度即为偏移深度；分层数量越多，计算量越大，计算结果越精细；</p>
<pre><code class="language-C++">float numLayers = 10;
float depthStep = 1.0 / numLayers;
float currentDepth = 0.0;
float2 uvStep = TV.xy * _ParallaxHeight/ numLayers; 
float currentDepthMapValue = tex2D(_DepthTex, uv).r;

for(int i = 0; i&lt; 10; i++)
{
    if(currentDepth &gt; currentDepthMapValue)
        break;
    uv -= uvStep;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    currentDepth += depthStep;  
}
</code></pre>
<h2 id="parallax-occlusion-mapping">Parallax Occlusion Mapping</h2>
<p>视差遮蔽贴图与陡峭视差贴图类似，区别仅在于最后深度的选择；陡峭视差贴图最终的深度为步进深度的倍数，并且最终深度大于此位置的采样深度，而前一步的深度小于前一步位置的采样深度；针对此现象，我们可以在两者之间进行深度插值，这样最终采样深度就是一个连续的分布了；</p>
<p>插值的根本原理就是相似三角形原理；代码如下，示意图请看参考引用；</p>
<pre><code class="language-C++">float numLayers = 10;
float depthStep = 1.0 / numLayers;
float currentDepth = 0.0;
float2 uvStep = TV.xy * _ParallaxHeight/ numLayers; 
float currentDepthMapValue = tex2D(_DepthTex, uv).r;

float preDiff = 1e-5;       //防止除0
for(int i = 0; i&lt; 10; i++)
{
    if(currentDepth &gt;= currentDepthMapValue)
    {
        float curDiff = currentDepth-currentDepthMapValue;
        uv -= uvStep*preDiff/(curDiff+preDiff);
        break;
    }
    else
        preDiff = currentDepthMapValue - currentDepth;
    uv -= uvStep;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    currentDepth += depthStep; 
}
</code></pre>
<h2 id="relief-mapping">Relief Mapping</h2>
<p>视差遮蔽贴图在最后的一步采用插值进行计算，本质上是采用线性分布模拟步进深度中的非线性深度分布；因此最好的方法就是采用更细的步进深度进行测试，但这样就要求需要有大量的步进运算；因此可采用二分法方法来进行步进，这样可以更快定位到相交的深度；但是二分法要求单调性，实际的深度分布不可能是但单调分布的，因此最佳的步进方法为，先进行大步进深度的传统线性步进，再进行二分步进，这就是Relief Mapping的中心思想；</p>
<pre><code class="language-C++">//linear rematching
float numLayers = 10;
float depthStep = 1.0 / numLayers;
float currentDepth = 0.0;
float2 uvStep = TV.xy * _ParallaxHeight/ numLayers; 
float currentDepthMapValue = tex2D(_DepthTex, uv).r;

for(int i = 0; i&lt; 10; i++)
{
    if(currentDepth &gt; currentDepthMapValue)
    {
        break;
    }
    uv -= uvStep;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    currentDepth += depthStep;  
}

//binary rematching
for(int i = 0; i&lt; 8; i++)
{
    uvStep *= 0.5;
    depthStep *= 0.5;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    if(currentDepth &lt; currentDepthMapValue)
    {
        uv -= uvStep;
        currentDepth += depthStep;
    }
    else
    {
        uv += uvStep;
        currentDepth -= depthStep;
    }
}
</code></pre>
<p>实际上，深度图的使用原理，与地形及其类似；确定好视线与深度相交点后，就可以沿光源方向进行阴影计算，<a href="https://shintaroiguchidotcom.files.wordpress.com/2016/01/relief-mapping-in-a-pixel-shader-using-binary-search.pdf">PDF：Relief Mapping</a>这篇文章也提到了使用深度图进行自投影的计算；</p>
<p>关于使用raymatching方法进行地形的渲染，可以参考<a href="https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm">iq：raymarching terrains</a>，读完后相应对于视差贴图的理解可以更深一步；</p>
<h2 id="个人思考">个人思考</h2>
<p>从结果上来看，确实算法越来越精确了，但是都要有一个严重的问题：如下图所示：<br>
<img src="https://wingstone.github.io/post-images/1601477127814.jpg" alt="实际运行图片" loading="lazy"><br>
可以看出，在视差起作用的边界处，出现了明显的锯齿，感觉如何解决这个要命的问题才是当下需要着重研究的；</p>
<h2 id="参考">参考</h2>
<p><a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">learnopengl：Parallax-Mapping</a><br>
<a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/">learnopengl中文版：Parallax-Mapping</a><br>
<a href="https://shintaroiguchidotcom.files.wordpress.com/2016/01/relief-mapping-in-a-pixel-shader-using-binary-search.pdf">PDF：Relief Mapping</a><br>
<a href="https://en.wikipedia.org/wiki/Parallax_mapping">Wiki：Parallax mapping</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NPR之描边]]></title>
        <id>https://wingstone.github.io/post/npr-zhi-miao-bian/</id>
        <link href="https://wingstone.github.io/post/npr-zhi-miao-bian/">
        </link>
        <updated>2020-09-28T07:49:37.000Z</updated>
        <content type="html"><![CDATA[<p>对于非平滑模型，采用背部扩展描边的方式，容易出现断裂问题；</p>
<p>解决方法为：背面的扩展法线要使用法线贴图计算后的法线，这样能得到高模下的法线分布，而高模法线是平滑分布的；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[皮肤渲染方法总结]]></title>
        <id>https://wingstone.github.io/post/pi-fu-xuan-ran-fang-fa-zong-jie/</id>
        <link href="https://wingstone.github.io/post/pi-fu-xuan-ran-fang-fa-zong-jie/">
        </link>
        <updated>2020-09-28T06:45:56.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering">gpugems1：wrap方法，模拟透射，纹理空间blur</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin">gpugems3：不同的Specular BRDF，改善模拟透射，纹理空间 Diffusion，屏幕空间Diffusion</a></li>
<li><a href="https://www.slideshare.net/leegoonz/penner-preintegrated-skin-rendering-siggraph-2011-advances-in-realtime-rendering-course">siggraph2011：pre-integrated skin rendering</a></li>
<li>GPU Pro 2, Part 2. Rendering, Chapter 1. Pre-Intergrated Skin Shading</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[皮肤渲染——Preintegrated Subsurface Scattering]]></title>
        <id>https://wingstone.github.io/post/pi-fu-xuan-ran-zhi-preintegrated-subsurface-scattering/</id>
        <link href="https://wingstone.github.io/post/pi-fu-xuan-ran-zhi-preintegrated-subsurface-scattering/">
        </link>
        <updated>2020-09-28T04:18:24.000Z</updated>
        <content type="html"><![CDATA[<p>预积分皮肤散射主要解决三种皮肤散射情况：</p>
<ol>
<li>表面弯曲引起的散射（Surface Curvature）；</li>
<li>表面小凸起引起的散射（Small Surface Bumps）；</li>
<li>投影边缘引起的散射（Shadows）；</li>
<li>皮肤背面的透射问题（Translucency）（自己添加的）；</li>
</ol>
<h2 id="surface-curvature">Surface Curvature</h2>
<p>单纯的wrap并不符合物理，需要通过diffusion profile积分才能获取正确的wrap；<br>
预积分贴图是在球形假设下进行计算的，因此该方法最大的缺陷是模拟表面拓扑复杂的结构时，有很大不合理之处；<br>
幸运的是，当今模型表面大都是平滑的，而不平滑的小的部分都用法线贴图进行假设计算；<br>
积分方程为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>θ</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo><mo>=</mo><mfrac><mrow><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mrow><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msubsup><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>+</mo><mi>x</mi><mo>)</mo><mo>∗</mo><mi>R</mi><mo>(</mo><mn>2</mn><mi>r</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>x</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>)</mo></mrow><mtext> </mtext><mi mathvariant="normal">d</mi><mi>x</mi></mrow><mrow><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mrow><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msubsup><mrow><mi>R</mi><mo>(</mo><mn>2</mn><mi>r</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>x</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>)</mo></mrow><mtext> </mtext><mi mathvariant="normal">d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">D(\theta, r) = \frac{\int_{-\pi/2}^{\pi/2} {cos(\theta+x)*R(2rsin(x/2))} \,{\rm d}x}{\int_{-\pi/2}^{\pi/2} {R(2rsin(x/2))} \,{\rm d}x} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.50744em;vertical-align:-1.50372em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.00372em;"><span style="top:-2.1100000000000003em;"><span class="pstrut" style="height:3.0829em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3441799999999997em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5308200000000001em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">x</span></span></span><span style="top:-3.3129em;"><span class="pstrut" style="height:3.0829em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.00372em;"><span class="pstrut" style="height:3.0829em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3441799999999997em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5308200000000001em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.50372em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>式中R(d)表示Diffusion profile，表示相应距离下的辐射度，d表示距离。该式表示在曲率半径为r的半球下，对应<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>角度下，其它所有角度在该角度下的散射强度；对应模型如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://wingstone.github.io/post-images/1601282044664.jpg" alt="Diffusion profile，Integrated model" loading="lazy"></figure>
<p>**图中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>应该全部用x来表示！**从图中的右侧的模型能够看出，N为我们要求的散射角度，L与N之间的角度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>，L在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">N+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>处的光照强度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>+</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">cos(\theta+x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>；N距N+x的距离为2rsin(x/2)，即弦长；N+x在N处的散射可由R(d)计算得出；</p>
<p>图中的Diffusion profile一般使用高斯核叠加进行表示，对于rgb各成分的高斯核表示为：<br>
<img src="https://wingstone.github.io/post-images/1601282423542.jpg" alt="A Sum-of-Gaussians Fit for Skin" loading="lazy"></p>
<p>最终得到一个Diffusion profile在不同<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>角度和曲率半径下的积分分布；将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>角度和曲率半径转换为NdoL和1/r，即可得到常用的预积分贴图；如下图所示：<br>
<img src="https://wingstone.github.io/post-images/1601283515546.jpg" alt="曲率，预积分贴图" loading="lazy"></p>
<p>其中曲率的求法可在shader中借助偏导函数计算，即：</p>
<pre><code class="language-C++">float3 dn = fwidth(N);
float3 dp = fwidth(P);

float c = length(dn)/length(dp);
</code></pre>
<h2 id="small-surface-bumps">Small Surface Bumps</h2>
<p>对于小的凸起以及皱纹，不能使用预积分来进行计算，但是由于可以多采样，因此可以使用预滤波的方式处理法线贴图；</p>
<p>对于specular使用正常的normalmap，对于diffuse的rgb分别使用针对不同Diffusion profile处理后的normalmap，因此需要4张normalmap；</p>
<p>为了效率考虑，可以使用一种高精度无滤波的normalmap，一张低精度预滤波的normalmap分别针对rgb插值来近似相应的预滤波处理；需要2张normalmap；</p>
<p>可以将低精度无滤波的normalmap省略，直接使用模型法线来代替，这样就可以指使用一张高精度无滤波的normalmap进行处理了；</p>
<p>最终的结果为：进行滤波处理的通道，其法线凹凸变弱，反应在视觉上，就是凹凸处该通道有相应的溢出（根本原因是此通道趋于恒定，而其他通道凹凸变换大）；</p>
<h2 id="shadows-scattering">Shadows Scattering</h2>
<p>皮肤出的散射特性在投影边缘会体现出来，具体模拟此现象是很困难的一件事情，但是我们可以通过一些trick来实现；</p>
<p>首先，阴影强度为0或1，表示被遮挡，或不被遮挡；位于两者之间的值，及表示半影区域，及发生散射的区域（前提是使用软阴影）；因此我们可以针对这一点，利用Diffusion profile进行积分，来得到阴影值与散射强度的关系；</p>
<p>积分的过程是针对位置进行积分，需要将阴影值映射到位置上后才能积分，针对不同的软阴影方法，映射函数是不同的；我们用P()表示阴影值与到blur kernel距离的函数，则此映射为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>p</mi><mo>−</mo></msup><mn>1</mn><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">p^-{1}()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">1</span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>；具体的积分方程为：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;^&#039; at position 45: …ty}^{\infty} {P^̲&#039;(P^{-1}(s)+x)R…'>P_S(s,w)  = \frac{\int_{-\infty}^{\infty} {P^&#039;(P^{-1}(s)+x)R(x/w)} \,{\rm d}x}{\int_{-\infty}^{\infty} {R(x/w)} \,{\rm d}x} 
</p>
<p>针对box blur软阴影（PCF）方法，其过程如下：<br>
<img src="https://wingstone.github.io/post-images/1601347525242.jpg" alt="投影预积分" loading="lazy"></p>
<p>需要注意的是，半影区域的一部分（宽度到没提及）作为正常的软阴影计算插值，剩下的一部分作为这些软阴影散射产生的影响；P'()即表示新的半影函数分布；</p>
<p>最终得到一张投影的预积分图；其散射强度为阴影值s、以及半影宽度w（世界空间）的函数；</p>
<h2 id="translucency">Translucency</h2>
<p>关于背面透射问题，可以借助light空间的depth map来大约计算光线在物体所穿过的距离；使用depth map对于非凸物体会产生一些不正确现象，但是还能够接受；</p>
<p>使用depth map需要重新渲染一张深度图，直接使用shadowmap其实也可以，但对于某些管线并不能很好的结合在一起，因此，一般使用一张表示物体的厚度贴图来作为光线穿过距离；</p>
<p>使用指数函数来处理距离，典型的使用<code>exp(-depth * sigma_t)</code>即可，这里sigma_t表示物体的透射系数；</p>
<p>额外需要处理的问题包括：</p>
<ol>
<li>光照的正面会得到穿过距离为0的问题，需要使用ndl进行处理，不能只是用ndl的sign值，否则会产生锯齿，不能产生平滑结果；</li>
<li>同理只有视角背向光源时，才能产生透射现象，需要使用vdl进行处理；</li>
</ol>
<p>最终的渲染结果为：<br>
<img src="https://wingstone.github.io/post-images/1601388479937.jpg" alt="预积分渲染结果" loading="lazy"></p>
<h2 id="问题及展望">问题及展望</h2>
<ol>
<li>曲率在PS中计算的话，在三角形边缘会出现异常；</li>
<li>三张normal map贴图问题；</li>
<li>对几何拓扑做出了大量的假设；</li>
</ol>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://www.slideshare.net/leegoonz/penner-preintegrated-skin-rendering-siggraph-2011-advances-in-realtime-rendering-course">Penner pre-integrated skin rendering (siggraph 2011 advances in real-time rendering course)</a>：PPT</li>
<li>GPU Pro 2, Part 2. Rendering, Chapter 1. Pre-Intergrated Skin Shading：Book</li>
<li><a href="http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html">Simon's Tech Blog</a>：使用数值插值代替预积分贴图</li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering">GPU Gems 1, Real-Time Approximations to Subsurface Scattering</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GPU编程之DDX、DDY详解]]></title>
        <id>https://wingstone.github.io/post/gpu-bian-cheng-zhi-ddxddy-xiang-jie/</id>
        <link href="https://wingstone.github.io/post/gpu-bian-cheng-zhi-ddxddy-xiang-jie/">
        </link>
        <updated>2020-09-21T08:18:43.000Z</updated>
        <content type="html"><![CDATA[<p>ddx、ddy函数的含义为返回大约目前变量的偏导数；</p>
<p>所谓偏导数，实际上就是分别在x方向和y方向的单位距离下，变量的差值；</p>
<p>在GPU中用数值进行计算的话，就是相邻像素下该变量的差值；</p>
<h2 id="使用细节">使用细节</h2>
<p>对于矢量变量，仍然返回一个矢量，但是矢量中的每个元素都会计算其偏导数；</p>
<p>该函数只能在fragment program profiles中使用，但是并不是所有的硬件都支持；</p>
<p>当该函数使用在条件分支语句中，ddx、ddy的偏导计算并不是完全正确的，因为并不是所有的fragment都运行在同一个分支中；</p>
<p>当变量所依据的参数是基于中心插值的情况下，偏导计算并不是非常精确；</p>
<h2 id="实现细节">实现细节</h2>
<p>其偏导数的实现方式要依据具体的实现方式；典型的实现方式为fragment被光栅化时，会以为2x2的形式形成像素块（称作quad-fragments），偏导计算就在quad-fragments中相邻的fragment中进行差值计算；这是像素着色器上面的最小工作单元 ，在像素着色器中，会将相邻的四个像素作为不可分隔的一组，送入同一个SM内4个不同的Core。</p>
<p><a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_shader_thread_group.txt">NV shader thread group</a>提供了OpenGL的扩展，可以查询GPU线程、Core、SM、Warp等硬件相关的属性。在处理2x2的像素块时，那些未被图元覆盖的像素着色器线程将被标记为<code>gl_HelperThreadNV = true</code>，它们的结果将被忽略，也不会被存储，但仍然进行着色器的计算，可辅助一些计算，如导数<code>ddx</code>和<code>ddy</code>。</p>
<p>原文：</p>
<blockquote>
<p>The variable gl_HelperThreadNV specifies if the current thread is a helper thread. In implementations supporting this extension, fragment shader invocations may be arranged in SIMD thread groups of 2x2 fragments called &quot;quad&quot;. When a fragment shader instruction is executed on a quad, it's possible that some fragments within the quad will execute the instruction even if they are not covered by the primitive. Those threads are called helper threads. Their outputs will be discarded and they will not execute global store functions, but the intermediate values they compute can still be used by thread group sharing functions or by fragment derivative functions like dFdx and dFdy.</p>
</blockquote>
<h2 id="reference">Reference</h2>
<p><a href="https://developer.download.nvidia.cn/cg/ddx.html">cg-ddx</a><br>
<a href="https://www.cnblogs.com/timlly/p/11471507.html#436-%E5%83%8F%E7%B4%A0%E5%9D%97%EF%BC%88pixel-quad%EF%BC%89">深入GPU硬件架构及运行机制</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动GPU架构]]></title>
        <id>https://wingstone.github.io/post/yi-dong-gpu-jia-gou/</id>
        <link href="https://wingstone.github.io/post/yi-dong-gpu-jia-gou/">
        </link>
        <updated>2020-09-17T05:30:09.000Z</updated>
        <content type="html"><![CDATA[<p>移动GPU架构经常被称之为TBDR（Tiled Based Deferred Rendering），我们这里也以TBDR代称；实际上移动架构有TBR与TBDR两种，为什么都被称之为TBDR，可以看这篇<a href="https://zhuanlan.zhihu.com/p/112120206">文章</a>；我们这里使用TBDR来指整个移动GPU架构都包含的TBR特点；</p>
<h2 id="移动tbdr架构与桌面imr架构">移动TBDR架构与桌面IMR架构</h2>
<h3 id="imr架构">IMR架构</h3>
<p>IMR（Immediate Mode Rendering）就如字面意思一样，提交的每个渲染命令都会立即开始执行，并且该渲染命令会在整条流水线中执行完毕后才开始执行下一个渲染命令。</p>
<p>IMR的渲染会存在浪费带宽的情况。例如，当两次渲染有前后遮蔽关系时，IMR模式因为两次draw命令都要执行，因此会存在经过Pixel Shader后的Pixel被Depth test抛弃，这样就浪费了Shader Unit运算能力。不过幸运的是，目前几乎所有的IMR架构的GPU都会提供Early Z的判断方式，一般是在Rasterizer里面对图形的遮蔽关系进行判断，如果需要渲染的图形被遮挡住，那么就直接抛弃该图形而不需要执行Pixel Shader。</p>
<p>IMR的另外一个缺点就是其渲染命令在执行需要随时读写frame buffer，depth buffer和stencil buffer，这带来大量的内存带宽消耗，在移动平台上面访问片外内存是最消耗电量和最耗时的操作。</p>
<h3 id="tbdr架构">TBDR架构</h3>
<p>移动端的硬件在设计最开始想到的最重要的问题就是功耗，功耗意味着发热量，意味着耗电量，意味着芯片大小…所以gpu也是把功耗摆在第一位，然而在gpu的渲染过程中，对功耗影响最大的是带宽；</p>
<p>每渲染一帧图像，对FrameBuffer的访问量是惊人的（各种test，blend，再算上MSAA, overdraw等等），通常gpu的onchip memory（也就是SRAM，或者L1 L2 cache）很小，这么大的FrameBuffer要存储在离gpu相对较远的DRAM（显存）上，可以把gpu想象成你家，SRAM想象成小区便利店，DRAM想象成市中心超市，从gpu对framebuffer的访问就相当于一辆货车大量的在你家和市中心之间往返运输，带宽和发热量之巨大是手机上无法接受的。</p>
<p><strong>TBDR一般的实现策略</strong>是对于cpu过来的commandbuffer，只对他们做vetex process，然后<strong>对vs产生的结果暂时保存</strong>，等待非得刷新整个FrameBuffer的时候，才真正的随这批绘制做光栅化，做tile-based-rendering。什么是非得刷新整个FrameBuffer的时候？比如Swap Back and Front Buffer，glflush，glfinish，glreadpixels，glcopytexiamge，glbitframebuffer，queryingocclusion，unbind the framebuffer。总之是所有gpu觉得不得不把这块FrameData绘制好的时候。</p>
<p>FrameData这个是tbr特有的在gpu绘制时所需的存储数据，在powervr上叫做arguments buffer，在arm上叫做plolygon lists。</p>
<p>于是移动端的gpu想到了一种化整为零的方法，把巨大的FrameBuffer分解成很多小块，使得每个小块可以被离gpu更近的那个SRAM可以容纳，块的多少取决于你的硬件的SRAM的大小。这样gpu可以分批的一块块的在SRAM上访问framebuffer，一整块都访问好了后整体转移回DRAM上。</p>
<h3 id="对比">对比</h3>
<p>那么为什么pc不使用tbr，这是因为实际上直接对DRAM上进行读写的速度是最快的，tbdr需要一块块的绘制然后回拷，可以说如果哪一天手机上可以解决带宽产生的功耗问题，或者说sram可以做的足够大了，那么就没有TBDR什么事了。可以简单的认为TBR牺牲了执行效率，但是换来了相对更难解决的带宽功耗。</p>
<h2 id="tbdr的重要特性">TBDR的重要特性</h2>
<h3 id="关于early-z">关于early-z</h3>
<p>因为tbdr有framedata队列，很多gpu会很聪明的尽量筛去不需要绘制的framedata。所以在tbdr上earlyz，或者stencil test这些是非常有益处的。例如你定义了一个stencil，gpu有可能在对framedata处理的过程中就筛掉了那些不能通过stencil的drawcall了。或者通过scissor test可能一整块tile都不需要绘制。</p>
<h3 id="blending和msaa的效率其实很高alpha-test效率很低">blending和MSAA的效率其实很高，alpha-test效率很低</h3>
<p>回头看下tbdr的渲染管线，对于一个tile上所有pixel的绘制都是在on-chip的mem上的，只在最后绘制好了才整体回拷给dram。所以我们通常认为会造成大量带宽的操作，例如blending（对framebuffer的读和写），msaa(增加对framebuffer读取的次数)其实在tbdr上反而是非常快速的。（当然msaa除了会造成framebuffer访问增多，还会带来渲染像素的数量增多，这个是tbr没什么优化的）</p>
<p>alpha-test这个东西，他对depth的写入是不能预先确定的，它必须等到pixel shader执行，这导致了alpha-test之后的那些framedata失去了early–z的机会，也就破坏了TBDR架构中的延迟渲染特性（FrameData必须进行ps处理，不能继续缓存），也就增加了渲染量。</p>
<h2 id="移动tbdr架构与render-pipeline中tbdr的区别">移动TBDR架构与Render Pipeline中TBDR的区别</h2>
<p>Render Pipeline中TBDR可以参考<a href="xuan-ran-guan-xian">这里</a>；RP中的TBDR指的光照渲染流程中，延迟光照的一种；为了减少DC，提高硬件利用效率；<strong>这里的延迟主要指</strong>：PS阶段光照的计算不立即计算，而是渲染到G-buffer中进行缓存，到最后使用的新的DC来使用G-buffer进行光照的计算（主要用于多光源下的渲染处理）；</p>
<p>移动TBDR架构指的是GPU所采用的的一种渲染架构，是GPU硬件上的延迟渲染流程的硬件实现；而且<strong>这里的延迟渲染主要指</strong>：VS到PS之间有一个硬件的framedata队列，来延迟PS的处理；</p>
<h2 id="reference">Reference</h2>
<p><a href="https://gameinstitute.qq.com/community/detail/103959">移动架构浅析</a><br>
<a href="https://zhuanlan.zhihu.com/p/112120206">移动设备GPU架构知识汇总</a><br>
<a href="https://gameinstitute.qq.com/community/detail/123220">针对移动端TBDR架构GPU特性的渲染优化</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[零散学习资源链接]]></title>
        <id>https://wingstone.github.io/post/ling-san-zi-yuan-lian-jie-ji-lu/</id>
        <link href="https://wingstone.github.io/post/ling-san-zi-yuan-lian-jie-ji-lu/">
        </link>
        <updated>2020-09-16T05:23:05.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/mrdoob/three.js/issues/10600">半透投影问题</a></p>
<p><a href="https://github.com/gkjohnson/unity-dithered-transparency-shader">dithered transparency / Screen-door transparency（扰动半透渲染技术）</a></p>
<p><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows">点光源的投影问题</a><br>
<a href="https://www.slideshare.net/stefan_b/shadow-techniques-for-realtime-and-interactive-applications">shadow techniques for realtime and interactive applications</a><br>
<a href="http://www.gamedevelop.eu/Tutorials/Dual-Paraboloid-Shadow-Mapping.htm">Dual Paraboloid Shadow Mapping</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[头发渲染——Kajiya model]]></title>
        <id>https://wingstone.github.io/post/tou-fa-xuan-ran-zhi-kajiya-model/</id>
        <link href="https://wingstone.github.io/post/tou-fa-xuan-ran-zhi-kajiya-model/">
        </link>
        <updated>2020-09-16T04:19:32.000Z</updated>
        <content type="html"><![CDATA[<p>关键点：采用多边形建模，进行深度排序修正渲染顺序（因为半透问题），AO去模拟自阴影，两层高光，采用Tangent向量代替N进行高光计算；</p>
<h2 id="采用多边形建模">采用多边形建模</h2>
<p>头发建模可分为发丝建模（关于发丝建模的渲染看<a href="https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-23-hair-animation-and-rendering-nalu-demo">这里</a>）与多边形建模两种，当今游戏界所大量采用的做法也是多边形建模；</p>
<ol>
<li>多边形建模有更低的几何复杂性，以至于有更高的排序效率；相比之下采用发丝建模需要大约100K-150K的发丝来构建，复杂度高很多；</li>
<li>采用多边形建模可以更加容易的集成到已有的渲染管线中去，基本已有的渲染管线都是处理的多边形模型；</li>
</ol>
<h2 id="高光计算">高光计算</h2>
<p>主要的高光计算都集成在下面这张PPT上；<br>
<img src="https://wingstone.github.io/post-images/1600411957731.jpg" alt="" loading="lazy"><br>
可以看出，kajiya计算模型与blin-phong模型比较类似，<strong>本质上都是采用pow(NdotH, specularity)来进行的高光计算</strong>；但是<strong>kajiya模型没有使用多边形几何的法线来作为法线计算，而是采用法线平面的概念来作为法线的代替计算</strong>；</p>
<blockquote>
<p>虽然几何是多边形，但是仍然将其作为发丝来看待，Tangent向量作为发丝的方向；而发丝的法线应该位于与发丝垂直的平面上，且发丝与此平面的交点作为法线的起点；</p>
</blockquote>
<p>法线平面即红色平面所显示的，法线平面中真正的法线，有T向量、H向量所决定的平面，与法线平面的交线来决定，我们将这里决定出来的法线用N1（区别于真正的多边形几何法线）来代替；由于T、H、N1都是单位向量，由几何关系可以得到<strong>N1dotH = sin(T,H)</strong>，到此，我们就可以使用T、H来进行高光计算了；</p>
<h2 id="模拟真正的头发高光">模拟真正的头发高光</h2>
<p>为了模拟头发真正的高光，还要基于对头发高光的观察进行部分假设，相应的观察假设在这张PPT上；<br>
<img src="https://wingstone.github.io/post-images/1600413042532.jpg" alt="" loading="lazy"></p>
<ol>
<li>头发有两层高光；</li>
<li>主高光切变流向朝向发梢；</li>
<li>次高光拥有头发的颜色，且切变流向发根；</li>
<li>次高光带有闪烁效果，即不是很连续；</li>
</ol>
<p>模拟两层高光比较简单，只需要计算两次高光即可；</p>
<p>如何模拟高光的切变流向，即一个位置偏向发梢，一个偏向发根；因为我们使用模型的T来计算的高光，要想改变高光位置，只能从T下手；AMD提供的方法为，使用N（这里是多边形几何的法线，不是法线平面中的法线N1）对T进行偏移；偏移量可以从贴图中进行采样，计算公式如下：</p>
<pre><code class="language-C++">float ShiftTangent(float3 T, float3 N, float shift)
{
    float3 shiftedT = T + shift * N;
    return normalize(shiftedT);
}
</code></pre>
<p>如下图：T'与T''是切变后的切向量；<br>
<img src="https://wingstone.github.io/post-images/1600414455694.jpg" alt="" loading="lazy"></p>
<p>T表示发丝的方向，那么当发丝方向发生变化时，N（多边形对应法线）自然而然也同样产生变化，偏移后的N为：</p>
<pre><code class="language-C++">float3 B = cross(N, T);
N = cross(T, B);
</code></pre>
<blockquote>
<p>实质上，N对T的偏移，是模拟头发的起伏，即发丝方向突出多边形平面或凹陷多边形平面；</p>
</blockquote>
<p>次高光的闪烁效果模拟比较简单，只需要使用一个噪音纹理与次高光相乘即可；</p>
<h2 id="渲染排序问题">渲染排序问题</h2>
<p>由于头发具有半透效果，必须依据一定的顺序进行渲染才能得到正确的Blend效果；</p>
<h3 id="模型内部排序">模型内部排序</h3>
<p>由于模型是一簇一簇的，因为只要决定簇之间的排序即可；依据视线观看头发的顺序，可以依照发簇距离头皮的距离进行排序；让靠近头皮的发簇对应的Index buffer排在整个模型Index buffer的前面；这样模型内部的渲染顺序就完全正确了；</p>
<blockquote>
<p>修改Index buffer的顺序，可以由模型制作时合并的顺序来决定；也可以由程序进行单独处理；</p>
</blockquote>
<h3 id="渲染时的pass设置">渲染时的pass设置</h3>
<p>虽然使用模型内部排序就能解决发簇之间的渲染顺序问题，但是对于发簇内部的渲染顺序也需要控制，不然会会出现先绘制发簇前面，再绘制背面的问题；有时也会出现先看到靠近头皮的发簇，再看到远离头皮的发簇的情况，特别是针对女性的头发；</p>
<p>因此为了解决这些问题，需要引入多pass渲染来解决，如下图所示：<br>
<img src="https://wingstone.github.io/post-images/1600416013592.jpg" alt="" loading="lazy"></p>
<p>Pass1：开启深度测试为Less并写入，开启alpha test，cull back；<br>
Pass2：关闭深度写入，深度测试为Less，关闭alpha test，cull front；<br>
Pass2：开启深度深度测试为Less并写入，关闭alpha test，cull back；</p>
<h2 id="使用方案">使用方案</h2>
<ol>
<li>纹理需求：base tex（发色纹理，包含Scretched noise）、alpha tex（需包含全不透区域）、tangent shift tex（模拟头发起伏形状）、specular noise tex（用于第二层高光sparkling）</li>
<li>模型需求：多边形建模，面片之间具有层次，且按照距表皮的距离进行排序合并；</li>
</ol>
<blockquote>
<p>碎碎念：没想到Kajiya模型竟然还中了2004年SIGGRAPH，牛批牛批！</p>
</blockquote>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://developer.amd.com/wordpress/media/2012/10/Scheuermann_HairSketchSlides.pdf">Practical Real-Time Hair Rendering and Shading</a></li>
<li><a href="http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf">Hair Rendering and Shading</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[皮肤渲染——Screen Space Separable Subsurface Scattering]]></title>
        <id>https://wingstone.github.io/post/pi-fu-xuan-ran-zhi-screen-space-separable-subsurface-scattering/</id>
        <link href="https://wingstone.github.io/post/pi-fu-xuan-ran-zhi-screen-space-separable-subsurface-scattering/">
        </link>
        <updated>2020-09-16T03:31:29.000Z</updated>
        <content type="html"><![CDATA[<p>总体来说，渲染步骤为：</p>
<ol>
<li>首先对于不同的皮肤散射颜色，去计算相应的kernel（作为一维的颜色数组，存储该距离下次表面散射贡献），kernel是通过多层高斯曲线去拟合偶极子曲线得到的，因此需要多次高斯叠加计算；kernel的长度大小对应模糊的范围，也对应采样数的大小；</li>
<li>正常渲染皮肤，但要使用MRT，将diffuse成分与specular分离，并使用stencil进行标记；</li>
<li>在相机的BeforeImageEffectsOpaque时，进行皮肤部分的separable blur，并使用stencil test，保证只在皮肤部分进行blur；blur时要使用前面计算出来的kernel以及模型的曲率（借助深度的ddx、ddy计算），依据曲率来调整实际blur的范围；</li>
<li>将MRT进行合并，即blur后的diffuse部分与specular部分进行结合；</li>
</ol>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="http://iryoku.com/separable-sss/">Separable Subsurface Scattering</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin">Advanced Techniques for Realistic Real-Time Skin Rendering</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图形学学习资源推荐]]></title>
        <id>https://wingstone.github.io/post/tu-xing-xue-zi-yuan-tui-jian/</id>
        <link href="https://wingstone.github.io/post/tu-xing-xue-zi-yuan-tui-jian/">
        </link>
        <updated>2020-09-15T08:10:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="离线渲染">离线渲染</h2>
<ol>
<li><a href="https://www.pbrt.org/index.html">Physically Based Rendering:From Theory To Implementation</a>：大名鼎鼎的《基于物理的渲染：从理论到实现》，离线学习必看，包含了各种光线追踪中用到的技术！官网还提供了第三版书籍的<a href="http://www.pbr-book.org/">网页版</a>供免费看；</li>
</ol>
<h2 id="实时渲染">实时渲染</h2>
<ol>
<li><a href="http://www.realtimerendering.com/index.html">Real-Time Rendering</a>：实时渲染技术的圣经，涵盖了实时渲染技术的各个方面，建议购买实体书查看；最重要的是记得去官网逛逛，官网包含了大量实时渲染的资料；随着实时ray tracing的发展，官网甚至涵盖了大量ray tracing相关的资料；一级推荐！</li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/contributors">GPU Gems1-3部曲</a>：学习GPU编程必备系列，学习如何编写shader来实现各种实时渲染技术；</li>
<li><a href="http://advances.realtimerendering.com/">Advances in Real-Time Rendering in 3D Graphics and Games</a>：SIGGRAPH中的课程系列，介绍每一年中关于实时计算机图形学中的高级渲染技术；</li>
<li><a href="http://www.rastertek.com/tutindex.html">Raster Tek</a>：一个关于DirectX入门的学习资料，对于新手非常推荐；相比于龙书，这个更接近与实际引擎开发，多个渲染功能都集成到一起；</li>
<li><a href="http://www.d3dcoder.net/">d3dcoder</a>：这是龙书系列的官方网站，含有从DirectX9到DirectX12的教程源代码。</li>
<li><a href="https://learnopengl.com/">learnopengl</a>：OpenGL的入门教程，必读！</li>
</ol>
]]></content>
    </entry>
</feed>