<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wingstone.github.io</id>
    <title>CG黑魔法作坊</title>
    <updated>2021-09-15T15:41:59.521Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wingstone.github.io"/>
    <link rel="self" href="https://wingstone.github.io/atom.xml"/>
    <subtitle>分享与记录关于CG技术的一切</subtitle>
    <logo>https://wingstone.github.io/images/avatar.png</logo>
    <icon>https://wingstone.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, CG黑魔法作坊</rights>
    <entry>
        <title type="html"><![CDATA[[Light and Color] Color Space]]></title>
        <id>https://wingstone.github.io/post/light-and-color-color-space/</id>
        <link href="https://wingstone.github.io/post/light-and-color-color-space/">
        </link>
        <updated>2021-06-26T15:14:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="color-space">Color Space</h1>
<h2 id="physical-basis-of-color颜色的物理基础">Physical Basis of Color（颜色的物理基础）</h2>
<p>说道颜色，首先得从光说起，因为光具有真实的物理属性；</p>
<ul>
<li>光是由不同波长的光照成分组成的，人眼能看到的光的范围称之为可见光谱；</li>
<li>Spectral Power Distribution (SPD)为谱功率密度，表示一束光在不同波长下的功率分布；常用来测量真实的光；</li>
<li>SPD具有线性叠加性；</li>
</ul>
<p>说完光，再来说颜色，颜色是光在人眼感知下的结果；并不是光的通用属性，与人眼具有强关联性；</p>
<h2 id="biological-basis-of-color颜色的生物基础">Biological Basis of Color（颜色的生物基础）</h2>
<p>人眼球中分布着Rods cell（杆状细胞，用来识别亮度），Cone cells（锥状细胞，用来识别颜色）；<br>
锥状细胞分为三种类型：S、M以及L，三种细胞对于不同波长的光，具有不同的反映峰值，各拥有各的spectral response curve；</p>
<h2 id="tristimulus-theory-of-color颜色的三色理论">Tristimulus Theory of Color（颜色的三色理论）</h2>
<p>前面已知不同锥状细胞具有不同的反映曲线，人的大脑处理的实际上是三种锥状细胞处理后输出的信号；即输入SPD与三种Response Function积分后得到的三个分量（S,M,L）；</p>
<h2 id="luminosity-function亮度函数">Luminosity Function（亮度函数）</h2>
<p>锥状细胞感受颜色，杆状细胞感受强度；同样不同的波长，杆状细胞感受出来的强度是不同的，感官亮度可以表示为Luminosity Function亮度随波长变化的函数；</p>
<h3 id="metamerism同色异谱">Metamerism（同色异谱）</h3>
<p>由于是积分产生的结果，那么不同的输入积分后就有可能产生同样的结果；即人眼看到的同样的颜色，可能是由不同的SPD产生；</p>
<h2 id="color-reproduction-matching颜色匹配">Color Reproduction / Matching（颜色匹配）</h2>
<p>同色异谱机制使得颜色匹配得以进行；Color Matching首先指定三盏光（每盏拥有固定SPD），调整三盏光的强度，使得混合后的颜色能匹配制定测试光，三盏光得到的强度由RGB组成，即为测试光光强；<br>
有时Color Matching的测试光需要进行补光，此时获取的RGB值可为负值；</p>
<h3 id="cie-rgb-color-matching-experimentcie颜色匹配实验">CIE RGB Color Matching Experiment（CIE颜色匹配实验）</h3>
<p>CIE颜色匹配实验是CIE所推出的颜色匹配标准；</p>
<ul>
<li>CIE使用red=700nm, green=546.1nm, blue=435.8nm三种波长的纯色光来进行匹配；</li>
<li>对可见波长的纯色光进行匹配后，得到了三条颜色匹配曲线，称之为Color Matching Curves或Color Matching Function；</li>
<li>有了颜色匹配曲线后，对于任意的SPD，只需将其与三条曲线进行积分，即可得到CIE rgb值，该值所在的空间，称之为CIE RGB空间；</li>
</ul>
<h2 id="color-space颜色空间">Color Space（颜色空间）</h2>
<h3 id="lms-space">LMS Space</h3>
<p>此处LMS即为前面所说的眼睛内部的三种锥形细胞，以三种细胞的response curve作为积分曲线，积分后得到的颜色值位于LMS 空间；Unity中的白平衡既是在此空间下进行计算；</p>
<h3 id="cie-rgb-space">CIE RGB Space</h3>
<p>前面提到将SPD与CIE color matching curves进行积分后即可得到CIE RGB空间下的值；</p>
<h3 id="cie-xyz-space1931">CIE XYZ Space（1931）</h3>
<p>同样CIE RGB Space里的值会存在负值，由于匹配主光设定的限制；<br>
为了避免负值的不变，CIE将RGB color matching curves经过仿射变换为XYZ color matching curves，转换后的curves不含有负值，这样积分得到的值就不会存在负值；积分值所在的空间称之为CIE XYZ Space；</p>
<ul>
<li>XYZ空间使用的Color Matching Curves是经过精心设置的，其中的Y坐标的curve刚好为人眼的Luminosity Function（亮度函数），这样XYZ空间下的Y坐标刚好就代表着亮度；</li>
<li>与CIE RGB空间相比，RGB空间的三个轴（前面所提的单色光）具有实际的物理波长，而XYZ空间的三个轴并没有物理意义，也就没有实际的物理颜色与波长；</li>
</ul>
<h3 id="cie-luv-and-lab1976">CIE LUV and LAB（1976）</h3>
<p>CIE 1931 XYZ具有一个很大的缺点，就是其上的颜色并不是均匀显示的，即相同间隔的颜色，在色度图上所显示的距离最多能相差20倍；为了解决这个问题CIE LUV就被提了出来，其将XYZ重新进行变换，能将最大相差倍数缩小为4倍；</p>
<h3 id="xyy-space">xyY Space</h3>
<p>由于色度图（下个小标题介绍）的方便性，使用色度图中的xy可以很方便的表示颜色的色相，但却丢失了亮度，因此加上CIE XYZ空间中Y值即可重建原来的颜色；<br>
xyY也因为其方便性而经常使用，所以这里把xyY单独列出来；</p>
<h3 id="srgb">sRGB</h3>
<p>sRGB是如今实时渲染中使用最广泛的颜色空间，广泛使用在PC以及TV上；值得一提的是，sRGB与Rec. 709使用相同的Primaries lights以及白点，其中白点使用D65；</p>
<blockquote>
<p>注意：这里sRGB指的是linear light space，并不考虑Gamma等相关因素的下nonlinear color space；相关知识参考<a href="https://blog.csdn.net/candycat1992/article/details/46228771">这里</a>还有<a href="https://zhuanlan.zhihu.com/p/36581276">这里</a>;</p>
</blockquote>
<h3 id="logc">LogC</h3>
<p>Log Color Space是基于场景的编码颜色空间，我们经常使用的sRGB这种则是基于显示的编码颜色空间；不同的厂商有不同的Log编码方式，LogC是ARRI用来记录颜色的空间；参考<a href="https://www.rocketstock.com/blog/tips-for-log-color-space-compositing/">Understanding Log and Color Space In Compositing</a>以及<a href="https://www.arri.com/en/learn-help/learn-help-camera-system/camera-workflow/image-science/log-c">LogC</a>；<br>
LogC最大的优点是维持更多的动态范围信息，甚至是超过人眼所能感受的范围；由于其通过对数方式编码，存储范围远远大于一般的颜色编码方式；<br>
由于LogC特性，常在LogC空间下进行对比度的计算，对比度的计算可能会导致负数、以及远超1的数，这些都可以在LogC空间下进行保存，使用再从LogC空间解码到原来的空间即可；</p>
<h3 id="hsv">HSV</h3>
<p>H为色相（Hue）、S为饱和度（Saturation）、V为亮度（Value）；HSV也被称作为HSB（Brightness），它是RGB空间的非线性转换，并不是独立的颜色空间，因此没有RGB Primaries以及白点的定义<a href="https://psychology.wikia.org/wiki/HSV_color_space">参考这里</a>；</p>
<h3 id="aces">ACES</h3>
<p>ACES并不是一个单独的颜色空间，而是一个系统，包含了颜色空间的一整套系统；ACES的存在就是为了标准化整个颜色的工作流；其内部包含了各颜色空间到ACES空间的转换，ACES内部还定义了ACES2065-1颜色空间（常称为AP0），该空间包含了整个色度图的范围，采用D60作为white point；还定义了ACEScg颜色空间，该空间常作为compositing与cg所使用的空间（常称为AP1），虽不如AP0，但也涵盖了大量的色域，采用D60作为white point；另外还有一个ACEScc，ACEScc与ACEScg基本一致，除了其使用了log gamma的形式，常用在grading中；ACES最后还定义了ACES空间至屏幕显示空间的转换，常有RRT与ODT组成，RRT与ODT内部包含的内容比想象中的要复杂的多，不仅考虑了Gamm，tonemapping，还有很多其他的因素；</p>
<h2 id="cie-chromaticity-diagramcie色度图">CIE chromaticity diagram(CIE色度图)</h2>
<p>直接在CIE XYZ空间上工作有众多不便；常用的做法是将XYZ投影到x+y+z=1的平面；即将XYZ进行归一化得到xyz值，这样只需要记录xy值（范围为0-1），z值为1-x-y；xy值所在的空间被称之为CIE色度图（特指CIE 1931 xy chromaticity diagram）；</p>
<ul>
<li>色度图包含了人眼所能看到的所有颜色，当然不包括强度；</li>
<li>实时上在色度图上丢失的是亮度信息Y，而xy决定了所有的颜色；</li>
<li>色度图为马蹄形；马蹄形的边沿代表整个色谱，是单色（单一波长），马蹄内部的颜色是混合色；</li>
<li>white point位于色度图的中心某处，具体位置依靠于所使用的光源；</li>
<li>色度图还具有很多很好的性质，色相与饱和度也可以从色度图中找出，具体看一查看这里<a href="https://www.cg.tuwien.ac.at/research/theses/matkovic/node14.html">Colorimetry</a>；</li>
</ul>
<h2 id="gamut色域">Gamut(色域)</h2>
<p>色度图包含了了所有的颜色，色度图中任意三点（Color Primaries）所组成的三角形就是一个色域（由于色度图的形式，三点进行插值可以得到三角形内的所有颜色）；我们平时使用的sRGB就是其中的一个色域；</p>
<ul>
<li>色域只包含所能表示的颜色，不能表示颜色的强度；</li>
<li>由于色度图是CIE XYZ空间的投影，所以CIE RGB空间的色域也能在色度图中进行表示，CIE  RGB在色度图中所显示的色域同样也为一个三角形；</li>
<li>CIE XYZ是由CIE RGB转换而来的的，为了CIE RGB的色域在色度图中反而是三角形，会丢失一些颜色呢？就是因为CIE RGB包含了负数，这些负数在色度图中丢失了；参考这里<a href="https://computergraphics.stackexchange.com/questions/10114/why-is-there-a-difference-between-the-cie-xyz-colour-gamut-vs-cie-rgb/10159#10159?newreg=7627228e6b9c4129811bd19902710039">Why is there a difference between the CIE XYZ colour gamut vs CIE RGB</a>;</li>
<li>各个颜色空间都有自己的色域；</li>
</ul>
<h2 id="color-temperature色温">Color Temperature（色温）</h2>
<p>谈到色温就要谈到黑体辐射；黑体在物理上被认为是一种物质，它能吸收打到它身上所有的光线，同时会随着自身温度的变化，而释放出固定的光谱；</p>
<ul>
<li>Black Body是一个理想化的物理物体，之所以叫黑体，是以为它会吸收所有的光线；</li>
<li>由于对于黑体来说，温度与黑体所释放出来的光谱是固定的，我们常用色温来指定相应的光谱；</li>
<li>黑体辐射的光谱与自然光是非常相似的，因此常用色温来指定阳光的颜色；</li>
<li>色温有时也被用来指定白点，D65就是一个例子；</li>
</ul>
<h2 id="white-point白点">White Point（白点）</h2>
<p>白点，定义的为一个色度，定义了白色在primaries light下的比值，具有一系列颜色与强度无关；某个光照环境下的白点，定义为白色物体在该环境下的色度；</p>
<ul>
<li>最常用的是白点是D65，定义为色温为6500K下的daylight光照环境；</li>
</ul>
<h2 id="define-a-color-space定义一个颜色空间">Define a Color Space（定义一个颜色空间）</h2>
<p>前面所说，色域已经给出了一个颜色空间所能表示的所有颜色，唯独丢失了强度范围，primaries lights给我们提供了矢量的方向信息，却没有没有提供矢量的相对比例关系；white point这时就起到了这个作用，白点确定了primaries lights之间的比例关系，之后再将白点亮度（Y坐标）缩放到1，即可确定给定primaries lights下所有颜色；</p>
<ul>
<li>Three Primaries Lights；</li>
<li>White Point；</li>
</ul>
<h2 id="transfer-between-color-space转换颜色空间">Transfer Between Color Space（转换颜色空间）</h2>
<p>由于每个颜色空间的色域都在XYZ空间上进行了标定（由primaries lights来决定），同时颜色空间下的White Point也已经指定，这样有颜色空间转换到XYZ空间的矩阵就可以确定；<br>
该矩阵具体由White Point在色度图上的xy坐标，primaries lights的xy坐标计算得来；<br>
同理，另外一个颜色空间转换至XYZ空间下的矩阵也可以确定，以XYZ空间为媒介，就可以在不同的颜色空间中进行转换；</p>
<blockquote>
<p>注意：实际上真正的物理渲染应该使用SPD来进行光照的计算与积分，即入射光使用SPD，brdf使用Spectral Reflectance Curve（）SRC，两者的积分与使用RGB直接计算得到结果会存在差异；但多数情况下，这种差异可以忽略，特别是在实时渲染；<br>
正确的渲染过程应该是光照的整个积分与计算都是用SPD和SRC来进行，只在最后输出的时候才转换成RGB显示；</p>
</blockquote>
<div id="refer-anchor"></div>
<h2 id="references">References</h2>
<p>[1] <a href="http://poynton.ca/notes/colour_and_gamma/ColorFAQ.html">Color FAQ</a><br>
[2] <a href="https://www.cg.tuwien.ac.at/research/theses/matkovic/node14.html">Colorimetry</a><br>
[3] <a href="http://www.brucelindbloom.com/">brucelindbloom</a><br>
[4] <a href="https://www.richardlackey.com/choosing-video-color-space/">How to Choose the Right Video Color Space</a><br>
[5] <a href="https://www.richardlackey.com/what-is-a-video-color-space/">What Is A Video Color Space?</a><br>
[6] <a href="https://hg2dc.com/">hitchhikers guide to digital color</a><br>
[7] <a href="https://color2.psych.upenn.edu/brainard/papers/Brainard_Stockman_Colorimetry.pdf">COLORIMETRY</a><br>
[8] <a href="https://research.activision.com/publications/archives/hdr-in-call-of-duty">HDR in Call of Duty</a><br>
[9] <a href="http://www.cvrl.org/">Colour &amp; Vision Research laboratory</a><br>
[10] <a href="https://en.wikipedia.org/wiki/White_point">White Point</a><br>
[11] <a href="https://en.wikipedia.org/wiki/Black_body">Black Body</a><br>
[12] <a href="https://pomfort.com/article/an-in-depth-look-at-asc-cdl-based-color-controls/">AN IN-DEPTH LOOK AT ASC-CDL BASED COLOR CONTROLS</a><br>
[13] <a href="https://cinematiccolor.org/">Cinematic Color</a><br>
[14] <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.1/manual/Post-Processing-Lift-Gamma-Gain.html">Lift Gamma Gain</a><br>
[15] <a href="https://z-fx.nl/ColorspACES.pdf">ACES pdf</a><br>
[16] <a href="https://acescolorspace.com/">ACES Space</a><br>
[17] <a href="https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/">Color system</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Light and Color] Gamma]]></title>
        <id>https://wingstone.github.io/post/light-and-color-gamma/</id>
        <link href="https://wingstone.github.io/post/light-and-color-gamma/">
        </link>
        <updated>2021-06-26T13:11:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>在图形开发中，总绕不开的一个名词，Gamma，这里会对Gamma进行一个粗暴但是通俗的讲解；便于理清图形开发中理解Gamma的一切；</p>
<h1 id="一-gamma是什么">一、Gamma是什么？</h1>
<p>Gamma是什么，Gamma FAQ<a href="#refer-anchor"><sup>[1]</sup></a>中有解释：在传统的CRT显示器中，屏幕显示的Luminance与电压并不是成正比的关系，而是成一个幂次方的关系，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><msup><mi>V</mi><mi>γ</mi></msup></mrow><annotation encoding="application/x-tex">L = V^\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span></span></span>，其中的幂就是我们通说所说的Gamma；<br>
<img src="https://img-blog.csdnimg.cn/20210623234248419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="Gamma变换" width="256" height="256" loading="lazy"></p>
<center>显示器的Gamma变换</center>
<h1 id="二-gamma-correction">二、Gamma Correction</h1>
<h2 id="gamma-correction是什么">Gamma Correction是什么？</h2>
<p>由于显示器所显示的Luminance为正常展示场景亮度的gamma次方（我们称之为Gamma变换），为了使显示器亮度为正常的展示场景亮度，抵消显示器Gamma变换的影响，必须在显示器前对展示场景亮度做 <strong>Gamma变换的逆变换</strong> ，此逆变换我们称之为 <strong>Gamma Correction</strong> ；<br>
<img src="https://img-blog.csdnimg.cn/20210623234433372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="256" height="256" loading="lazy"></p>
<center>显示器的Gamma Correction</center>
<p>实际上场景所在的空间，我们常称之为线性空间，即 <strong>Linear Space</strong> ，对应着曲线y=x；经过 <strong>Gamma Correction过后的空间</strong> ，我们称之为Gamma空间，即 <strong>Gamma Space</strong> ，对应着曲线y=x的上半段；</p>
<p>Gamma Correction有时也称 <strong>Encode Gamma</strong> ，从Gamma空间转换到线性空间变换则称之为 <strong>Decode Gamma</strong> ；</p>
<h2 id="为什么需要gamma-correction">为什么需要Gamma Correction？</h2>
<p>上面已经说到，做Gamma Correction是为了让显示器显示正常的场景亮度，这就是要做Gamma Correction的做主要的原因；</p>
<p>实际上人眼看到现实场景就是线性的，要想让观众觉得显示器里的东西更接近现实，显示器就必须要显示为线性空间；</p>
<h2 id="关于gamma的巧合">关于Gamma的巧合</h2>
<p>实际上， <strong>人眼对亮度的感知也并不是线性的，巧合的是，人眼对亮度的感知曲线搞刚好是显示器Gamma变换的逆变换的曲线（与Gamma矫正类似）</strong><a href="#refer-anchor"><sup>[2]</sup></a> ；</p>
<p>这样导致的结果就是：假如没有Gamma Correction，显示器显示一段均匀变化的亮度，人眼感知到的亮度刚好也是均匀的；因为显示器先做了Gamma变换，人眼感知又做了Gamma逆变换，导致人眼感知到的是均匀的；如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210623231605422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="未做Gamma Correction的0-1渐变图" width="512" height="256" loading="lazy"></figure>
<center>未做Gamma Correction的0-1渐变图</center>
<p>如果我们做了Gamma Correction，这个时候虽然是显示器最终显示的是均匀变化的亮度，但是人眼的感受却是不均匀的；因为先做了Gamma Correction（Gamma逆变换），然后显示器做了Gamma变换，人眼感知又做了Gamma逆变换，导致人眼感知到的是Gamma逆变换后的；如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/2021062323311715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="512" height="256" loading="lazy"></p>
<center>做了Gamma Correction的0-1渐变图</center>
<p>做了Gamma Correction之后的渐变图就是人眼真正应该感知到的渐变图：暗部人眼感知到的亮度大于实际亮度，且相差比较大；亮部人眼感知到的亮度与实际亮度基本持平，且相差较小；</p>
<p>之所以人眼有这样的特征，是因为为了能够在夜晚中生存，暗部或被人眼感知上提亮，这样就能够避免夜晚中不可知的危险；</p>
<h1 id="三-实际使用的gamma">三、实际使用的Gamma</h1>
<h2 id="文件保存中的gamma">文件保存中的Gamma</h2>
<p>实时上， <strong>我们在电脑屏幕上看到的大部分图片都是处于Gamma空间的</strong> ，尤其是屏幕的截图，屏幕的吸色，得到的都是Gamma空间的颜色，他们经常存储在PNG、TGA、JPG等格式的文件；在显示这些图片时， <strong>他们直接会被送到屏幕缓冲中进行显示</strong> ；由于文件本身为Gamma空间，图片颜色经过显示器的Gamma变换，就会显示为线性空间下的颜色，再进入人眼中，被我们人眼感知；</p>
<h2 id="渲染管线中的gamma">渲染管线中的Gamma</h2>
<p>在图形渲染中，有各种各样的环节，包括PBR Shading、后期Color Grading、后期Tone Mapping、AA等等；同一个环节内也可能包含各种各样的模块与环节，比如PBR Shading环节就包括贴图读取、BRDF相关矢量计算、BRDF计算等（不管这些是在VS阶段、还是PS阶段）；<br>
在这些环节中大部分的计算会与颜色相关，说到颜色也就伴随着Gamma空间与线性空间；那么在整个渲染管线中，应给如何处理Gamma问题呢？<br>
关于Gamma的处理，首先确认的是，显示器显示的空间应该是线性空间（前面的为什么需要Gamma Correction已经提到），所以输送到屏幕缓冲的颜色应该为Gamma空间，为了抵消屏幕的影响；另外要注意的是，我们关于颜色的光照计算或者其他计算应该在线性空间（除非一些必须在Gamma空间或其他空间的计算），以为线性空间的颜色才是物体本身的颜色，在线性空间下进行光照或其他计算才是物理正确的，否则都是物理不正确的；<br>
所以 <strong>整体的流程</strong> 应该是：</p>
<ol>
<li>读取贴图颜色，位于<a href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E4%B8%AD%E7%9A%84Gamma">Gamma Space</a>；</li>
<li>Decode Gamma到Linear Space，然后进行光照或其他关于颜色的计算；</li>
<li>Encode Gamma到Gamma Space（Gamma Correction），然后写入到屏幕缓存；</li>
<li>显示器进行Gamma变换，显示为Linear Space下的颜色；</li>
</ol>
<p>下图为RTR中在现实过程中Gamma的处理<a href="#refer-anchor"><sup>[3]</sup></a>，与我们之前所理解的一致；<br>
<img src="https://img-blog.csdnimg.cn/20210626165646704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="512" height="256" loading="lazy"></p>
<center>Gamma process in display</center>
<h2 id="gamma使用不当会引起的问题">Gamma使用不当会引起的问题</h2>
<p>事实上，早期人们还没有意识到Gamma的问题，以至于很多图形上的操作都是在Gamma空间下进行的，以至于出现了很多画面上的问题，包括Light fall-off、Linear intensity response、Linear and gamma blending等<a href="#refer-anchor"><sup>[4]</sup></a>；分别如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/2021062618200573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="480" height="256" loading="lazy"></p>
<center>Light fall-off</center>
<p>Light fall-off影响的为光照沿平面朝向的衰减，其实是就是计算该点的irridience，在diffuse上会有明显的感受；可以看到Gamma Space下亮度分布更均匀，Linear space下亮度分布更接近<a href="#%E5%85%B3%E4%BA%8EGamma%E7%9A%84%E5%B7%A7%E5%90%88">人眼感知</a>；</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210626181743896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="450" height="256" loading="lazy"></figure>
<center>Linear intensity response</center>
<p>Gamma空间下，不同光强产生的影响会更加反直觉，会非常容易产生过曝的问题，以至于在项目中美术打光很难控制光照强度；</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210626182410735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="256" height="256" loading="lazy"></figure>
<center>Linear and gamma blending</center>
<p>Gamma空间下的Blend则会引起色相偏移问题（插值、叠加或其他Blend方式），这在工程中对美术来说是很不友好的，特别是游戏中的特效，受此影响最为过大；在RTR4中则还提到了叠加引起的亮度感知错误问题，在5.6章节，有兴趣的可以看一下；<br>
<img src="https://img-blog.csdnimg.cn/2021062618520422.png#pic_center" alt="另外" width="500" height="100" loading="lazy"></p>
<center>Ropping</center>
<p>Ropping现象则是因为没有经过Gamma Correction引起的直线弯曲效应；不过需要在使用MSAA或者SSAA的情况下才能看到，上图就是开8xAA情况下出现的问题；</p>
<h1 id="总结">总结</h1>
<p>本文主要介绍了图形学中Gamma的由来，以及图形开发中与Gamma相关的场景；开发者们需要注意Gamma的存在，并通过正确的线性工作流来避免Gamma引起显示不正确问题；</p>
<div id="refer-anchor"></div>
<h1 id="references">References</h1>
<p>[1] <a href="http://poynton.ca/notes/colour_and_gamma/GammaFAQ.html">Gamma FAQ</a><br>
[2] <a href="https://www.wigglepixel.nl/en/blog/what-are-color-spaces-color-profiles-and-gamma-correction">What are Color Spaces, Color Profiles and Gamma Correction?</a><br>
[3] <a href="http://www.realtimerendering.com/">realtimerendering</a><br>
[4] <a href="https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html#:~:text=Linear%20or%20gamma%20workflow%20The%20Unity%20Editor%20offers,of%20a%20mesh%20to%20give%20it%20visual%20detail.">Linear or gamma workflow</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Thingking] PostProcess关于UV的思考]]></title>
        <id>https://wingstone.github.io/post/postprocess-guan-yu-uv-de-si-kao/</id>
        <link href="https://wingstone.github.io/post/postprocess-guan-yu-uv-de-si-kao/">
        </link>
        <updated>2021-06-10T15:47:44.000Z</updated>
        <content type="html"><![CDATA[<p>以前一直以为屏幕空间下的UV应该是0-1的范围内的；</p>
<h2 id="blit操作下的postprocess">Blit操作下的PostProcess</h2>
<p>但是最近在做后处理时，对这件事重新进行了思考，其实Shader中使用的uv肯定是经过光栅化后的数据，既然是光栅化后的数据，那么UV坐标应该是像素中心的UV坐标；</p>
<p>后期一般都是通过DrawMesh来实现的，Mesh里的UV值为0-1，而此时的Mesh肯定需要覆盖整个屏幕，那么可以得到屏幕的最左侧uv.x = 0，最右侧uv.x = 1；而最左侧对应于最左列像素的左边，最右侧对应于最右列像素的右边；</p>
<p>由此可见，对于Vertex Shader，其UV是 <strong>0-1</strong> 范围内的；<br>
对于FragmentSahder，其UV范围是最左列像素坐标到最右侧像素坐标的，令_Size = float4(1/ScreenWidth, 1/ScreenHeight, ScreenWidth, ScreenHeight)，则UV范围为 <strong>(0.5*_Size.x~1-0.5*_Size.x, 0.5*_Size.y~1-0.5*_Size.y)</strong> ；</p>
<p>下图为10x10分辨率下的UV灰度图：<br>
<img src="https://wingstone.github.io/post-images/1623341545976.jpg" alt="" width="200" height="200" loading="lazy"><br>
可以看到最左列的灰度值并不为0，看来我们的思考是对的；</p>
<h2 id="computershader下的postprocess">ComputerShader下的PostProcess</h2>
<p>ComputerShader（简称CS）下的UV获取比较特殊，因为CS并不走正常的GPU绘制流水线，只是单纯的用多线程进行并行计算，所以我们在CS中获取UV值一般是由ThreadID除以屏幕分辨率来获取；</p>
<p>简易CS Example：</p>
<pre><code class="language-C">#pragma kernel CSMain

RWTexture2D&lt;float4&gt; _Result;
float4 _Size;   //(1/width, 1/height,  width, height)

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy/_Size.zw;
    _Result[id.xy] = uv.x;
}
</code></pre>
<p>threadID即为我们分配的线程ID，每个线程有唯一值，对于图片处理，一般范围为(0<sub>width-1,0</sub>height-1)，那么算下来，CS里的UV范围应该为 <strong>(0~1-_Size.x, 0~1-_Size.y)</strong> ；</p>
<p>下图为10x10分辨率下的UV灰度图：<br>
<img src="https://wingstone.github.io/post-images/1623342423558.jpg" alt="" width="200" height="200" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FXAA理论方法]]></title>
        <id>https://wingstone.github.io/post/fxaa-li-lun-fang-fa/</id>
        <link href="https://wingstone.github.io/post/fxaa-li-lun-fang-fa/">
        </link>
        <updated>2021-03-01T14:52:01.000Z</updated>
        <content type="html"><![CDATA[<p>FXAA是基于图像空间理论的抗拒齿方法；</p>
<h2 id="基础理论为">基础理论为：</h2>
<ol>
<li>进行图像边缘检测；</li>
<li>针对检测出来的图像边缘，进行抗拒齿处理；</li>
</ol>
<h2 id="基础步骤">基础步骤：</h2>
<ol>
<li><strong>采样屏幕颜色，转换至亮度；</strong><br>
Nvidia建议使用red以及green通道来计算亮度进行优化，人眼对这两种颜色最为敏感；亮度计算方法如下：</li>
</ol>
<pre><code class="language-c++">float FxaaLuma(float3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; }
</code></pre>
<ol start="2">
<li><strong>根据亮度来计算对比度，用对比度来作为边缘检测的标准；</strong><br>
一般边缘检测都会使用<strong>当前像素</strong>，以及<strong>上下左右四个像素</strong>来进行对比度的计算；当对比度大于某个阈值时，认为当前点处于边缘位置；</li>
</ol>
<pre><code class="language-c++">float3 rgbN  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0,-1)).xyz;
float3 rgbW  = FxaaTextureOffset(tex, pos.xy, FxaaInt2(-1, 0)).xyz;
float3 rgbM  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0, 0)).xyz;
float3 rgbE  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 1, 0)).xyz;
float3 rgbS  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0, 1)).xyz;
float lumaN  = FxaaLuma(rgbN);
float lumaW  = FxaaLuma(rgbW);
float lumaM  = FxaaLuma(rgbM);
float lumaE  = FxaaLuma(rgbE);
float lumaS  = FxaaLuma(rgbS);
float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));
float range = rangeMax -rangeMin;
if(range &lt; max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * XAA_EDGE_THRESHOLD))           {return FxaaFilterReturn(rgbM); }
</code></pre>
<ol start="3">
<li><strong>边缘的横纵向检测，用于后续抗拒齿处理；</strong><br>
边缘进行光栅化之后，在比较小的维度上，只有横向边缘与纵向边缘之分；检测出来横向与纵向，可以便于后续沿边缘进行延伸；</li>
</ol>
<pre><code class="language-c++">float edgeVert = abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));
float edgeHorz = abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));
bool horzSpan = edgeHorz &gt;= edgeVert;   //判断当前像素位于横向边缘还是纵向边缘
</code></pre>
<p>4.** 判断真正的边缘边界位置，并将当前点定位到真正的边缘边界处；**<br>
检测出横向还是纵向后，需要定位边缘边界是在上横向还是下横向，左横向还是右横向；<br>
当前点是在像素中心，定位出边缘边界（位于两个像素的交接处）后，即可将当前点移动到边缘边界；</p>
<pre><code class="language-c++">// 梯度最大处作为边缘边界的位置；
float luma1 = isHorizontal ? lumaDown : lumaLeft;
float luma2 = isHorizontal ? lumaUp : lumaRight;
float gradient1 = luma1 - lumaCenter;
float gradient2 = luma2 - lumaCenter;
bool is1Steepest = abs(gradient1) &gt;= abs(gradient2);

// 我也不清楚此处为什么要用0.25来进行normalize，感觉就是一个简单的factor；
float gradientScaled = 0.25*max(abs(gradient1),abs(gradient2));

float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;

//边缘边界处（计算像素相交处）的亮度平均值
float lumaLocalAverage = 0.0;
if(is1Steepest){
    stepLength = - stepLength;
    lumaLocalAverage = 0.5*(luma1 + lumaCenter);
} else {
    lumaLocalAverage = 0.5*(luma2 + lumaCenter);
}

// 将uv移动半个像素，定位到边缘边界处（像素相交处）.
vec2 currentUv = In.uv;
if(isHorizontal){
    currentUv.y += stepLength * 0.5;
} else {
    currentUv.x += stepLength * 0.5;
}
</code></pre>
<ol start="5">
<li>定位到边界处，需要沿边缘方向（横向或纵向）进行搜索，来计算当前边缘的长度；<br>
之所以计算边缘的长度，是因为锯齿一般都出现在边缘端点处；离端点越远，越不容易产生锯齿；我们需要计算当前边缘边界距边缘端点的距离，用来计算锯齿的强弱程度；</li>
</ol>
<pre><code class="language-c++">// 第一步迭代
vec2 offset = isHorizontal ? vec2(inverseScreenSize.x,0.0) : vec2(0.0,inverseScreenSize.y);
vec2 uv1 = currentUv - offset;
vec2 uv2 = currentUv + offset;

float lumaEnd1 = rgb2luma(texture(screenTexture,uv1).rgb);
float lumaEnd2 = rgb2luma(texture(screenTexture,uv2).rgb);
lumaEnd1 -= lumaLocalAverage;
lumaEnd2 -= lumaLocalAverage;

bool reached1 = abs(lumaEnd1) &gt;= gradientScaled;
bool reached2 = abs(lumaEnd2) &gt;= gradientScaled;
bool reachedBoth = reached1 &amp;&amp; reached2;

if(!reached1){
    uv1 -= offset;
}
if(!reached2){
    uv2 += offset;
}  

// 继续后面的迭代
if(!reachedBoth){

    for(int i = 2; i &lt; ITERATIONS; i++){
        if(!reached1){
            lumaEnd1 = rgb2luma(texture(screenTexture, uv1).rgb);
            lumaEnd1 = lumaEnd1 - lumaLocalAverage;
        }
        if(!reached2){
            lumaEnd2 = rgb2luma(texture(screenTexture, uv2).rgb);
            lumaEnd2 = lumaEnd2 - lumaLocalAverage;
        }
        reached1 = abs(lumaEnd1) &gt;= gradientScaled;
        reached2 = abs(lumaEnd2) &gt;= gradientScaled;
        reachedBoth = reached1 &amp;&amp; reached2;

        // 此处QUALITY为迭代步进的缩放系数，一般前5步为1，后面可逐渐递增
        if(!reached1){
            uv1 -= offset * QUALITY(i);
        }
        if(!reached2){
            uv2 += offset * QUALITY(i);
        }

        if(reachedBoth){ break;}
    }
}
</code></pre>
<ol start="6">
<li>偏移（此偏移量作用于最初uv，用于最终采样）估算<br>
前面说到越靠近边缘终点，锯齿越严重，那么最终像素输出采样点的偏移量越大；与此相反，越靠近边缘中点，输出采样点的偏移量越小；算法如下：</li>
</ol>
<pre><code class="language-c++">// 使用边缘边界点与边缘终点的距离处于边缘的长度来计算offset
float distance1 = isHorizontal ? (In.uv.x - uv1.x) : (In.uv.y - uv1.y);
float distance2 = isHorizontal ? (uv2.x - In.uv.x) : (uv2.y - In.uv.y);
bool isDirection1 = distance1 &lt; distance2;
float distanceFinal = min(distance1, distance2);
float edgeThickness = (distance1 + distance2);
float pixelOffset = - distanceFinal / edgeThickness + 0.5;

// 添加额外的判断，来保证端点处的走势（gradient）与中心处的一致
bool isLumaCenterSmaller = lumaCenter &lt; lumaLocalAverage;
bool correctVariation = ((isDirection1 ? lumaEnd1 : lumaEnd2) &lt; 0.0) != isLumaCenterSmaller;
float finalOffset = correctVariation ? pixelOffset : 0.0;
</code></pre>
<ol start="7">
<li>子像素抗拒齿处理<br>
使用额外的步骤即可处理子像素抗拒齿（即细线引起的锯齿，或点引起的锯齿，我也不知道为啥叫做子像素锯齿==）；<br>
基本思路是计算中心点与周围点的差值，然后计算此差值与局部差值的比值来计算子像素抗拒齿的偏移量；最终选择较大偏移量作为最终采样值；</li>
</ol>
<pre><code class="language-c++">float lumaAverage = (1.0/12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);
float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter)/lumaRange,0.0,1.0);
float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;
float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * SUBPIXEL_QUALITY;

// Pick the biggest of the two offsets.
finalOffset = max(finalOffset,subPixelOffsetFinal);
</code></pre>
<ol start="8">
<li>使用最终偏移量进行采样;</li>
</ol>
<pre><code class="language-c++">vec2 finalUv = In.uv;
if(isHorizontal){
    finalUv.y += finalOffset * stepLength;
} else {
    finalUv.x += finalOffset * stepLength;
}

vec3 finalColor = texture(screenTexture,finalUv).rgb;
fragColor = finalColor;
</code></pre>
<p>注意点：FXAA运行在sRGB空间；直接作用于linear、hdr数据，会出现闪烁问题；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity中序列化Asset的修改]]></title>
        <id>https://wingstone.github.io/post/unity-zhong-xu-lie-hua-asset-de-xiu-gai/</id>
        <link href="https://wingstone.github.io/post/unity-zhong-xu-lie-hua-asset-de-xiu-gai/">
        </link>
        <updated>2021-02-28T15:31:35.000Z</updated>
        <content type="html"><![CDATA[<p>代码片段事例：</p>
<pre><code>        Object obj = new Object();
        SerializedObject so = new SerializedObject(obj);     //这里obj为要进行序列化操作的asset对象
        SerializedProperty sp = so.FindProperty(&quot;property&quot;);    //这里property为要进行操作的property，需要查看asset文件获取
        sp.boolValue = true;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种常用渲染技术文章集合]]></title>
        <id>https://wingstone.github.io/post/ge-chong-chang-yong-xuan-ran-ji-zhu-wen-zhang-ji-he/</id>
        <link href="https://wingstone.github.io/post/ge-chong-chang-yong-xuan-ran-ji-zhu-wen-zhang-ji-he/">
        </link>
        <updated>2020-11-11T13:52:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="localcubemap">LocalCubemap</h2>
<p><a href="https://armkeil.blob.core.windows.net/developer/Files/pdf/graphics-and-multimedia/ImplementingReflectionsinUnityUsingLocalCubemaps.pdf">ImplementingReflectionsinUnityUsingLocalCubemaps PDF</a><br>
<a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity">Reflections Based on Local Cubemaps in Unity Web</a></p>
<h2 id="clearcoat">ClearCoat</h2>
<p><a href="https://google.github.io/filament/Filament.html#materialsystem/clearcoatmodel">Clear coat model in filament Web</a></p>
<h2 id="cloud-in-sky">Cloud In Sky</h2>
<p><a href="http://walkingfat.com/bump-noise-cloud-3d%e5%99%aa%e7%82%b9gpu-instancing%e5%88%b6%e4%bd%9c%e5%9f%ba%e4%ba%8e%e6%a8%a1%e5%9e%8b%e7%9a%84%e4%bd%93%e7%a7%af%e4%ba%91/">Bump Noise Cloud – 3D噪点+GPU instancing制作基于模型的体积云 Web</a><br>
<a href="https://blog.csdn.net/qq_33967521/article/details/102657017">浅谈《Sky 光·遇》中的渲染技术 Web</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[景深的实现技术]]></title>
        <id>https://wingstone.github.io/post/jing-shen-de-shi-xian-ji-zhu/</id>
        <link href="https://wingstone.github.io/post/jing-shen-de-shi-xian-ji-zhu/">
        </link>
        <updated>2020-10-20T08:47:41.000Z</updated>
        <content type="html"><![CDATA[<p>景深的实现技术有很多，针对不同的使用场景，可以使用不同的方法；</p>
<h2 id="基于光线追踪的景深效果离线">基于光线追踪的景深效果（离线）</h2>
<p>基于光线追踪的景深效果，直接使用薄透镜模型，在透镜上面进行多采样即可实现景深效果；</p>
<p>关于薄透镜理论的使用，可以参考这里<a href="https://zhuanlan.zhihu.com/p/23827065">基于摄影参数渲染</a>;</p>
<h2 id="基于累积贴图的景深效果实时">基于累积贴图的景深效果（实时）</h2>
<p>大致思路为，将相机进行移动（可按照透镜多采样的方式移动），沿焦平面进行多个相机的渲染，然后将渲染结果进行累加，这样就能获取与光线追踪类似的效果；本质上类似于光线追踪的多采样方式，但需要花费大量的DC，一般只用来验证；</p>
<h2 id="基于分层绘制的景深效果实时">基于分层绘制的景深效果（实时）</h2>
<p>本质上，是基于2D图层的方式来实现；将场景按深度进行分层绘制，然后将远离焦距的绘制rt记性模糊，然后按层进行混合，即可获取接近景深的效果；</p>
<p>使用要求时，不同的景物之间不能有交叉，即物体不能有太强的深度变化；因为针对单个物体是无法产生即聚焦又失焦的现象；</p>
<h2 id="基于前向映射的z-buffer的景深效果实时">基于前向映射的Z-buffer的景深效果（实时）</h2>
<p>此方法常用在后处理效果中，该方法存储颜色缓冲与深度缓冲作为最后的blit对象；然后使用深度缓冲计算COC（circle of confusion），即点投影在屏幕上形成的弥散圆；再然后利用弥散圆进行模糊与blend，这里模糊并不是通常意义上的模糊，模糊需要的圆盘采样与普通模糊一致，但是采样的判定需要根据采样点的COC是否能覆盖到当前点，来确定该采样点的弥散圆是否对当前点有贡献；GPU Gems中说blend只能混合到距离摄像机比自己远的那些相邻像素中，以避免模糊的像素影响它们前面的清晰像素。实际上，blend的是为了避免前面模糊造成聚焦物体边缘的消失；</p>
<h2 id="基于反向映射的z-buffer的景深效果实时">基于反向映射的Z-buffer的景深效果（实时）</h2>
<p>该方法与上一种技术类似，区别在于并不是通过blend来形成最后的图像，而是通过使用深度值距焦距的距离来进行blur，从而形成最终的效果；这里把当前点的弥散圆当做模糊范围来进行计算了，与实际的PBR有些偏差，但也能凑活使用；</p>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/depth-of-field/">Depth of Field</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-23-depth-field-survey-techniques">Depth of Field: A Survey of Techniques</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23827065">基于摄影参数渲染</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/146143501">渲染中的景深(Depth of Field/DOF)</a></li>
<li><a href="https://epicgames.ent.box.com/s/s86j70iamxvsuu6j35pilypficznec04">A Life of a Bokeh - SIGGRAPH 2018</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后处理技术——景深]]></title>
        <id>https://wingstone.github.io/post/hou-chu-li-ji-zhu-jing-shen/</id>
        <link href="https://wingstone.github.io/post/hou-chu-li-ji-zhu-jing-shen/">
        </link>
        <updated>2020-10-20T08:05:48.000Z</updated>
        <content type="html"><![CDATA[<p>景深是能体现场景纵深的重要效果，同时还能虚化前景与背景，这样可以让玩家将注意力集中在聚焦物体上；</p>
<h2 id="实现步骤">实现步骤</h2>
<h3 id="提取coc">提取COC</h3>
<p>所谓COC即circle of confusion，表示一点投影在屏幕上所形成的弥散圆。可知，焦距上的点仍然会形成点，而远离焦距的点则会形成弥散圆；</p>
<p>一般将COC的半径存储为rt，此半径需要根据焦距（focus distance）以及焦距范围（focus range）来进行计算；</p>
<h3 id="计算散景效果">计算散景效果</h3>
<p>实际上就是使用圆形范围的模糊效果来进行RT的blit；这里模糊并不是通常意义上的模糊，模糊需要的圆盘采样与普通模糊一致，但是采样的判定需要根据采样点的COC是否能覆盖到当前点，来确定该采样点的弥散圆是否对当前点有贡献（GPU Gems中说blend只能混合到距离摄像机比自己远的那些相邻像素中，以避免模糊的像素影响它们前面的清晰像素。）；</p>
<p>考虑到采样所带来的的效率问题，一般都会讲rt进行降采样处理；同样的COC也要记性降采样，才可以使用，一般会将其存储至rt的alpha通道；</p>
<p>一般散景模糊主要考虑的就是效率问题，可以采用其他的途径来获取相应效果；毕竟只是实现模糊就有很多种不同方法；</p>
<h3 id="与物模糊背景进行融合">与物模糊背景进行融合</h3>
<p>计算散景效果时，对于聚焦物体的边缘部分，还是会产生模糊问题；为了比较这种问题产生，只能使用blend方法，将这些区域恢复为原来的无模糊图像；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[天空渲染——大气物理]]></title>
        <id>https://wingstone.github.io/post/tian-kong-xuan-ran-da-qi-wu-li/</id>
        <link href="https://wingstone.github.io/post/tian-kong-xuan-ran-da-qi-wu-li/">
        </link>
        <updated>2020-10-10T07:38:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="大气物理现象">大气物理现象</h2>
<p>假设1：空气密度随着高度成指数进行衰减；即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>=</mo><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>(</mo><mn>0</mn><mo>)</mo><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>h</mi><mi>H</mi></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">density(h) = density(0)e^{-\frac{h}{H}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.27902em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.02902em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中density(0)为海平面密度，h为当前高度，H为scale height，随温度变化；不是所有的人都采用这种模型，另一种密度假设为分层模型，每一层采用不同的大气密度；</p>
<p>大气分子散射主要可分为<strong>空气分子散射（Rayleigh scattering，小于光线波长）<strong>与</strong>气溶胶散射（Mie scattering，大于光线波长）</strong>；空气分子散射主要会产生天空的蓝色成分与橘黄色成分（日出、日落时分），气溶胶散射主要会导致灰白色条带（特别是污染都市上空）；</p>
<p>在进行光追计算时，还需要进行地球半径的假设，以及大气层半径的假设；我们假设地球半径为6360 km，大气半径为6420 km，此外还需要假设太阳光为平行光，因为太阳距地球足够远；</p>
<p>计算的过程中需要注意量纲的统一，一般都去Km；</p>
<p>熟悉体渲染的人应该知道，物体的体渲染熟悉可以用散射系数（针对外散射）、吸收系数、相位函数（针对内散射）进行描述，我们这里忽略大气吸收的过程，即忽略吸收系数的计算；</p>
<h2 id="rayleigh-scattering">Rayleigh scattering</h2>
<p>Rayleigh scattering具有很强的波长依赖性，散射蓝光比绿光和红光具有更高的精确性；</p>
<p>Rayleigh首先提出了计算此现象的公式，他给出了散射系数的公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>λ</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mn>8</mn><msup><mi>π</mi><mn>3</mn></msup><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow><mrow><mn>3</mn><mi>N</mi><msup><mi>λ</mi><mn>4</mn></msup></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>h</mi><msub><mi>H</mi><mi>R</mi></msub></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">{\beta}_R^s(h, \lambda) = \frac{8\pi^3(n^2-1)^2}{3N\lambda^4}e^{-\frac{h}{H_R}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.133835em;"><span style="top:-3.5178149999999997em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.6559999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:-0.08125em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833299999999998em;"></span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.33853em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5858071428571429em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这里<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>表示波长，N表示大气分子密度，n为大气折射率，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">H_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>即为前面的scale height，此处我们取8Km；</p>
<p>参考文献中N与n并没有给出相应的参数，但是给出了相应的散射系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup><mo>=</mo><mo>(</mo><mn>5.8</mn><mo separator="true">,</mo><mn>13.5</mn><mo separator="true">,</mo><mn>33.1</mn><mo>)</mo><mn>1</mn><msup><mn>0</mn><mo>−</mo></msup><mn>6</mn><msup><mi>m</mi><mo>−</mo></msup><mn>1</mn></mrow><annotation encoding="application/x-tex">\beta^s_R=(5.8, 13.5, 33.1)10^-6m^-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9697709999999999em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">.</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">6</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">1</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mo>(</mo><mn>680</mn><mo separator="true">,</mo><mn>550</mn><mo separator="true">,</mo><mn>440</mn><mo>)</mo><mi>n</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">\lambda=(680, 550, 440)nm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">8</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">5</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mord">0</span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span></span></span></span>；</p>
<p>渲染使用的extinction coefficient为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>e</mi></msubsup><mo>=</mo><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup></mrow><annotation encoding="application/x-tex">\beta_R^e = \beta_R^s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>相位函数的公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>R</mi></msub><mo>(</mo><mi>μ</mi><mo>)</mo><mo>=</mo><mfrac><mn>3</mn><mrow><mn>16</mn><mi>π</mi></mrow></mfrac><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>μ</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">P_R(\mu)=\frac{3}{16\pi}(1+\mu^2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>表示光线与视角的夹角；</p>
<h2 id="mie-scattering">Mie Scattering</h2>
<p>与Rayleigh Scattering类似，其散射公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>M</mi><mi>s</mi></msubsup><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>λ</mi><mo>)</mo><mo>=</mo><msubsup><mi>β</mi><mi>M</mi><mi>s</mi></msubsup><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>λ</mi><mo>)</mo><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>h</mi><msub><mi>H</mi><mi>M</mi></msub></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\beta_M^s(h,\lambda)=\beta_M^s(0,\lambda) e^{-\frac{h}{H_M}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.383835em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.133835em;"><span style="top:-3.5178149999999997em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.6559999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:-0.08125em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833299999999998em;"></span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.33853em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5858071428571429em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">H_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>通常取1.2Km；同样类似于Rayleigh Scattering，气溶胶密度也随高度进行指数衰减，我们直接取散射系数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>M</mi><mi>s</mi></msubsup><mo>=</mo><mn>210</mn><mi>x</mi><mn>1</mn><msup><mn>0</mn><mo>−</mo></msup><mn>5</mn><msup><mi>m</mi><mo>−</mo></msup><mn>1</mn></mrow><annotation encoding="application/x-tex">\beta^s_M=210x10^-5m^-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9697709999999999em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">1</span></span></span></span>；</p>
<p>渲染使用的extinction coefficient为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>e</mi></msubsup><mo>=</mo><mn>1.1</mn><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup></mrow><annotation encoding="application/x-tex">\beta_R^e = 1.1\beta_R^s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>相位函数为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>M</mi></msub><mo>(</mo><mi>μ</mi><mo>)</mo><mo>=</mo><mfrac><mn>3</mn><mrow><mn>8</mn><mi>π</mi></mrow></mfrac><mfrac><mrow><mo>(</mo><mn>1</mn><mo>−</mo><msup><mi>g</mi><mn>2</mn></msup><mo>)</mo><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>μ</mi><mn>2</mn></msup><mo>)</mo></mrow><mrow><mo>(</mo><mn>2</mn><mo>+</mo><msup><mi>g</mi><mn>2</mn></msup><mo>)</mo><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>g</mi><mn>2</mn></msup><mo>−</mo><mn>2</mn><mi>g</mi><mi>μ</mi><msup><mo>)</mo><mfrac><mn>3</mn><mn>2</mn></mfrac></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">P_M(\mu)=\frac{3}{8\pi}\frac{(1-g^2)(1+\mu^2)}{(2+g^2)(1+g^2-2g\mu)^{\frac{3}{2}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.570678em;vertical-align:-1.07957em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.17043em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.93957em;"><span style="top:-3.3485500000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.07957em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>项用来控制介质的各向异性，一般取0.76；</p>
<h2 id="reference">Reference</h2>
<p><a href="https://www.ea.com/frostbite/news/physically-based-sky-atmosphere-and-cloud-rendering">寒霜引擎天空渲染实现</a></p>
<p><a href="https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky">Simulating the Colors of the Sky</a></p>
<p><a href="http://www-ljk.imag.fr/Publications/Basilic/com.lmc.publi.PUBLI_Article@11e7cdda2f7_f64b69/article.pdf">Precomputed Atmospheric Scattering</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软阴影技术——PCF、ESM、VSM、CSM、PCSS]]></title>
        <id>https://wingstone.github.io/post/yin-ying-ji-zhu-pcfesmvsmpcss/</id>
        <link href="https://wingstone.github.io/post/yin-ying-ji-zhu-pcfesmvsmpcss/">
        </link>
        <updated>2020-09-30T15:39:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pcfpercentage-closer-filtering">PCF（Percentage-Closer Filtering）</h2>
<p>就是对阴影结果进行滤波，这里的阴影结果指阴影测试函数所得的结果；一般采用双线性滤波，此时可以使用硬件PCF来进行插值；</p>
<h3 id="实现要求">实现要求</h3>
<p>Depth格式的shadow map或者ShadowMap格式的shadow map；</p>
<h2 id="esmexponential-shadow-maps">ESM（Exponential Shadow Maps）</h2>
<p>PCF方法对阴影结果进行滤波，无法集成到阴影测试函数中；因此可以采用其他的阴影测试函数来进行实现软阴影效果；</p>
<p>ESM采用指数空间下的深度测试函数来代替传统的深度测试函数；</p>
<p>采用ESM方法，存储的为指数空间下的阴影数值，支持预滤波，这样就可以对shadowmap进行blur，将滤波与测试函数进行分离；</p>
<p>传统shadowmap存储的为深度z，而在ESM中存储的为<code>exp(c*z)</code>，即深度值的指数形式；其中c表示指数常数，对于32位存储格式，极限值为88；</p>
<p>而阴影测试函数，传统的shadowmap为<code>step(d, z)</code>，而ESM的阴影测试函数则变为<code>exp(-cd)*tz</code>；其中tz表示采样的指数深度值，即<code>exp(c*z)</code>，这样原来的<code>z-d</code>转变为了<code>exp(c(z-d))</code>；</p>
<h3 id="所带来的问题有">所带来的问题有：</h3>
<ol>
<li>计算出来的阴影值与shadow caseter、shadow receiver之间的距离有关，距离越远，阴影越黑，越近，阴影越接近于无；</li>
<li>多重阴影下，肯会由于shadow map精度问题产生瑕疵；</li>
<li>对rt精度要求比较高；</li>
</ol>
<h3 id="实现需求">实现需求</h3>
<p>一张Depth格式的shadow map即可，需要手动对其进行模糊；</p>
<h2 id="renference">Renference</h2>
<ol>
<li>《实时阴影技术》 艾森曼努；</li>
<li><a href="https://zhuanlan.zhihu.com/p/26853641">实时渲染中的软阴影技术</a></li>
<li><a href="http://www.klayge.org/2013/10/07/%e5%88%87%e6%8d%a2%e5%88%b0esm/">切换到esm</a></li>
</ol>
]]></content>
    </entry>
</feed>