<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wingstone.github.io</id>
    <title>CG黑魔法作坊</title>
    <updated>2021-06-26T15:04:47.447Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wingstone.github.io"/>
    <link rel="self" href="https://wingstone.github.io/atom.xml"/>
    <subtitle>分享与记录关于CG技术的一切</subtitle>
    <logo>https://wingstone.github.io/images/avatar.png</logo>
    <icon>https://wingstone.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, CG黑魔法作坊</rights>
    <entry>
        <title type="html"><![CDATA[Light and Color——Gamma]]></title>
        <id>https://wingstone.github.io/post/light-and-color-gamma/</id>
        <link href="https://wingstone.github.io/post/light-and-color-gamma/">
        </link>
        <updated>2021-06-26T13:11:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>在图形开发中，总绕不开的一个名词，Gamma，这里会对Gamma进行一个粗暴但是通俗的讲解；便于理清图形开发中理解Gamma的一切；</p>
<h1 id="一-gamma是什么">一、Gamma是什么？</h1>
<p>Gamma是什么，Gamma FAQ<a href="#refer-anchor"><sup>[1]</sup></a>中有解释：在传统的CRT显示器中，屏幕显示的Luminance与电压并不是成正比的关系，而是成一个幂次方的关系，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><msup><mi>V</mi><mi>γ</mi></msup></mrow><annotation encoding="application/x-tex">L = V^\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span></span></span>，其中的幂就是我们通说所说的Gamma；<br>
<img src="https://img-blog.csdnimg.cn/20210623234248419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="Gamma变换" width="256" height="256" loading="lazy"></p>
<center>显示器的Gamma变换</center>
<h1 id="二-gamma-correction">二、Gamma Correction</h1>
<h2 id="gamma-correction是什么">Gamma Correction是什么？</h2>
<p>由于显示器所显示的Luminance为正常展示场景亮度的gamma次方（我们称之为Gamma变换），为了使显示器亮度为正常的展示场景亮度，抵消显示器Gamma变换的影响，必须在显示器前对展示场景亮度做 <strong>Gamma变换的逆变换</strong> ，此逆变换我们称之为 <strong>Gamma Correction</strong> ；<br>
<img src="https://img-blog.csdnimg.cn/20210623234433372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="256" height="256" loading="lazy"></p>
<center>显示器的Gamma Correction</center>
<p>实际上场景所在的空间，我们常称之为线性空间，即 <strong>Linear Space</strong> ，对应着曲线y=x；经过 <strong>Gamma Correction过后的空间</strong> ，我们称之为Gamma空间，即 <strong>Gamma Space</strong> ，对应着曲线y=x的上半段；</p>
<p>Gamma Correction有时也称 <strong>Encode Gamma</strong> ，从Gamma空间转换到线性空间变换则称之为 <strong>Decode Gamma</strong> ；</p>
<h2 id="为什么需要gamma-correction">为什么需要Gamma Correction？</h2>
<p>上面已经说到，做Gamma Correction是为了让显示器显示正常的场景亮度，这就是要做Gamma Correction的做主要的原因；</p>
<p>实际上人眼看到现实场景就是线性的，要想让观众觉得显示器里的东西更接近现实，显示器就必须要显示为线性空间；</p>
<h2 id="关于gamma的巧合">关于Gamma的巧合</h2>
<p>实际上， <strong>人眼对亮度的感知也并不是线性的，巧合的是，人眼对亮度的感知曲线搞刚好是显示器Gamma变换的逆变换的曲线（与Gamma矫正类似）</strong><a href="#refer-anchor"><sup>[2]</sup></a> ；</p>
<p>这样导致的结果就是：假如没有Gamma Correction，显示器显示一段均匀变化的亮度，人眼感知到的亮度刚好也是均匀的；因为显示器先做了Gamma变换，人眼感知又做了Gamma逆变换，导致人眼感知到的是均匀的；如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210623231605422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="未做Gamma Correction的0-1渐变图" width="512" height="256" loading="lazy"></figure>
<center>未做Gamma Correction的0-1渐变图</center>
<p>如果我们做了Gamma Correction，这个时候虽然是显示器最终显示的是均匀变化的亮度，但是人眼的感受却是不均匀的；因为先做了Gamma Correction（Gamma逆变换），然后显示器做了Gamma变换，人眼感知又做了Gamma逆变换，导致人眼感知到的是Gamma逆变换后的；如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/2021062323311715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="512" height="256" loading="lazy"></p>
<center>做了Gamma Correction的0-1渐变图</center>
<p>做了Gamma Correction之后的渐变图就是人眼真正应该感知到的渐变图：暗部人眼感知到的亮度大于实际亮度，且相差比较大；亮部人眼感知到的亮度与实际亮度基本持平，且相差较小；</p>
<p>之所以人眼有这样的特征，是因为为了能够在夜晚中生存，暗部或被人眼感知上提亮，这样就能够避免夜晚中不可知的危险；</p>
<h1 id="三-实际使用的gamma">三、实际使用的Gamma</h1>
<h2 id="文件保存中的gamma">文件保存中的Gamma</h2>
<p>实时上， <strong>我们在电脑屏幕上看到的大部分图片都是处于Gamma空间的</strong> ，尤其是屏幕的截图，屏幕的吸色，得到的都是Gamma空间的颜色，他们经常存储在PNG、TGA、JPG等格式的文件；在显示这些图片时， <strong>他们直接会被送到屏幕缓冲中进行显示</strong> ；由于文件本身为Gamma空间，图片颜色经过显示器的Gamma变换，就会显示为线性空间下的颜色，再进入人眼中，被我们人眼感知；</p>
<h2 id="渲染管线中的gamma">渲染管线中的Gamma</h2>
<p>在图形渲染中，有各种各样的环节，包括PBR Shading、后期Color Grading、后期Tone Mapping、AA等等；同一个环节内也可能包含各种各样的模块与环节，比如PBR Shading环节就包括贴图读取、BRDF相关矢量计算、BRDF计算等（不管这些是在VS阶段、还是PS阶段）；<br>
在这些环节中大部分的计算会与颜色相关，说到颜色也就伴随着Gamma空间与线性空间；那么在整个渲染管线中，应给如何处理Gamma问题呢？<br>
关于Gamma的处理，首先确认的是，显示器显示的空间应该是线性空间（前面的为什么需要Gamma Correction已经提到），所以输送到屏幕缓冲的颜色应该为Gamma空间，为了抵消屏幕的影响；另外要注意的是，我们关于颜色的光照计算或者其他计算应该在线性空间（除非一些必须在Gamma空间或其他空间的计算），以为线性空间的颜色才是物体本身的颜色，在线性空间下进行光照或其他计算才是物理正确的，否则都是物理不正确的；<br>
所以 <strong>整体的流程</strong> 应该是：</p>
<ol>
<li>读取贴图颜色，位于<a href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E4%B8%AD%E7%9A%84Gamma">Gamma Space</a>；</li>
<li>Decode Gamma到Linear Space，然后进行光照或其他关于颜色的计算；</li>
<li>Encode Gamma到Gamma Space（Gamma Correction），然后写入到屏幕缓存；</li>
<li>显示器进行Gamma变换，显示为Linear Space下的颜色；</li>
</ol>
<p>下图为RTR中在现实过程中Gamma的处理<a href="#refer-anchor"><sup>[3]</sup></a>，与我们之前所理解的一致；<br>
<img src="https://img-blog.csdnimg.cn/20210626165646704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="512" height="256" loading="lazy"></p>
<center>Gamma process in display</center>
<h2 id="gamma使用不当会引起的问题">Gamma使用不当会引起的问题</h2>
<p>事实上，早期人们还没有意识到Gamma的问题，以至于很多图形上的操作都是在Gamma空间下进行的，以至于出现了很多画面上的问题，包括Light fall-off、Linear intensity response、Linear and gamma blending等<a href="#refer-anchor"><sup>[4]</sup></a>；分别如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/2021062618200573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="480" height="256" loading="lazy"></p>
<center>Light fall-off</center>
<p>Light fall-off影响的为光照沿平面朝向的衰减，其实是就是计算该点的irridience，在diffuse上会有明显的感受；可以看到Gamma Space下亮度分布更均匀，Linear space下亮度分布更接近<a href="#%E5%85%B3%E4%BA%8EGamma%E7%9A%84%E5%B7%A7%E5%90%88">人眼感知</a>；</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210626181743896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="450" height="256" loading="lazy"></figure>
<center>Linear intensity response</center>
<p>Gamma空间下，不同光强产生的影响会更加反直觉，会非常容易产生过曝的问题，以至于在项目中美术打光很难控制光照强度；</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210626182410735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODE3NzAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" width="256" height="256" loading="lazy"></figure>
<center>Linear and gamma blending</center>
<p>Gamma空间下的Blend则会引起色相偏移问题（插值、叠加或其他Blend方式），这在工程中对美术来说是很不友好的，特别是游戏中的特效，受此影响最为过大；在RTR4中则还提到了叠加引起的亮度感知错误问题，在5.6章节，有兴趣的可以看一下；<br>
<img src="https://img-blog.csdnimg.cn/2021062618520422.png#pic_center" alt="另外" width="500" height="100" loading="lazy"></p>
<center>Ropping</center>
<p>Ropping现象则是因为没有经过Gamma Correction引起的直线弯曲效应；不过需要在使用MSAA或者SSAA的情况下才能看到，上图就是开8xAA情况下出现的问题；</p>
<h1 id="总结">总结</h1>
<p>本文主要介绍了图形学中Gamma的由来，以及图形开发中与Gamma相关的场景；开发者们需要注意Gamma的存在，并通过正确的线性工作流来避免Gamma引起显示不正确问题；</p>
<h1 id="references">References</h1>
<p>[1] <a href="http://poynton.ca/notes/colour_and_gamma/GammaFAQ.html">Gamma FAQ</a><br>
[2] <a href="https://www.wigglepixel.nl/en/blog/what-are-color-spaces-color-profiles-and-gamma-correction">What are Color Spaces, Color Profiles and Gamma Correction?</a><br>
[3] <a href="http://www.realtimerendering.com/">realtimerendering</a><br>
[4] <a href="https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html#:~:text=Linear%20or%20gamma%20workflow%20The%20Unity%20Editor%20offers,of%20a%20mesh%20to%20give%20it%20visual%20detail.">Linear or gamma workflow</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostProcess关于UV的思考]]></title>
        <id>https://wingstone.github.io/post/postprocess-guan-yu-uv-de-si-kao/</id>
        <link href="https://wingstone.github.io/post/postprocess-guan-yu-uv-de-si-kao/">
        </link>
        <updated>2021-06-10T15:47:44.000Z</updated>
        <content type="html"><![CDATA[<p>以前一直以为屏幕空间下的UV应该是0-1的范围内的；</p>
<h2 id="blit操作下的postprocess">Blit操作下的PostProcess</h2>
<p>但是最近在做后处理时，对这件事重新进行了思考，其实Shader中使用的uv肯定是经过光栅化后的数据，既然是光栅化后的数据，那么UV坐标应该是像素中心的UV坐标；</p>
<p>后期一般都是通过DrawMesh来实现的，Mesh里的UV值为0-1，而此时的Mesh肯定需要覆盖整个屏幕，那么可以得到屏幕的最左侧uv.x = 0，最右侧uv.x = 1；而最左侧对应于最左列像素的左边，最右侧对应于最右列像素的右边；</p>
<p>由此可见，对于Vertex Shader，其UV是 <strong>0-1</strong> 范围内的；<br>
对于FragmentSahder，其UV范围是最左列像素坐标到最右侧像素坐标的，令_Size = float4(1/ScreenWidth, 1/ScreenHeight, ScreenWidth, ScreenHeight)，则UV范围为 <strong>(0.5*_Size.x~1-0.5*_Size.x, 0.5*_Size.y~1-0.5*_Size.y)</strong> ；</p>
<p>下图为10x10分辨率下的UV灰度图：<br>
<img src="https://wingstone.github.io/post-images/1623341545976.jpg" alt="" width="200" height="200" loading="lazy"><br>
可以看到最左列的灰度值并不为0，看来我们的思考是对的；</p>
<h2 id="computershader下的postprocess">ComputerShader下的PostProcess</h2>
<p>ComputerShader（简称CS）下的UV获取比较特殊，因为CS并不走正常的GPU绘制流水线，只是单纯的用多线程进行并行计算，所以我们在CS中获取UV值一般是由ThreadID除以屏幕分辨率来获取；</p>
<p>简易CS Example：</p>
<pre><code class="language-C">#pragma kernel CSMain

RWTexture2D&lt;float4&gt; _Result;
float4 _Size;   //(1/width, 1/height,  width, height)

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy/_Size.zw;
    _Result[id.xy] = uv.x;
}
</code></pre>
<p>threadID即为我们分配的线程ID，每个线程有唯一值，对于图片处理，一般范围为(0<sub>width-1,0</sub>height-1)，那么算下来，CS里的UV范围应该为 <strong>(0~1-_Size.x, 0~1-_Size.y)</strong> ；</p>
<p>下图为10x10分辨率下的UV灰度图：<br>
<img src="https://wingstone.github.io/post-images/1623342423558.jpg" alt="" width="200" height="200" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FXAA理论方法]]></title>
        <id>https://wingstone.github.io/post/fxaa-li-lun-fang-fa/</id>
        <link href="https://wingstone.github.io/post/fxaa-li-lun-fang-fa/">
        </link>
        <updated>2021-03-01T14:52:01.000Z</updated>
        <content type="html"><![CDATA[<p>FXAA是基于图像空间理论的抗拒齿方法；</p>
<h2 id="基础理论为">基础理论为：</h2>
<ol>
<li>进行图像边缘检测；</li>
<li>针对检测出来的图像边缘，进行抗拒齿处理；</li>
</ol>
<h2 id="基础步骤">基础步骤：</h2>
<ol>
<li><strong>采样屏幕颜色，转换至亮度；</strong><br>
Nvidia建议使用red以及green通道来计算亮度进行优化，人眼对这两种颜色最为敏感；亮度计算方法如下：</li>
</ol>
<pre><code class="language-c++">float FxaaLuma(float3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; }
</code></pre>
<ol start="2">
<li><strong>根据亮度来计算对比度，用对比度来作为边缘检测的标准；</strong><br>
一般边缘检测都会使用<strong>当前像素</strong>，以及<strong>上下左右四个像素</strong>来进行对比度的计算；当对比度大于某个阈值时，认为当前点处于边缘位置；</li>
</ol>
<pre><code class="language-c++">float3 rgbN  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0,-1)).xyz;
float3 rgbW  = FxaaTextureOffset(tex, pos.xy, FxaaInt2(-1, 0)).xyz;
float3 rgbM  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0, 0)).xyz;
float3 rgbE  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 1, 0)).xyz;
float3 rgbS  = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0, 1)).xyz;
float lumaN  = FxaaLuma(rgbN);
float lumaW  = FxaaLuma(rgbW);
float lumaM  = FxaaLuma(rgbM);
float lumaE  = FxaaLuma(rgbE);
float lumaS  = FxaaLuma(rgbS);
float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));
float range = rangeMax -rangeMin;
if(range &lt; max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * XAA_EDGE_THRESHOLD))           {return FxaaFilterReturn(rgbM); }
</code></pre>
<ol start="3">
<li><strong>边缘的横纵向检测，用于后续抗拒齿处理；</strong><br>
边缘进行光栅化之后，在比较小的维度上，只有横向边缘与纵向边缘之分；检测出来横向与纵向，可以便于后续沿边缘进行延伸；</li>
</ol>
<pre><code class="language-c++">float edgeVert = abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));
float edgeHorz = abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));
bool horzSpan = edgeHorz &gt;= edgeVert;   //判断当前像素位于横向边缘还是纵向边缘
</code></pre>
<p>4.** 判断真正的边缘边界位置，并将当前点定位到真正的边缘边界处；**<br>
检测出横向还是纵向后，需要定位边缘边界是在上横向还是下横向，左横向还是右横向；<br>
当前点是在像素中心，定位出边缘边界（位于两个像素的交接处）后，即可将当前点移动到边缘边界；</p>
<pre><code class="language-c++">// 梯度最大处作为边缘边界的位置；
float luma1 = isHorizontal ? lumaDown : lumaLeft;
float luma2 = isHorizontal ? lumaUp : lumaRight;
float gradient1 = luma1 - lumaCenter;
float gradient2 = luma2 - lumaCenter;
bool is1Steepest = abs(gradient1) &gt;= abs(gradient2);

// 我也不清楚此处为什么要用0.25来进行normalize，感觉就是一个简单的factor；
float gradientScaled = 0.25*max(abs(gradient1),abs(gradient2));

float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;

//边缘边界处（计算像素相交处）的亮度平均值
float lumaLocalAverage = 0.0;
if(is1Steepest){
    stepLength = - stepLength;
    lumaLocalAverage = 0.5*(luma1 + lumaCenter);
} else {
    lumaLocalAverage = 0.5*(luma2 + lumaCenter);
}

// 将uv移动半个像素，定位到边缘边界处（像素相交处）.
vec2 currentUv = In.uv;
if(isHorizontal){
    currentUv.y += stepLength * 0.5;
} else {
    currentUv.x += stepLength * 0.5;
}
</code></pre>
<ol start="5">
<li>定位到边界处，需要沿边缘方向（横向或纵向）进行搜索，来计算当前边缘的长度；<br>
之所以计算边缘的长度，是因为锯齿一般都出现在边缘端点处；离端点越远，越不容易产生锯齿；我们需要计算当前边缘边界距边缘端点的距离，用来计算锯齿的强弱程度；</li>
</ol>
<pre><code class="language-c++">// 第一步迭代
vec2 offset = isHorizontal ? vec2(inverseScreenSize.x,0.0) : vec2(0.0,inverseScreenSize.y);
vec2 uv1 = currentUv - offset;
vec2 uv2 = currentUv + offset;

float lumaEnd1 = rgb2luma(texture(screenTexture,uv1).rgb);
float lumaEnd2 = rgb2luma(texture(screenTexture,uv2).rgb);
lumaEnd1 -= lumaLocalAverage;
lumaEnd2 -= lumaLocalAverage;

bool reached1 = abs(lumaEnd1) &gt;= gradientScaled;
bool reached2 = abs(lumaEnd2) &gt;= gradientScaled;
bool reachedBoth = reached1 &amp;&amp; reached2;

if(!reached1){
    uv1 -= offset;
}
if(!reached2){
    uv2 += offset;
}  

// 继续后面的迭代
if(!reachedBoth){

    for(int i = 2; i &lt; ITERATIONS; i++){
        if(!reached1){
            lumaEnd1 = rgb2luma(texture(screenTexture, uv1).rgb);
            lumaEnd1 = lumaEnd1 - lumaLocalAverage;
        }
        if(!reached2){
            lumaEnd2 = rgb2luma(texture(screenTexture, uv2).rgb);
            lumaEnd2 = lumaEnd2 - lumaLocalAverage;
        }
        reached1 = abs(lumaEnd1) &gt;= gradientScaled;
        reached2 = abs(lumaEnd2) &gt;= gradientScaled;
        reachedBoth = reached1 &amp;&amp; reached2;

        // 此处QUALITY为迭代步进的缩放系数，一般前5步为1，后面可逐渐递增
        if(!reached1){
            uv1 -= offset * QUALITY(i);
        }
        if(!reached2){
            uv2 += offset * QUALITY(i);
        }

        if(reachedBoth){ break;}
    }
}
</code></pre>
<ol start="6">
<li>偏移（此偏移量作用于最初uv，用于最终采样）估算<br>
前面说到越靠近边缘终点，锯齿越严重，那么最终像素输出采样点的偏移量越大；与此相反，越靠近边缘中点，输出采样点的偏移量越小；算法如下：</li>
</ol>
<pre><code class="language-c++">// 使用边缘边界点与边缘终点的距离处于边缘的长度来计算offset
float distance1 = isHorizontal ? (In.uv.x - uv1.x) : (In.uv.y - uv1.y);
float distance2 = isHorizontal ? (uv2.x - In.uv.x) : (uv2.y - In.uv.y);
bool isDirection1 = distance1 &lt; distance2;
float distanceFinal = min(distance1, distance2);
float edgeThickness = (distance1 + distance2);
float pixelOffset = - distanceFinal / edgeThickness + 0.5;

// 添加额外的判断，来保证端点处的走势（gradient）与中心处的一致
bool isLumaCenterSmaller = lumaCenter &lt; lumaLocalAverage;
bool correctVariation = ((isDirection1 ? lumaEnd1 : lumaEnd2) &lt; 0.0) != isLumaCenterSmaller;
float finalOffset = correctVariation ? pixelOffset : 0.0;
</code></pre>
<ol start="7">
<li>子像素抗拒齿处理<br>
使用额外的步骤即可处理子像素抗拒齿（即细线引起的锯齿，或点引起的锯齿，我也不知道为啥叫做子像素锯齿==）；<br>
基本思路是计算中心点与周围点的差值，然后计算此差值与局部差值的比值来计算子像素抗拒齿的偏移量；最终选择较大偏移量作为最终采样值；</li>
</ol>
<pre><code class="language-c++">float lumaAverage = (1.0/12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);
float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter)/lumaRange,0.0,1.0);
float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;
float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * SUBPIXEL_QUALITY;

// Pick the biggest of the two offsets.
finalOffset = max(finalOffset,subPixelOffsetFinal);
</code></pre>
<ol start="8">
<li>使用最终偏移量进行采样;</li>
</ol>
<pre><code class="language-c++">vec2 finalUv = In.uv;
if(isHorizontal){
    finalUv.y += finalOffset * stepLength;
} else {
    finalUv.x += finalOffset * stepLength;
}

vec3 finalColor = texture(screenTexture,finalUv).rgb;
fragColor = finalColor;
</code></pre>
<p>注意点：FXAA运行在sRGB空间；直接作用于linear、hdr数据，会出现闪烁问题；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity中序列化Asset的修改]]></title>
        <id>https://wingstone.github.io/post/unity-zhong-xu-lie-hua-asset-de-xiu-gai/</id>
        <link href="https://wingstone.github.io/post/unity-zhong-xu-lie-hua-asset-de-xiu-gai/">
        </link>
        <updated>2021-02-28T15:31:35.000Z</updated>
        <content type="html"><![CDATA[<p>代码片段事例：</p>
<pre><code>        Object obj = new Object();
        SerializedObject so = new SerializedObject(obj);     //这里obj为要进行序列化操作的asset对象
        SerializedProperty sp = so.FindProperty(&quot;property&quot;);    //这里property为要进行操作的property，需要查看asset文件获取
        sp.boolValue = true;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种常用渲染技术文章集合]]></title>
        <id>https://wingstone.github.io/post/ge-chong-chang-yong-xuan-ran-ji-zhu-wen-zhang-ji-he/</id>
        <link href="https://wingstone.github.io/post/ge-chong-chang-yong-xuan-ran-ji-zhu-wen-zhang-ji-he/">
        </link>
        <updated>2020-11-11T13:52:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="localcubemap">LocalCubemap</h2>
<p><a href="https://armkeil.blob.core.windows.net/developer/Files/pdf/graphics-and-multimedia/ImplementingReflectionsinUnityUsingLocalCubemaps.pdf">ImplementingReflectionsinUnityUsingLocalCubemaps PDF</a><br>
<a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity">Reflections Based on Local Cubemaps in Unity Web</a></p>
<h2 id="clearcoat">ClearCoat</h2>
<p><a href="https://google.github.io/filament/Filament.html#materialsystem/clearcoatmodel">Clear coat model in filament Web</a></p>
<h2 id="cloud-in-sky">Cloud In Sky</h2>
<p><a href="http://walkingfat.com/bump-noise-cloud-3d%e5%99%aa%e7%82%b9gpu-instancing%e5%88%b6%e4%bd%9c%e5%9f%ba%e4%ba%8e%e6%a8%a1%e5%9e%8b%e7%9a%84%e4%bd%93%e7%a7%af%e4%ba%91/">Bump Noise Cloud – 3D噪点+GPU instancing制作基于模型的体积云 Web</a><br>
<a href="https://blog.csdn.net/qq_33967521/article/details/102657017">浅谈《Sky 光·遇》中的渲染技术 Web</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[景深的实现技术]]></title>
        <id>https://wingstone.github.io/post/jing-shen-de-shi-xian-ji-zhu/</id>
        <link href="https://wingstone.github.io/post/jing-shen-de-shi-xian-ji-zhu/">
        </link>
        <updated>2020-10-20T08:47:41.000Z</updated>
        <content type="html"><![CDATA[<p>景深的实现技术有很多，针对不同的使用场景，可以使用不同的方法；</p>
<h2 id="基于光线追踪的景深效果离线">基于光线追踪的景深效果（离线）</h2>
<p>基于光线追踪的景深效果，直接使用薄透镜模型，在透镜上面进行多采样即可实现景深效果；</p>
<p>关于薄透镜理论的使用，可以参考这里<a href="https://zhuanlan.zhihu.com/p/23827065">基于摄影参数渲染</a>;</p>
<h2 id="基于累积贴图的景深效果实时">基于累积贴图的景深效果（实时）</h2>
<p>大致思路为，将相机进行移动（可按照透镜多采样的方式移动），沿焦平面进行多个相机的渲染，然后将渲染结果进行累加，这样就能获取与光线追踪类似的效果；本质上类似于光线追踪的多采样方式，但需要花费大量的DC，一般只用来验证；</p>
<h2 id="基于分层绘制的景深效果实时">基于分层绘制的景深效果（实时）</h2>
<p>本质上，是基于2D图层的方式来实现；将场景按深度进行分层绘制，然后将远离焦距的绘制rt记性模糊，然后按层进行混合，即可获取接近景深的效果；</p>
<p>使用要求时，不同的景物之间不能有交叉，即物体不能有太强的深度变化；因为针对单个物体是无法产生即聚焦又失焦的现象；</p>
<h2 id="基于前向映射的z-buffer的景深效果实时">基于前向映射的Z-buffer的景深效果（实时）</h2>
<p>此方法常用在后处理效果中，该方法存储颜色缓冲与深度缓冲作为最后的blit对象；然后使用深度缓冲计算COC（circle of confusion），即点投影在屏幕上形成的弥散圆；再然后利用弥散圆进行模糊与blend，这里模糊并不是通常意义上的模糊，模糊需要的圆盘采样与普通模糊一致，但是采样的判定需要根据采样点的COC是否能覆盖到当前点，来确定该采样点的弥散圆是否对当前点有贡献；GPU Gems中说blend只能混合到距离摄像机比自己远的那些相邻像素中，以避免模糊的像素影响它们前面的清晰像素。实际上，blend的是为了避免前面模糊造成聚焦物体边缘的消失；</p>
<h2 id="基于反向映射的z-buffer的景深效果实时">基于反向映射的Z-buffer的景深效果（实时）</h2>
<p>该方法与上一种技术类似，区别在于并不是通过blend来形成最后的图像，而是通过使用深度值距焦距的距离来进行blur，从而形成最终的效果；这里把当前点的弥散圆当做模糊范围来进行计算了，与实际的PBR有些偏差，但也能凑活使用；</p>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/depth-of-field/">Depth of Field</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-23-depth-field-survey-techniques">Depth of Field: A Survey of Techniques</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23827065">基于摄影参数渲染</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/146143501">渲染中的景深(Depth of Field/DOF)</a></li>
<li><a href="https://epicgames.ent.box.com/s/s86j70iamxvsuu6j35pilypficznec04">A Life of a Bokeh - SIGGRAPH 2018</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后处理技术——景深]]></title>
        <id>https://wingstone.github.io/post/hou-chu-li-ji-zhu-jing-shen/</id>
        <link href="https://wingstone.github.io/post/hou-chu-li-ji-zhu-jing-shen/">
        </link>
        <updated>2020-10-20T08:05:48.000Z</updated>
        <content type="html"><![CDATA[<p>景深是能体现场景纵深的重要效果，同时还能虚化前景与背景，这样可以让玩家将注意力集中在聚焦物体上；</p>
<h2 id="实现步骤">实现步骤</h2>
<h3 id="提取coc">提取COC</h3>
<p>所谓COC即circle of confusion，表示一点投影在屏幕上所形成的弥散圆。可知，焦距上的点仍然会形成点，而远离焦距的点则会形成弥散圆；</p>
<p>一般将COC的半径存储为rt，此半径需要根据焦距（focus distance）以及焦距范围（focus range）来进行计算；</p>
<h3 id="计算散景效果">计算散景效果</h3>
<p>实际上就是使用圆形范围的模糊效果来进行RT的blit；这里模糊并不是通常意义上的模糊，模糊需要的圆盘采样与普通模糊一致，但是采样的判定需要根据采样点的COC是否能覆盖到当前点，来确定该采样点的弥散圆是否对当前点有贡献（GPU Gems中说blend只能混合到距离摄像机比自己远的那些相邻像素中，以避免模糊的像素影响它们前面的清晰像素。）；</p>
<p>考虑到采样所带来的的效率问题，一般都会讲rt进行降采样处理；同样的COC也要记性降采样，才可以使用，一般会将其存储至rt的alpha通道；</p>
<p>一般散景模糊主要考虑的就是效率问题，可以采用其他的途径来获取相应效果；毕竟只是实现模糊就有很多种不同方法；</p>
<h3 id="与物模糊背景进行融合">与物模糊背景进行融合</h3>
<p>计算散景效果时，对于聚焦物体的边缘部分，还是会产生模糊问题；为了比较这种问题产生，只能使用blend方法，将这些区域恢复为原来的无模糊图像；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[天空渲染——大气物理]]></title>
        <id>https://wingstone.github.io/post/tian-kong-xuan-ran-da-qi-wu-li/</id>
        <link href="https://wingstone.github.io/post/tian-kong-xuan-ran-da-qi-wu-li/">
        </link>
        <updated>2020-10-10T07:38:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="大气物理现象">大气物理现象</h2>
<p>假设1：空气密度随着高度成指数进行衰减；即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>=</mo><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>(</mo><mn>0</mn><mo>)</mo><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>h</mi><mi>H</mi></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">density(h) = density(0)e^{-\frac{h}{H}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.27902em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.02902em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中density(0)为海平面密度，h为当前高度，H为scale height，随温度变化；不是所有的人都采用这种模型，另一种密度假设为分层模型，每一层采用不同的大气密度；</p>
<p>大气分子散射主要可分为<strong>空气分子散射（Rayleigh scattering，小于光线波长）<strong>与</strong>气溶胶散射（Mie scattering，大于光线波长）</strong>；空气分子散射主要会产生天空的蓝色成分与橘黄色成分（日出、日落时分），气溶胶散射主要会导致灰白色条带（特别是污染都市上空）；</p>
<p>在进行光追计算时，还需要进行地球半径的假设，以及大气层半径的假设；我们假设地球半径为6360 km，大气半径为6420 km，此外还需要假设太阳光为平行光，因为太阳距地球足够远；</p>
<p>计算的过程中需要注意量纲的统一，一般都去Km；</p>
<p>熟悉体渲染的人应该知道，物体的体渲染熟悉可以用散射系数（针对外散射）、吸收系数、相位函数（针对内散射）进行描述，我们这里忽略大气吸收的过程，即忽略吸收系数的计算；</p>
<h2 id="rayleigh-scattering">Rayleigh scattering</h2>
<p>Rayleigh scattering具有很强的波长依赖性，散射蓝光比绿光和红光具有更高的精确性；</p>
<p>Rayleigh首先提出了计算此现象的公式，他给出了散射系数的公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>λ</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mn>8</mn><msup><mi>π</mi><mn>3</mn></msup><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow><mrow><mn>3</mn><mi>N</mi><msup><mi>λ</mi><mn>4</mn></msup></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>h</mi><msub><mi>H</mi><mi>R</mi></msub></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">{\beta}_R^s(h, \lambda) = \frac{8\pi^3(n^2-1)^2}{3N\lambda^4}e^{-\frac{h}{H_R}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.133835em;"><span style="top:-3.5178149999999997em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.6559999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:-0.08125em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833299999999998em;"></span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.33853em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5858071428571429em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这里<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>表示波长，N表示大气分子密度，n为大气折射率，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">H_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>即为前面的scale height，此处我们取8Km；</p>
<p>参考文献中N与n并没有给出相应的参数，但是给出了相应的散射系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup><mo>=</mo><mo>(</mo><mn>5.8</mn><mo separator="true">,</mo><mn>13.5</mn><mo separator="true">,</mo><mn>33.1</mn><mo>)</mo><mn>1</mn><msup><mn>0</mn><mo>−</mo></msup><mn>6</mn><msup><mi>m</mi><mo>−</mo></msup><mn>1</mn></mrow><annotation encoding="application/x-tex">\beta^s_R=(5.8, 13.5, 33.1)10^-6m^-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9697709999999999em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">.</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">6</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">1</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mo>(</mo><mn>680</mn><mo separator="true">,</mo><mn>550</mn><mo separator="true">,</mo><mn>440</mn><mo>)</mo><mi>n</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">\lambda=(680, 550, 440)nm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">8</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">5</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mord">0</span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span></span></span></span>；</p>
<p>渲染使用的extinction coefficient为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>e</mi></msubsup><mo>=</mo><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup></mrow><annotation encoding="application/x-tex">\beta_R^e = \beta_R^s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>相位函数的公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>R</mi></msub><mo>(</mo><mi>μ</mi><mo>)</mo><mo>=</mo><mfrac><mn>3</mn><mrow><mn>16</mn><mi>π</mi></mrow></mfrac><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>μ</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">P_R(\mu)=\frac{3}{16\pi}(1+\mu^2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>表示光线与视角的夹角；</p>
<h2 id="mie-scattering">Mie Scattering</h2>
<p>与Rayleigh Scattering类似，其散射公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>M</mi><mi>s</mi></msubsup><mo>(</mo><mi>h</mi><mo separator="true">,</mo><mi>λ</mi><mo>)</mo><mo>=</mo><msubsup><mi>β</mi><mi>M</mi><mi>s</mi></msubsup><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>λ</mi><mo>)</mo><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>h</mi><msub><mi>H</mi><mi>M</mi></msub></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\beta_M^s(h,\lambda)=\beta_M^s(0,\lambda) e^{-\frac{h}{H_M}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.383835em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.133835em;"><span style="top:-3.5178149999999997em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.6559999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:-0.08125em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833299999999998em;"></span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.33853em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5858071428571429em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">H_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>通常取1.2Km；同样类似于Rayleigh Scattering，气溶胶密度也随高度进行指数衰减，我们直接取散射系数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>M</mi><mi>s</mi></msubsup><mo>=</mo><mn>210</mn><mi>x</mi><mn>1</mn><msup><mn>0</mn><mo>−</mo></msup><mn>5</mn><msup><mi>m</mi><mo>−</mo></msup><mn>1</mn></mrow><annotation encoding="application/x-tex">\beta^s_M=210x10^-5m^-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9697709999999999em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">1</span></span></span></span>；</p>
<p>渲染使用的extinction coefficient为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>β</mi><mi>R</mi><mi>e</mi></msubsup><mo>=</mo><mn>1.1</mn><msubsup><mi>β</mi><mi>R</mi><mi>s</mi></msubsup></mrow><annotation encoding="application/x-tex">\beta_R^e = 1.1\beta_R^s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>相位函数为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>M</mi></msub><mo>(</mo><mi>μ</mi><mo>)</mo><mo>=</mo><mfrac><mn>3</mn><mrow><mn>8</mn><mi>π</mi></mrow></mfrac><mfrac><mrow><mo>(</mo><mn>1</mn><mo>−</mo><msup><mi>g</mi><mn>2</mn></msup><mo>)</mo><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>μ</mi><mn>2</mn></msup><mo>)</mo></mrow><mrow><mo>(</mo><mn>2</mn><mo>+</mo><msup><mi>g</mi><mn>2</mn></msup><mo>)</mo><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>g</mi><mn>2</mn></msup><mo>−</mo><mn>2</mn><mi>g</mi><mi>μ</mi><msup><mo>)</mo><mfrac><mn>3</mn><mn>2</mn></mfrac></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">P_M(\mu)=\frac{3}{8\pi}\frac{(1-g^2)(1+\mu^2)}{(2+g^2)(1+g^2-2g\mu)^{\frac{3}{2}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.570678em;vertical-align:-1.07957em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.17043em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.93957em;"><span style="top:-3.3485500000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.07957em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>项用来控制介质的各向异性，一般取0.76；</p>
<h2 id="reference">Reference</h2>
<p><a href="https://www.ea.com/frostbite/news/physically-based-sky-atmosphere-and-cloud-rendering">寒霜引擎天空渲染实现</a></p>
<p><a href="https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky">Simulating the Colors of the Sky</a></p>
<p><a href="http://www-ljk.imag.fr/Publications/Basilic/com.lmc.publi.PUBLI_Article@11e7cdda2f7_f64b69/article.pdf">Precomputed Atmospheric Scattering</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软阴影技术——PCF、ESM、VSM、CSM、PCSS]]></title>
        <id>https://wingstone.github.io/post/yin-ying-ji-zhu-pcfesmvsmpcss/</id>
        <link href="https://wingstone.github.io/post/yin-ying-ji-zhu-pcfesmvsmpcss/">
        </link>
        <updated>2020-09-30T15:39:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pcfpercentage-closer-filtering">PCF（Percentage-Closer Filtering）</h2>
<p>就是对阴影结果进行滤波，这里的阴影结果指阴影测试函数所得的结果；一般采用双线性滤波，此时可以使用硬件PCF来进行插值；</p>
<h3 id="实现要求">实现要求</h3>
<p>Depth格式的shadow map或者ShadowMap格式的shadow map；</p>
<h2 id="esmexponential-shadow-maps">ESM（Exponential Shadow Maps）</h2>
<p>PCF方法对阴影结果进行滤波，无法集成到阴影测试函数中；因此可以采用其他的阴影测试函数来进行实现软阴影效果；</p>
<p>ESM采用指数空间下的深度测试函数来代替传统的深度测试函数；</p>
<p>采用ESM方法，存储的为指数空间下的阴影数值，支持预滤波，这样就可以对shadowmap进行blur，将滤波与测试函数进行分离；</p>
<p>传统shadowmap存储的为深度z，而在ESM中存储的为<code>exp(c*z)</code>，即深度值的指数形式；其中c表示指数常数，对于32位存储格式，极限值为88；</p>
<p>而阴影测试函数，传统的shadowmap为<code>step(d, z)</code>，而ESM的阴影测试函数则变为<code>exp(-cd)*tz</code>；其中tz表示采样的指数深度值，即<code>exp(c*z)</code>，这样原来的<code>z-d</code>转变为了<code>exp(c(z-d))</code>；</p>
<h3 id="所带来的问题有">所带来的问题有：</h3>
<ol>
<li>计算出来的阴影值与shadow caseter、shadow receiver之间的距离有关，距离越远，阴影越黑，越近，阴影越接近于无；</li>
<li>多重阴影下，肯会由于shadow map精度问题产生瑕疵；</li>
<li>对rt精度要求比较高；</li>
</ol>
<h3 id="实现需求">实现需求</h3>
<p>一张Depth格式的shadow map即可，需要手动对其进行模糊；</p>
<h2 id="renference">Renference</h2>
<ol>
<li>《实时阴影技术》 艾森曼努；</li>
<li><a href="https://zhuanlan.zhihu.com/p/26853641">实时渲染中的软阴影技术</a></li>
<li><a href="http://www.klayge.org/2013/10/07/%e5%88%87%e6%8d%a2%e5%88%b0esm/">切换到esm</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[贴图技术——Parallax Mapping（视差贴图）]]></title>
        <id>https://wingstone.github.io/post/texture-technique-parallax-mappingshi-chai-tie-tu/</id>
        <link href="https://wingstone.github.io/post/texture-technique-parallax-mappingshi-chai-tie-tu/">
        </link>
        <updated>2020-09-30T05:10:15.000Z</updated>
        <content type="html"><![CDATA[<p>视差贴图属于位移贴图(Displacement Mapping)技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一般使用位移贴图之前，需要对模型进行细分（细分着色器），然后进行顶点位移；</p>
<p>位移贴图要想有好的效果，需要大量顶点支持，而使用视差贴图即可省去大量的顶点使用；</p>
<p>视差贴图的原理实际上是对采样纹理坐标进行偏移，而偏移的原理根据视角观察高度图的真实过程进行模拟，因此可以模拟出真实的贴图凹凸遮挡关系；</p>
<p>在实际的使用过程中，一般使用 <strong>深度图来代替高度图</strong> ，两种互为反相；</p>
<h2 id="parallax-mapping">Parallax mapping</h2>
<p>最原始视差贴图方法就叫Parallax mapping，其大概原理是：在切线空间下，当前采样坐标获得的高度作为V向量偏移的长度，然后偏移后的长度在切平面的投影即为坐标的偏移量</p>
<pre><code class="language-C++">//_ParallaxHeight为一控制参数
uv -= tex2D(_HightMap, uv)*TV.xy*_ParallaxHeight;     //V向量为切空间下的向量
</code></pre>
<p>在高度图变化比较剧烈的地方，采用这种方法会有很对问题；因此又发展出了Steep Parallax Mapping（陡峭视差贴图）；</p>
<h2 id="steep-parallax-mapping">Steep Parallax Mapping</h2>
<p>对于高度变化剧烈地方，其实很难通过一步就定位到偏移后的位置，陡峭视差贴图方法实际上就是ray matching方法，使用此方法可以更精确的定位到偏移后位置；但由于ray matching算法的性质，在计算量不足的情况下，容易出现分层的痕迹；针对分层问题，后面提出了Parallax Occlusion Mapping(视差遮蔽映射)方法；</p>
<p>该算法首先将深度值进行分层，每一步递进一层；若当前步所获取深度值与步进深度值的差值的符号，与前一步相反，则可定位当前层深度即为偏移深度；分层数量越多，计算量越大，计算结果越精细；</p>
<pre><code class="language-C++">float numLayers = 10;
float depthStep = 1.0 / numLayers;
float currentDepth = 0.0;
float2 uvStep = TV.xy * _ParallaxHeight/ numLayers; 
float currentDepthMapValue = tex2D(_DepthTex, uv).r;

for(int i = 0; i&lt; 10; i++)
{
    if(currentDepth &gt; currentDepthMapValue)
        break;
    uv -= uvStep;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    currentDepth += depthStep;  
}
</code></pre>
<h2 id="parallax-occlusion-mapping">Parallax Occlusion Mapping</h2>
<p>视差遮蔽贴图与陡峭视差贴图类似，区别仅在于最后深度的选择；陡峭视差贴图最终的深度为步进深度的倍数，并且最终深度大于此位置的采样深度，而前一步的深度小于前一步位置的采样深度；针对此现象，我们可以在两者之间进行深度插值，这样最终采样深度就是一个连续的分布了；</p>
<p>插值的根本原理就是相似三角形原理；代码如下，示意图请看参考引用；</p>
<pre><code class="language-C++">float numLayers = 10;
float depthStep = 1.0 / numLayers;
float currentDepth = 0.0;
float2 uvStep = TV.xy * _ParallaxHeight/ numLayers; 
float currentDepthMapValue = tex2D(_DepthTex, uv).r;

float preDiff = 1e-5;       //防止除0
for(int i = 0; i&lt; 10; i++)
{
    if(currentDepth &gt;= currentDepthMapValue)
    {
        float curDiff = currentDepth-currentDepthMapValue;
        uv -= uvStep*preDiff/(curDiff+preDiff);
        break;
    }
    else
        preDiff = currentDepthMapValue - currentDepth;
    uv -= uvStep;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    currentDepth += depthStep; 
}
</code></pre>
<h2 id="relief-mapping">Relief Mapping</h2>
<p>视差遮蔽贴图在最后的一步采用插值进行计算，本质上是采用线性分布模拟步进深度中的非线性深度分布；因此最好的方法就是采用更细的步进深度进行测试，但这样就要求需要有大量的步进运算；因此可采用二分法方法来进行步进，这样可以更快定位到相交的深度；但是二分法要求单调性，实际的深度分布不可能是但单调分布的，因此最佳的步进方法为，先进行大步进深度的传统线性步进，再进行二分步进，这就是Relief Mapping的中心思想；</p>
<pre><code class="language-C++">//linear rematching
float numLayers = 10;
float depthStep = 1.0 / numLayers;
float currentDepth = 0.0;
float2 uvStep = TV.xy * _ParallaxHeight/ numLayers; 
float currentDepthMapValue = tex2D(_DepthTex, uv).r;

for(int i = 0; i&lt; 10; i++)
{
    if(currentDepth &gt; currentDepthMapValue)
    {
        break;
    }
    uv -= uvStep;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    currentDepth += depthStep;  
}

//binary rematching
for(int i = 0; i&lt; 8; i++)
{
    uvStep *= 0.5;
    depthStep *= 0.5;
    currentDepthMapValue = tex2D(_DepthTex, uv).r;
    if(currentDepth &lt; currentDepthMapValue)
    {
        uv -= uvStep;
        currentDepth += depthStep;
    }
    else
    {
        uv += uvStep;
        currentDepth -= depthStep;
    }
}
</code></pre>
<p>实际上，深度图的使用原理，与地形及其类似；确定好视线与深度相交点后，就可以沿光源方向进行阴影计算，<a href="https://shintaroiguchidotcom.files.wordpress.com/2016/01/relief-mapping-in-a-pixel-shader-using-binary-search.pdf">PDF：Relief Mapping</a>这篇文章也提到了使用深度图进行自投影的计算；</p>
<p>关于使用raymatching方法进行地形的渲染，可以参考<a href="https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm">iq：raymarching terrains</a>，读完后相应对于视差贴图的理解可以更深一步；</p>
<h2 id="个人思考">个人思考</h2>
<p>从结果上来看，确实算法越来越精确了，但是都要有一个严重的问题：如下图所示：<br>
<img src="https://wingstone.github.io/post-images/1601477127814.jpg" alt="实际运行图片" loading="lazy"><br>
可以看出，在视差起作用的边界处，出现了明显的锯齿，感觉如何解决这个要命的问题才是当下需要着重研究的；</p>
<h2 id="参考">参考</h2>
<p><a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">learnopengl：Parallax-Mapping</a><br>
<a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/">learnopengl中文版：Parallax-Mapping</a><br>
<a href="https://shintaroiguchidotcom.files.wordpress.com/2016/01/relief-mapping-in-a-pixel-shader-using-binary-search.pdf">PDF：Relief Mapping</a><br>
<a href="https://en.wikipedia.org/wiki/Parallax_mapping">Wiki：Parallax mapping</a></p>
]]></content>
    </entry>
</feed>