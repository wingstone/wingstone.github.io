<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wingstone.github.io</id>
    <title>CG黑魔法作坊</title>
    <updated>2020-09-18T08:11:25.560Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wingstone.github.io"/>
    <link rel="self" href="https://wingstone.github.io/atom.xml"/>
    <subtitle>分享与记录关于CG技术的一切</subtitle>
    <logo>https://wingstone.github.io/images/avatar.png</logo>
    <icon>https://wingstone.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CG黑魔法作坊</rights>
    <entry>
        <title type="html"><![CDATA[移动GPU架构]]></title>
        <id>https://wingstone.github.io/post/yi-dong-gpu-jia-gou/</id>
        <link href="https://wingstone.github.io/post/yi-dong-gpu-jia-gou/">
        </link>
        <updated>2020-09-17T05:30:09.000Z</updated>
        <content type="html"><![CDATA[<p>移动GPU架构经常被称之为TBDR（Tiled Based Deferred Rendering），我们这里也以TBDR代称；实际上移动架构有TBR与TBDR两种，为什么都被称之为TBDR，可以看这篇<a href="https://zhuanlan.zhihu.com/p/112120206">文章</a>；我们这里使用TBDR来指整个移动GPU架构都包含的TBR特点；</p>
<h2 id="移动tbdr架构与桌面imr架构">移动TBDR架构与桌面IMR架构</h2>
<h3 id="imr架构">IMR架构</h3>
<p>IMR（Immediate Mode Rendering）就如字面意思一样，提交的每个渲染命令都会立即开始执行，并且该渲染命令会在整条流水线中执行完毕后才开始执行下一个渲染命令。</p>
<p>IMR的渲染会存在浪费带宽的情况。例如，当两次渲染有前后遮蔽关系时，IMR模式因为两次draw命令都要执行，因此会存在经过Pixel Shader后的Pixel被Depth test抛弃，这样就浪费了Shader Unit运算能力。不过幸运的是，目前几乎所有的IMR架构的GPU都会提供Early Z的判断方式，一般是在Rasterizer里面对图形的遮蔽关系进行判断，如果需要渲染的图形被遮挡住，那么就直接抛弃该图形而不需要执行Pixel Shader。</p>
<p>IMR的另外一个缺点就是其渲染命令在执行需要随时读写frame buffer，depth buffer和stencil buffer，这带来大量的内存带宽消耗，在移动平台上面访问片外内存是最消耗电量和最耗时的操作。</p>
<h3 id="tbdr架构">TBDR架构</h3>
<p>移动端的硬件在设计最开始想到的最重要的问题就是功耗，功耗意味着发热量，意味着耗电量，意味着芯片大小…所以gpu也是把功耗摆在第一位，然而在gpu的渲染过程中，对功耗影响最大的是带宽；</p>
<p>每渲染一帧图像，对FrameBuffer的访问量是惊人的（各种test，blend，再算上MSAA, overdraw等等），通常gpu的onchip memory（也就是SRAM，或者L1 L2 cache）很小，这么大的FrameBuffer要存储在离gpu相对较远的DRAM（显存）上，可以把gpu想象成你家，SRAM想象成小区便利店，DRAM想象成市中心超市，从gpu对framebuffer的访问就相当于一辆货车大量的在你家和市中心之间往返运输，带宽和发热量之巨大是手机上无法接受的。</p>
<p><strong>TBDR一般的实现策略</strong>是对于cpu过来的commandbuffer，只对他们做vetex process，然后<strong>对vs产生的结果暂时保存</strong>，等待非得刷新整个FrameBuffer的时候，才真正的随这批绘制做光栅化，做tile-based-rendering。什么是非得刷新整个FrameBuffer的时候？比如Swap Back and Front Buffer，glflush，glfinish，glreadpixels，glcopytexiamge，glbitframebuffer，queryingocclusion，unbind the framebuffer。总之是所有gpu觉得不得不把这块FrameData绘制好的时候。</p>
<p>FrameData这个是tbr特有的在gpu绘制时所需的存储数据，在powervr上叫做arguments buffer，在arm上叫做plolygon lists。</p>
<p>于是移动端的gpu想到了一种化整为零的方法，把巨大的FrameBuffer分解成很多小块，使得每个小块可以被离gpu更近的那个SRAM可以容纳，块的多少取决于你的硬件的SRAM的大小。这样gpu可以分批的一块块的在SRAM上访问framebuffer，一整块都访问好了后整体转移回DRAM上。</p>
<h3 id="对比">对比</h3>
<p>那么为什么pc不使用tbr，这是因为实际上直接对DRAM上进行读写的速度是最快的，tbdr需要一块块的绘制然后回拷，可以说如果哪一天手机上可以解决带宽产生的功耗问题，或者说sram可以做的足够大了，那么就没有TBDR什么事了。可以简单的认为TBR牺牲了执行效率，但是换来了相对更难解决的带宽功耗。</p>
<h2 id="tbdr的重要特性">TBDR的重要特性</h2>
<h3 id="关于early-z">关于early-z</h3>
<p>因为tbdr有framedata队列，很多gpu会很聪明的尽量筛去不需要绘制的framedata。所以在tbdr上earlyz，或者stencil test这些是非常有益处的。例如你定义了一个stencil，gpu有可能在对framedata处理的过程中就筛掉了那些不能通过stencil的drawcall了。或者通过scissor test可能一整块tile都不需要绘制。</p>
<h3 id="blending和msaa的效率其实很高alpha-test效率很低">blending和MSAA的效率其实很高，alpha-test效率很低</h3>
<p>回头看下tbdr的渲染管线，对于一个tile上所有pixel的绘制都是在on-chip的mem上的，只在最后绘制好了才整体回拷给dram。所以我们通常认为会造成大量带宽的操作，例如blending（对framebuffer的读和写），msaa(增加对framebuffer读取的次数)其实在tbdr上反而是非常快速的。（当然msaa除了会造成framebuffer访问增多，还会带来渲染像素的数量增多，这个是tbr没什么优化的）</p>
<p>alpha-test这个东西，他对depth的写入是不能预先确定的，它必须等到pixel shader执行，这导致了alpha-test之后的那些framedata失去了early–z的机会，也就破坏了TBDR架构中的延迟渲染特性（FrameData必须进行ps处理，不能继续缓存），也就增加了渲染量。</p>
<h2 id="移动tbdr架构与render-pipeline中tbdr的区别">移动TBDR架构与Render Pipeline中TBDR的区别</h2>
<p>Render Pipeline中TBDR可以参考<a href="xuan-ran-guan-xian">这里</a>；RP中的TBDR指的光照渲染流程中，延迟光照的一种；为了减少DC，提高硬件利用效率；<strong>这里的延迟主要指</strong>：PS阶段光照的计算不立即计算，而是渲染到G-buffer中进行缓存，到最后使用的新的DC来使用G-buffer进行光照的计算（主要用于多光源下的渲染处理）；</p>
<p>移动TBDR架构指的是GPU所采用的的一种渲染架构，是GPU硬件上的延迟渲染流程的硬件实现；而且<strong>这里的延迟渲染主要指</strong>：VS到PS之间有一个硬件的framedata队列，来延迟PS的处理；</p>
<h2 id="reference">Reference</h2>
<p><a href="https://gameinstitute.qq.com/community/detail/103959">移动架构浅析</a><br>
<a href="https://zhuanlan.zhihu.com/p/112120206">移动设备GPU架构知识汇总</a><br>
<a href="https://gameinstitute.qq.com/community/detail/123220">针对移动端TBDR架构GPU特性的渲染优化</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[零散学习资源链接]]></title>
        <id>https://wingstone.github.io/post/ling-san-zi-yuan-lian-jie-ji-lu/</id>
        <link href="https://wingstone.github.io/post/ling-san-zi-yuan-lian-jie-ji-lu/">
        </link>
        <updated>2020-09-16T05:23:05.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/mrdoob/three.js/issues/10600">半透投影问题</a></p>
<p><a href="https://github.com/gkjohnson/unity-dithered-transparency-shader">dithered transparency / Screen-door transparency（扰动半透渲染技术）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[头发渲染之Kajiya model]]></title>
        <id>https://wingstone.github.io/post/tou-fa-xuan-ran-zhi-kajiya-model/</id>
        <link href="https://wingstone.github.io/post/tou-fa-xuan-ran-zhi-kajiya-model/">
        </link>
        <updated>2020-09-16T04:19:32.000Z</updated>
        <content type="html"><![CDATA[<p>关键点：采用多边形建模，进行深度排序修正渲染顺序（因为半透问题），AO去模拟自阴影，两层高光，采用Tangent向量代替N进行高光计算；</p>
<h2 id="采用多边形建模">采用多边形建模</h2>
<p>头发建模可分为发丝建模（关于发丝建模的渲染看<a href="https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-23-hair-animation-and-rendering-nalu-demo">这里</a>）与多边形建模两种，当今游戏界所大量采用的做法也是多边形建模；</p>
<ol>
<li>多边形建模有更低的几何复杂性，以至于有更高的排序效率；相比之下采用发丝建模需要大约100K-150K的发丝来构建，复杂度高很多；</li>
<li>采用多边形建模可以更加容易的集成到已有的渲染管线中去，基本已有的渲染管线都是处理的多边形模型；</li>
</ol>
<h2 id="高光计算">高光计算</h2>
<p>主要的高光计算都集成在下面这张PPT上；<br>
<img src="https://wingstone.github.io/post-images/1600411957731.jpg" alt="" loading="lazy"><br>
可以看出，kajiya计算模型与blin-phong模型比较类似，<strong>本质上都是采用pow(NdotH, specularity)来进行的高光计算</strong>；但是<strong>kajiya模型没有使用多边形几何的法线来作为法线计算，而是采用法线平面的概念来作为法线的代替计算</strong>；</p>
<blockquote>
<p>虽然几何是多边形，但是仍然将其作为发丝来看待，Tangent向量作为发丝的方向；而发丝的法线应该位于与发丝垂直的平面上，且发丝与此平面的交点作为法线的起点；</p>
</blockquote>
<p>法线平面即红色平面所显示的，法线平面中真正的法线，有T向量、H向量所决定的平面，与法线平面的交线来决定，我们将这里决定出来的法线用N1（区别于真正的多边形几何法线）来代替；由于T、H、N1都是单位向量，由几何关系可以得到<strong>N1dotH = sin(T,H)</strong>，到此，我们就可以使用T、H来进行高光计算了；</p>
<h2 id="模拟真正的头发高光">模拟真正的头发高光</h2>
<p>为了模拟头发真正的高光，还要基于对头发高光的观察进行部分假设，相应的观察假设在这张PPT上；<br>
<img src="https://wingstone.github.io/post-images/1600413042532.jpg" alt="" loading="lazy"></p>
<ol>
<li>头发有两层高光；</li>
<li>主高光切变流向朝向发梢；</li>
<li>次高光拥有头发的颜色，且切变流向发根；</li>
<li>次高光带有闪烁效果，即不是很连续；</li>
</ol>
<p>模拟两层高光比较简单，只需要计算两次高光即可；</p>
<p>如何模拟高光的切变流向，即一个位置偏向发梢，一个偏向发根；因为我们使用模型的T来计算的高光，要想改变高光位置，只能从T下手；AMD提供的方法为，使用N（这里是多边形几何的法线，不是法线平面中的法线N1）对T进行偏移；偏移量可以从贴图中进行采样，计算公式如下：</p>
<pre><code class="language-C++">float ShiftTangent(float3 T, float3 N, float shift)
{
    float3 shiftedT = T + shift * N;
    return normalize(shiftedT);
}
</code></pre>
<p>如下图：T'与T''是切变后的切向量；<br>
<img src="https://wingstone.github.io/post-images/1600414455694.jpg" alt="" loading="lazy"></p>
<blockquote>
<p>实质上，N对T的偏移，是模拟头发的起伏，即发丝方向突出多边形平面或凹陷多边形平面；</p>
</blockquote>
<p>次高光的闪烁效果模拟比较简单，只需要使用一个噪音纹理与次高光相乘即可；</p>
<h2 id="渲染排序问题">渲染排序问题</h2>
<p>由于头发具有半透效果，必须依据一定的顺序进行渲染才能得到正确的Blend效果；</p>
<h3 id="模型内部排序">模型内部排序</h3>
<p>由于模型是一簇一簇的，因为只要决定簇之间的排序即可；依据视线观看头发的顺序，可以依照发簇距离头皮的距离进行排序；让靠近头皮的发簇对应的Index buffer排在整个模型Index buffer的前面；这样模型内部的渲染顺序就完全正确了；</p>
<blockquote>
<p>修改Index buffer的顺序，可以由模型制作时合并的顺序来决定；也可以由程序进行单独处理；</p>
</blockquote>
<h3 id="渲染时的pass设置">渲染时的pass设置</h3>
<p>虽然使用模型内部排序就能解决发簇之间的渲染顺序问题，但是对于发簇内部的渲染顺序也需要控制，不然会会出现先绘制发簇前面，再绘制背面的问题；有时也会出现先看到靠近头皮的发簇，再看到远离头皮的发簇的情况，特别是针对女性的头发；</p>
<p>因此为了解决这些问题，需要引入多pass渲染来解决，如下图所示：<br>
<img src="https://wingstone.github.io/post-images/1600416013592.jpg" alt="" loading="lazy"></p>
<p>Pass1：开启深度测试为Less并写入，开启alpha test，cull back；<br>
Pass2：关闭深度写入，深度测试为Less，关闭alpha test，cull front；<br>
Pass2：开启深度深度测试为Less并写入，关闭alpha test，cull back；</p>
<h2 id="使用方案">使用方案</h2>
<ol>
<li>纹理需求：base tex（发色纹理，包含Scretched noise）、alpha tex（需包含全不透区域）、tangent shift tex（模拟头发起伏形状）、specular noise tex（用于第二层高光sparkling）</li>
<li>模型需求：多边形建模，面片之间具有层次，且按照距表皮的距离进行排序合并；</li>
</ol>
<blockquote>
<p>碎碎念：没想到Kajiya模型竟然还中了2004年SIGGRAPH，牛批牛批！</p>
</blockquote>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://developer.amd.com/wordpress/media/2012/10/Scheuermann_HairSketchSlides.pdf">Practical Real-Time Hair Rendering and Shading</a></li>
<li><a href="http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf">Hair Rendering and Shading</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[皮肤渲染之Screen Space Separable Subsurface Scattering]]></title>
        <id>https://wingstone.github.io/post/pi-fu-xuan-ran-zhi-screen-space-separable-subsurface-scattering/</id>
        <link href="https://wingstone.github.io/post/pi-fu-xuan-ran-zhi-screen-space-separable-subsurface-scattering/">
        </link>
        <updated>2020-09-16T03:31:29.000Z</updated>
        <content type="html"><![CDATA[<p>总体来说，渲染步骤为：</p>
<ol>
<li>首先对于不同的皮肤散射颜色，去计算相应的kernel（作为一维的颜色数组，存储该距离下次表面散射贡献），kernel是通过多层高斯曲线去拟合偶极子曲线得到的，因此需要多次高斯叠加计算；kernel的长度大小对应模糊的范围，也对应采样数的大小；</li>
<li>正常渲染皮肤，但要使用MRT，将diffuse成分与specular分离，并使用stencil进行标记；</li>
<li>在相机的BeforeImageEffectsOpaque时，进行皮肤部分的separable blur，并使用stencil test，保证只在皮肤部分进行blur；blur时要使用前面计算出来的kernel以及模型的曲率（借助深度的ddx、ddy计算），依据曲率来调整实际blur的范围；</li>
<li>将MRT进行合并，即blur后的diffuse部分与specular部分进行结合；</li>
</ol>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="http://iryoku.com/separable-sss/">Separable Subsurface Scattering</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin">Advanced Techniques for Realistic Real-Time Skin Rendering</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图形学资源推荐]]></title>
        <id>https://wingstone.github.io/post/tu-xing-xue-zi-yuan-tui-jian/</id>
        <link href="https://wingstone.github.io/post/tu-xing-xue-zi-yuan-tui-jian/">
        </link>
        <updated>2020-09-15T08:10:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="离线渲染">离线渲染</h2>
<ol>
<li><a href="https://www.pbrt.org/index.html">Physically Based Rendering:From Theory To Implementation</a>：大名鼎鼎的《基于物理的渲染：从理论到实现》，离线学习必看，包含了各种光线追踪中用到的技术！官网还提供了第三版书籍的<a href="http://www.pbr-book.org/">网页版</a>供免费看；</li>
</ol>
<h2 id="实时渲染">实时渲染</h2>
<ol>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/contributors">GPU Gems1-3部曲</a>：学习GPU编程必备系列，学习如何编写shader来实现各种实时渲染技术；</li>
<li><a href="http://advances.realtimerendering.com/">Advances in Real-Time Rendering in 3D Graphics and Games</a>：SIGGRAPH中的课程系列，介绍每一年中关于实时计算机图形学中的高级渲染技术；</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pipeline——Render Pipeline/Path（渲染管线/路径）]]></title>
        <id>https://wingstone.github.io/post/xuan-ran-guan-xian/</id>
        <link href="https://wingstone.github.io/post/xuan-ran-guan-xian/">
        </link>
        <updated>2020-09-14T06:51:39.000Z</updated>
        <content type="html"><![CDATA[<p>Render Path称之为渲染路径更为合适，实际上指渲染一帧所要走的流程，这个流程主要用来处理光照，以及后处理等；常见的有Forward/Deferred Rendering；以及其改版Forward+、Tiled Based Deferred Rendering、Clustered Shading；以及更灵活的Frame Graph（寒霜引擎）、SRP（Unity引擎）；</p>
<p>注意：在render之前，一般还会有一个Application stage，用以在CPU上运行一些必要的前置任务：如碰撞检测、全局加速算法（视锥剔除、遮挡剔除）、物理模拟、动画效果等等；处理完这些后，才能进行高效合理的渲染；</p>
<h2 id="forward-rendering">Forward Rendering</h2>
<p>总的来说，前向渲染绘制次数为光源个数乘以物体个数，通常在一个pass中处理一个光源；然后多个pass处理多个光源，并在pass中通过blend add相加得到总的光照效果；</p>
<p><strong>DC复杂度为O(num(obj)*num(light))</strong>，通常会限制light的数量来减少DC；</p>
<p>更甚者，会将限制光源数量（一般附加光源数量为4），并将所有的光照写进一个Uber Shader，通过传递光照参数来实现；</p>
<h3 id="z-prepass避免overdraw问题">Z-Prepass避免overdraw问题</h3>
<p>具体来说，在实际渲染之前，加入了一个称之为z prepass的流程，这个流程关闭了color buffer的写入，同时pixel shader极为简单或者索性为空，可以非常快速的执行完毕并且获得场景中的z buffer；紧接着，我们再关闭z buffer的写入，改depth test function为equal。这样就只绘制我们所能看到的像素了（当然只针对于不透明问题）；</p>
<h2 id="deferred-rendering">Deferred Rendering</h2>
<p>得益于MRT的支持，我们可以发展处延迟渲染，它的核心技术是 <strong>第一阶段</strong> 在绘制物体时将光照所需要的的basecolor、normal、smoothness等信息存储于G-buffer中，而不进行真正的光照；待物体绘制完后， <strong>第二阶段</strong> 再重新使用G-buffer进行光照的计算（及将光照的计算进行推迟）；</p>
<p>传统的延迟渲染在G-Buffer生成之后，会根据光源的形状（light volume），对每个光源执行一次draw call，如果某个像素被light volume覆盖到了，我们就在该像素的位置执行一次当前光源的lighting计算。</p>
<p>需要注意的是，为了防止同一像素被光源正反面计算两次，我们需要在绘制light volume的时候使用单面渲染，如果摄像机在光源内，则需要开启正面剔除，并且将depth test设置为farOrEqual，如果摄像机在光源之外，则开启背面剔除，并且将depth test设置为nearOrEqual。</p>
<p><strong>DC的复杂度为O(num(obj)+num(light))</strong>；num(obj)为前期绘制物体的数量，num(light)为后期光照时光源的数量；在光照渲染时，同样通过blend add来实现多光源效果的叠加；</p>
<p>一种简单但耗费资源的做法：可以直接将所有光源信息传至一个shader，在这一个shader中进行所有光源的计算与累积，由于是在整个屏幕中进行计算，也就导致会产生多余的光照计算（光源照不到区域也进行了计算）；优点是只有O(1)的复杂度进行光照计算；</p>
<p>另外，G-Buffer除了用于直接照明外，还能够被用于一些间接照明的效果，比如SSAO，SSR；也正是G-Buffer概念的提出，使得近十年来越来越多的算法从world space向screen space的演进；</p>
<h2 id="light-pre-pass">Light Pre-Pass</h2>
<p>Light Pre-Pass是Deferred Rendering的一个变种，它将整个渲染流程分为<strong>三个阶段</strong>：</p>
<ol>
<li>只在G-Buffer中存储Z值和Normal值。对比Deferred Render，少了Diffuse Color， Specular Color以及对应位置的材质索引值。</li>
<li>在FS阶段（对应于普通Deferred Rendering的light volume绘制阶段）利用上面的G-Buffer计算出所必须的light properties，比如Normal*LightDir,LightColor,Specular等light properties。将这些计算出的光照进行blend add并存入LightBuffer（就是用来存储light properties的buffer）。</li>
<li>最后将结果送到forward rendering渲染方式计算最后的光照效果；采用Front to Back的绘制顺序，以及前面的LightBuffer进行光照计算；</li>
</ol>
<p>可以看到光照相关的light properties已经在第二阶段计算过了，第三阶段更多是光照成分的组合，因此又称之为Light Pre-Pass；总体的<strong>DC复杂度为O(num(obj)+num(light)+num(obj))</strong>，分别对应第一二三阶段；</p>
<p>相对于传统的Deferred Render，Light Pre-Pass第三步使用的其实是forward rendering，所以可以对每个mesh设置其材质，这两者是相辅相成的，有利有弊。另一个Light Pre-Pass的优点是在使用MSAA上很有利。</p>
<h2 id="tiled-based-deferred-rendering-forward">Tiled Based Deferred Rendering &amp; Forward+</h2>
<p>实际上TBDR和Forward+是tiled based方法在forward和deferred上各自的体现，相较于过去的管线，TBDR和Forward+增加了一个 <strong>light culling</strong> 的流程，这个流程把整个屏幕分割成若干个tile（通常每个tile是16*16个pixel），每个tile各自计算出一个单独的<strong>light list</strong>，找出场景中那些对当前tile有贡献的光源。然后对每个tile中的pixel，只需要计算其对应的tile中light list内的光源对该像素的贡献。</p>
<h3 id="tbdr">TBDR</h3>
<p><strong>light culling</strong> 后的光照计算过程，是在一个Computer shader中进行计算，针对每个tile，采用Deferred rendering只需累加相应light list的光照即可；<strong>不考虑tile数量，DC复杂度为O(1)</strong>；</p>
<p>由于只读取一次G-buffer，大大减少了带宽的影响；</p>
<h3 id="forward">Forward+</h3>
<p><strong>light culling</strong> 后的光照计算过程，针对每个tile里的物体，采用Forward rendering在一个shader中累加相应light list的光照即可；<strong>不考虑tile数量，复杂度为O(num(obj))</strong>；</p>
<p>与普通的Forward Rendering相比，其大大减少了DC的数量（因为所有的light都合到一个pass中进行了计算）；</p>
<p>另外，<strong>Z-Prepass</strong>对于Forward+来说是必须的，其大大减弱了Overdraw所带来的性能损耗；毕竟在Forward Rendering+流程中一个pass中进行了大量的light的运算；</p>
<h2 id="clustered-shading">Clustered Shading</h2>
<p>TBDR和Forward+使用平面上的tile进行light culling，每一个tile的深度为Z-Near（摄像机近平面）到Z-Far（摄像机远平面）；这样同样会产生问题，即物体对应的像素可能并不会被深度相差太远的光源给照到，因此针对深度上应该再进行一次light culling；</p>
<p>clustered shading就此产生，其给light list的划分增加了一个维度，即depth，它根据view frustum的zmin，zmax把场景进一步根据depth划分成若干个slice（基于指数的划分，通常16个），然后在每个slice上对场景中的所有灯光进行light culling；</p>
<p>在实际shading的时候，每个像素根据自己的depth和screen position，找到对应的depth slice，从3D Texture里拿到offset和num lights，再执行一个num lights次循环；</p>
<h2 id="unity-scriptable-render-pipelinesrp可编程渲染管线">Unity Scriptable Render Pipeline（SRP可编程渲染管线）</h2>
<p>Unity SRP实际上是对底层渲染API进行了封装，并且结合unity内部的渲染模块，提供了一个相对高级的可编程化的渲染管线；用户可以使用SRP编写适合自己产品的Render Pipeline；不过要想自定义SRP，必须要对已有的管线有深入了解，才能编写出高效的管线；</p>
<p>在Unity SRP出现之前，Unity提供的是不可更改的standard built-in pipeline；Unity SRP出现后，Unity还提供了两个已经相对标准且开源的基于SRP的管线，<strong>URP与HDRP</strong>；URP主要侧重于通用平台下的渲染，支持多平台；HDRP主要侧重高端平台下的渲染（大量使用了Computer Shader），普通平台支持不了；</p>
<h2 id="frame-graph">Frame Graph</h2>
<p>随着时代的发展，内置固化的渲染管线架构已经越来越不能满足行业发展的需求，具体表现在以下几个方面：</p>
<ol>
<li>多样化的游戏画面表现需求：有的写实，有的卡通，有的更加风格化，这就要求引擎的渲染管线能具有相应的可调整的能力；</li>
<li>不同平台的软硬件能力差异：比如 PC、主机硬件能力更强，需要有更高端的画面表现，试图通过一种渲染流程来充分发挥每个平台的优势以及消除劣势，是一件非常困难的事情；</li>
<li>Rendering Path 的不断进化：即前面介绍的各种render path；</li>
<li>新的渲染技术：近年来的 VR\AR\XR 渲染技术对渲染管线提出了特定的需求，一套管线已经很难做到完全兼容这些渲染机制。在 2018 年微软发布了革命性的 DirectX RayTracing，这更是完全不同Rendering\Computing 机制。</li>
</ol>
<p>通过上述几点，说明传统的固定功能的渲染管线架构已经不再适合未来游戏发展的需求，如果重新设计引擎的渲染管线，必须要考虑到渲染管线的可扩展性、可配置性、甚至是 Data-Driven 的。</p>
<p><strong>Frostbite：Frame Graph（FG）<strong>就此产生，FG 由</strong> RenderPass</strong> 以及其依赖的 **Resource **组成。RenderPass 定义了一个完整的渲染操作，Resource 包括了 RenderPass 使用的 PSO、Texture、RenderTarget、ConstantBuffer、Shader 等资源。每个 RenderPass 都有 Input 和 Output 资源，这样 RenderPass 和 Resource 就形成了有向非循环图（DAG）结构，因为描述的是引擎在一帧内的渲染流程，所以称之为 Frame Graph。</p>
<p>更详细的Frame Graph接受看<a href="https://www.cnblogs.com/username/p/8497150.html">这里</a>；</p>
<p>在 RG 中，每个 RenderPass（RP） 包含三个重要阶段：</p>
<ol>
<li>Setup 阶段，主要用于定义输入和输出所使用的资源，比如 RenderTarget、Buffer 等。</li>
<li>Compile 阶段，根据 Setup 所定义的资源，来决定真正需要执行的 RP 执行路径图，并且裁剪掉不需要执行的 RP 依赖资源。</li>
<li>Execute 阶段，是真正执行 RP 渲染逻辑的阶段。在这个阶段可以直接调用渲染 API 将 Render Command 和 GPU 资源提交到渲染设备中，完成真正的渲染。</li>
</ol>
<p>Setup 一般只需要执行一次，Execute 每帧都需要执行，Compile 可根据情况执行多次，比如某个 RP 根据配置动态变化，这时需要重新 Compile，以获得变化后的 RP 执行路径图。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pipeline——GPU Graphic Pipeline（图形管线）]]></title>
        <id>https://wingstone.github.io/post/gpu-graphic-pipeline/</id>
        <link href="https://wingstone.github.io/post/gpu-graphic-pipeline/">
        </link>
        <updated>2020-09-13T01:14:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="管线介绍">管线介绍</h2>
<p>所谓管线就是一个流程，针对硬件来说，处理一个图元有一个硬件渲染流程<strong>Graphic Pipeline（图形管线）</strong>；针对实际应用来说，渲染一帧画面也需要一个渲染流程<strong>Render Pipeline/Path（渲染管线/路径）</strong>；Graphic Pipeline处于更加低级的渲染层次，是渲染一个物体必走的渲染流程；</p>
<h2 id="gpu-graphic-pipeline">GPU Graphic Pipeline</h2>
<p>具体的管线流程要看实际的硬件驱动，Direct3D每一个版本都有很大的改动，这里以Direct3D11为例进行介绍；具体的文章参考可以看这里：<a href="https://docs.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-graphics-pipeline">Direct3D 11 Graphics Pipeline</a>，<a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/pipelines-and-shaders-with-directx-12">Direct3D 12 Graphics Pipeline</a>；</p>
<h3 id="input-assembler-stage图元装配阶段">Input-Assembler Stage（图元装配阶段）</h3>
<p>这一阶段主要进行图元的装配，先从用户填充的缓冲中读取数据，然后将数据装配成图元；此阶段可装配成不同的图元类型（如 line lists, triangle strips, or primitives with adjacency）</p>
<h3 id="vertex-shader-stage顶点着色阶段">Vertex Shader Stage（顶点着色阶段）</h3>
<p><strong>一个可编程shader阶段</strong>，此阶段主要处理IA阶段输入的顶点，执行每顶点的处理（如变换、蒙皮、变形，顶点光照等）；VS阶段总是处理单一顶点，并输出单一顶点；VS阶段必须处于激活状态，VS必须提供；</p>
<h3 id="tessellation-stages细分阶段">Tessellation Stages（细分阶段）</h3>
<p>该阶段实际上有三个小阶段来完成图元的细分；通过硬件实现细分，GPU Graphic Pipeline能将低细节的模型转换为高细节模型进行渲染；</p>
<h4 id="hull-shader-stage壳着色阶段">Hull-Shader Stage（壳着色阶段）</h4>
<p><strong>一个可编程shader阶段</strong>，用来生成一个patch（和patch constants），每个patch对应一个输入的patch（quad, triangle, or line）；有点像一个基本的图元类型；</p>
<h4 id="tessellator-stage">Tessellator Stage</h4>
<p>一个固定处理阶段，用来生成简单格式的域，一个域代表一个geometry patch并用来生成更小物体的集合（triangles, points, or lines），通过连接domain sample来实现；</p>
<h4 id="domain-shader-stage域着色阶段">Domain-Shader Stage（域着色阶段）</h4>
<p><strong>一个可编程shader阶段</strong>，用来计算每个domain sample的顶点的位置，</p>
<h3 id="geometry-shader-stage几何着色阶段">Geometry Shader Stage（几何着色阶段）</h3>
<p><strong>一个可编程shader阶段</strong>，该阶段同样以顶点作为输入，以顶点作为输出；但与VS有很大不同；</p>
<ol>
<li>输入顶点数不一定为一，输入顶点数刚好可以可组成一完整图元（two vertices for lines, three vertices for triangles, or single vertex for point）；并且可以携带邻接的图元顶点数据（an additional two vertices for a line, an additional three for a triangle）；</li>
<li>输出顶点数不一定为一，输出的顶点数目可以形成特定的拓扑结构即可，输出的拓扑结构可选（GS stage output topologies available are: tristrip, linestrip, and pointlist）；</li>
</ol>
<h3 id="stream-output-stage流输出阶段">Stream-Output Stage（流输出阶段）</h3>
<p>该阶段的目的在于能够从不断的GS阶段输出顶点数据，至一个或多个缓存中；</p>
<h3 id="rasterizer-stage光栅化阶段">Rasterizer Stage（光栅化阶段）</h3>
<p>此阶段，将每个图元光栅化为像素，通过顶点差值来计算像素信息；光栅化过程总是运行顶点裁剪，透视除法，将顶点转换为齐次裁剪空间，然后将顶点映射到视口上；</p>
<h3 id="pixel-shader-stage像素着色器阶段">Pixel Shader Stage（像素着色器阶段）</h3>
<p><strong>一个可编程shader阶段</strong>，该阶段能够使用更加丰富的着色技术（每像素光照，后处理效果）；该阶段能够将常量，纹理数据，顶点差值数据以及其他数据进行计算，从而产生像素的输出；</p>
<h3 id="output-merger-stage输出合并阶段">Output-Merger Stage（输出合并阶段）</h3>
<p>该阶段生成最终的像素颜色，通过管线状态的整合，即：PS阶段生成的数据，如render target、depth/stencil buffer；OM阶段是用来决定可见颜色的最后一步，并且会Blend最终的像素颜色；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Opengl Vertex Interpolation]]></title>
        <id>https://wingstone.github.io/post/opengl-vertex-interpolation/</id>
        <link href="https://wingstone.github.io/post/opengl-vertex-interpolation/">
        </link>
        <updated>2020-09-10T06:39:18.000Z</updated>
        <content type="html"><![CDATA[<p>OpenGL中关于插值问题</p>
<h2 id="opengl中关于插值问题">OpenGL中关于插值问题</h2>
<p>在GPU的光栅化阶段，会针对每个片段进行插值计算；需要注意的是，这个时候进行的插值不能是简单的screen space线性插值，而应该是透视空间矫正的view space线性插值；</p>
<p>OpenGL中默认的是透视插值，也就是在view space空间中的线性插值，可以给变量加no perspective in/out使其插值时不做透视矫正，也就不线性了。如果要自定义插值方式，只能自己把相关参数都传到片元shader里计算了。</p>
<blockquote>
<p>注意：透视矫正插值仍是线性的，只不过是screen space下等距的线性插值，转换为view space下的非等距的线性插值，也是view space空间上的线性插值；</p>
</blockquote>
<h2 id="透视插值的公式推导">透视插值的公式推导</h2>
<p>参考《3D游戏与计算机图形学中的数学方法》4.4节</p>
<p>简单概括就是：</p>
<p>对于深度插值：由相似三角形变换可以得到，Z的倒数在光栅化时，恰好是按照线性进行插值的；</p>
<p>对于顶点属性插值：也能推导出：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>3</mn></msub><mo>=</mo><mfrac><mrow><mfrac><msub><mi>b</mi><mn>1</mn></msub><msub><mi>z</mi><mn>1</mn></msub></mfrac><mo>(</mo><mn>1</mn><mo>−</mo><mi>t</mi><mo>)</mo><mo>+</mo><mfrac><msub><mi>b</mi><mn>2</mn></msub><msub><mi>z</mi><mn>2</mn></msub></mfrac><mi>t</mi></mrow><mrow><mfrac><mn>1</mn><msub><mi>z</mi><mn>1</mn></msub></mfrac><mo>(</mo><mn>1</mn><mo>−</mo><mi>t</mi><mo>)</mo><mo>+</mo><mfrac><mn>1</mn><msub><mi>z</mi><mn>2</mn></msub></mfrac><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">b_3 = \frac{\frac{b_1}{z_1}(1-t)+\frac{b_2}{z_2}t}{\frac{1}{z_1}(1-t)+\frac{1}{z_2}t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9115159999999998em;vertical-align:-1.180208em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7313079999999998em;"><span style="top:-2.264892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.8351em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.180208em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>也就是说，顶点属性的插值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">b/z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>的线性插值再除以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">1/z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>的线性插值；</p>
<h2 id="为什么像素插值光照要优于顶点插值光照">为什么像素插值光照要优于顶点插值光照</h2>
<p>是因为顶点插值光照是线性插值（当然指透视矫正后）的，但是对于向量只是进行线性插值是不够的，还应该有个归一化阶段；</p>
<p>像素插值光照可以在PS中进行向量的归一化（特别是法向量），如此就纠正了向量插值的错误问题，然后可进行正确的光照；</p>
<p>其次光照计算过程并不是一个线性的过程；对计算结果进行线性插值，当然就不可能得到正确的光照效果；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ECS Architecture]]></title>
        <id>https://wingstone.github.io/post/ecs-architecture/</id>
        <link href="https://wingstone.github.io/post/ecs-architecture/">
        </link>
        <updated>2020-09-10T06:38:33.000Z</updated>
        <content type="html"><![CDATA[<p>ECS架构介绍</p>
<h2 id="ecs架构介绍">ECS架构介绍</h2>
<p><strong>ECS</strong> ，即 <strong>Entity-Component-System（实体-组件-系统）</strong> 的缩写，其模式遵循 <strong>组合优于继承</strong> 原则，游戏内的每一个基本单元都是一个 <strong>实体</strong> ，每个 <strong>实体</strong> 又由一个或多个 <strong>组件</strong> 构成，每个 <strong>组件</strong> 仅仅包含代表其特性的 <strong>数据（即在组件中没有任何方法）</strong> ，<strong>系统</strong> 便是来处理拥有一个或多个相同组件的实体集合的工具，其只拥有 <strong>行为（即在系统中没有任何数据）</strong> 。</p>
<p><strong>实体与组件是一个一对多的关系</strong> ，实体拥有怎样的能力，完全是取决于其拥有哪些组件，通过动态添加或删除组件，可以在（游戏）运行时改变实体的行为。</p>
<h2 id="ecs详解">ECS详解</h2>
<h3 id="实体">实体</h3>
<p>实体是游戏中的一个独特物体，使用一个ID进行表示和标记；</p>
<h3 id="组件">组件</h3>
<p>一个组件是一个数据的集合，不存在任何方法；一个经典的实现是使用 <strong>继承（或实现）同一个基类（或接口）</strong> ，这样就可以在运行时动态的添加和移除；</p>
<p>根据设计需求，有时在全局上下文中只有一个特殊的组件，这种组件一般称之为 <strong>Singleton Component（单例组件）</strong> ；</p>
<h3 id="系统">系统</h3>
<p>系统便是ECS架构中用来 <strong>处理游戏逻辑</strong> 的部分。一个系统就是对拥有一个或多个相同组件的实体集合进行操作的工具，它只有行为，没有状态，即不存放任何数据。OW差不多拥有上百个系统；</p>
<p>由于代码逻辑分布于各个系统中，各个系统之间为了解耦又不能互相访问，那么如果有多个系统希望运行同样的逻辑，该如何解决，总不能把代码复制 N 份，放到各个系统之中。 <strong>UtilityFunction（实用函数）</strong> 便是用来解决这一问题的，它将被多个系统调用的方法单独提取出来，放到统一的地方，同系统一样， <strong>UtilityFunction</strong> 中不能存放状态，它应该是拥有各个方法的纯净集合。</p>
<h2 id="ecs架构优点">ECS架构优点</h2>
<ol>
<li>性能优势：ECS带来的两大性能优势，就是cache友好，以及易于做多线程并行。</li>
<li>数据与行为分离：修改方便，逻辑清晰；</li>
</ol>
<h2 id="oop面向对象架构">OOP（面向对象）架构</h2>
<p>传统的很多游戏引擎是基于 <strong>面向对象</strong> 来设计的，游戏中的东西都是对象，每个对象有一个叫做 <strong>Update</strong> 的方法，框架 <strong>遍历所有的对象</strong> ，依次调用其 <strong>Update</strong> 方法。有些引擎甚至定义了多种 <strong>Update</strong> 方法，在同一帧的不同时机去调用。</p>
<h2 id="unity引擎的架构">Unity引擎的架构</h2>
<p>Unity的设计思想为 <strong>基于组件</strong> 的对象模型；<strong>基于组件</strong> 的对象模型就是把所有需要提供给游戏对象的基础功能都独立成单独的 <strong>组件模块(Component)</strong> ，一个具体的游戏对象可以将它需要的功能模块组合到一起使用。所有 <strong>功能</strong> 不再是父类中的接口，而变成子对象实例，为游戏对象提供服务。</p>
<p>在Unity中， <strong>GameObject</strong> 除了作为 <strong>Component</strong> 的容器之外，基本上没有其他功能。所有需要的功能都要通过 <strong>组合Component</strong> 来实现。虽然这些 <strong>Component</strong> 在物理上是完全并列的关系，但是他们之间还是会有一定的层次关系的。在设计一个游戏对象的具体功能时，组件一般会被分为三个层次。</p>
<ol>
<li><strong>引擎的基础组件</strong>：Unity本身提供的各种内部功能组件。比如渲染组件，物理组件，声音组件等等。</li>
<li><strong>模块功能脚本组件</strong>：通过脚本实现的一些相对独立的通用模块功能的组件。这类组件的设计是脚本可重用的关键，需要仔细分析游戏对象中哪些功能可以被独立出来成为一个可重用的功能模块组件，并且在实现上应该尽量降低与其他组件的耦合性。</li>
<li><strong>高层的胶水代码脚本</strong>：这些脚本用来真正将引擎基础组件和模块功能组件组合到一起实现最终游戏对象逻辑。用“胶水代码”来形容这些脚本非常的贴切，就是把所有这些子功能“粘”在一起。</li>
</ol>
<h3 id="unity的架构与ecs架构的区别">Unity的架构与ECS架构的区别</h3>
<p>可以看出Unity的架构与ECS架构并不一样，虽然在组件-实体这一部分有很大的相似性；</p>
<ol>
<li>Unity的每个组件含有相应的方法，数据与行为并没有实现完全的解耦；</li>
<li>Unity没有那么多系统（毕竟Unity只提供最基本的功能而已），系统也并不是只提供行为而已；</li>
</ol>
<h3 id="unity所带的ecs插件包">Unity所带的ECS插件包</h3>
<ol>
<li><a href="https://github.com/sschmid/Entitas-CSharp">Entitas插件系统</a></li>
<li>UnityPackages Managers下的Entities插件包</li>
</ol>
<blockquote>
<p>注意：实际上，使用哪种架构模式还是得根据具体情况；ECS并不是万能的，局限性<a href="https://www.zhihu.com/question/286963885/answer/456710929">参考这里</a></p>
</blockquote>
<h2 id="reference">Reference</h2>
<ol>
<li>
<p><a href="https://www.gdcvault.com/play/1024001/-Overwatch-Gameplay-Architecture-and">守望先锋GDC源视频分享连接</a>（视频）</p>
</li>
<li>
<p><a href="https://gameinstitute.qq.com/community/detail/114516">守望先锋GDC源视频中文翻译</a>（文章）</p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/30538626">一个ECS系统的介绍及简易实现</a>（文章）</p>
</li>
<li>
<p><a href="https://blog.codingnow.com/2017/06/overwatch_ecs.html">一个关于ECS系统的深入理解</a>（文章）</p>
</li>
<li>
<p><a href="https://www.cnblogs.com/zhibolife/p/3620440.html">Unity3D引擎架构设计</a>（文章）</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ Static Usage]]></title>
        <id>https://wingstone.github.io/post/c-static-usage/</id>
        <link href="https://wingstone.github.io/post/c-static-usage/">
        </link>
        <updated>2020-09-07T06:37:51.000Z</updated>
        <content type="html"><![CDATA[<p>C++中的一些细节问题</p>
<h2 id="c语言中的static关键字">C语言中的static关键字</h2>
<h3 id="修饰全局变量全局函数">修饰全局变量，全局函数</h3>
<p>将限制该变量及函数的作用域为本文，不能实现连接时的跨文本使用；</p>
<pre><code class="language-C++">//file1.c
static int a = 10;      //变量作用范围限制在本文本作用域中

//file2.c
#include &lt;iostream&gt;

using namespace std;

extern int a;   //无法使用file1.c中的a变量

int main()
{
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt;endl;

    return 0;
}

</code></pre>
<h3 id="修饰局部变量">修饰局部变量</h3>
<p>在用static修饰局部变量后，该变量只在初次运行时进行初始化工作，且只进行一次；且该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。</p>
<pre><code class="language-c++">#include&lt;stdio.h&gt;

void fun()
{
    static int a=1;
    a++;
}

int main(void)
{
    fun();  //这里运行时，a会进行初始化，随后a++
    fun();  //这里运行时，只会运行a++
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>